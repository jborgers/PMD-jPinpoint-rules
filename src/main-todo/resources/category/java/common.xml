<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. Or use Lombok @EqualsAndHashCode, @Value or @Data. Also holds for inner classes.
            If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... , @Entity, Throwable and Executor objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,unpredictable" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:- top level class - not annotated that would make it a non-value object -:)
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(:- a getter with result type of a field -:)
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)
(:- and class has no equals or hashCode method -:)
and (not (ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='equals' or @Name='hashCode']))
(:- and class has a toString and #fields <= 1+#getters -:)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@SimpleName, 'Dto')]
or
(:- #fields == #getters -:)
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)]
]/.. (:-up to class -:)

(:- inner classes -:)
,
//ClassOrInterfaceBodyDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[(
ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='equals'])
)
and
((ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[1][ends-with(@SimpleName, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
)]
or
ancestor::ClassOrInterfaceBodyDeclaration[1]/Annotation//Name[@Image='Getter']
]/.. (:-up to class -:)
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Getters { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
}

@Getter
class LombokGetterBad { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";
}

@Getter
@EqualsAndHashCode
class LombokGetterGood {
    private String someState1 = "some1";
    private String someState2 = "some2";
}
            ]]>
        </example>
    </rule>

    <!-- not migrating this deprecated rule -->
    <!--rule name="MinimizeAttributesInSession"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java" 
          message="Attribute is set in the session, yet not removed. This may bloat the session." 
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tmsu01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="deprecated" value="true" type="Boolean" description="portlet and http sessions are hardly used anymore" />
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/MethodDeclaration[../..//(VariableDeclaratorId |ReturnStatement/Expression)[pmd-java:typeIs('javax.portlet.PortletSession') or pmd-java:typeIs('javax.servlet.http.HttpSession')]]
/Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'removeAttribute')]
)]]
,
//ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    PortletSession session; // same for HttpSession
    public void setAttribute(String name, Object obj) {
	    session.setAttribute(name, obj);                 // bad
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
}

class Good {
    PortletSession session; // same for HttpSession
	public void setAttribute(String name, final Object obj) {
		session.setAttribute(name, obj);
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
	public void removeAttribute(String name) {
		session.removeAttribute(name);
	}
}
            ]]>
        </example>
    </rule-->


    <!-- not migrating this deprecated rule -->
    <!--rule name="AvoidTimeUnitConfusionPMD7" since="7.0"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." 
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,confusing" type="String" description="classification"/>
            <property name="deprecated" value="true" type="boolean" description="developed for pre-release of PMD7"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//VariableDeclaratorId[preceding-sibling::PrimitiveType|../../PrimitiveType][ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')]
,
(: @Value :)
//Annotation[@SimpleName='Value']//StringLiteral[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule-->


    <!-- not migrating this deprecated rule -->
    <!--rule name="AvoidCalendar"
          language="java"
          message="A Calendar is inefficient in memory usage."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#imu01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use Date, Java 8+ java.time.[Local/Zoned]DateTime.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="deprecated" value="true" type="boolean" description="replaced by Sonar rule java:S2143"/>
            <property name="xpath">
                <value><![CDATA[
//(Type)[pmd-java:typeIs('java.util.Calendar')]
,
//Name[starts-with(@Image, 'Calendar.')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CalendarStuff {
    Calendar field1; // bad

    private Calendar bad1() {
        return Calendar.getInstance();
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
}
            ]]>
        </example>
    </rule-->


    <rule name="ImproperVariableName"
          language="java"
          message="Give variables and fields a meaningful name."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#m01">
        <description>Problem: Variables like 'var3' and fields like 'FOUR = 4', do not express what they are used for. This is bad for maintainability.&#13;
            Solution: Let variable names express what they are used for, like 'key' and 'MAX_KEYS = 4'
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,bad-practice,confusing" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaratorId[matches(@Name, 'VALUE|VAL|INTEGER|INT|LONG|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY', 'i')
(: not allowed only as uppercase :)
and (replace(@Name, 'VALUE|VAL|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '') = ''
   (: not allowed as lower and uppercase :)
   or replace(@Name, 'INTEGER|INT|LONG|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '', 'i') = '')
or starts-with(@Name, 'var') and number(substring-after(@Name, 'var'))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private static final int FOUR_ZERO_NINE_SIX = 4096; // bad
    private static int six = 6; // bad
    private int five = 6; // really bad
    private static final int SIXTIES_START = 1960; // good

    void bar() {
        String var1 = "baz"; // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReStreamingEnumValues"
          language="java"
          message="Avoid re-streaming enum values to find a value by a field."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc07">
        <description>Problem: the time to find element is O(n); n = the number of enum values. This identical processing is executed for every call. Considered problematic when n > 3.
            Solution: use a static field-to-enum-value Map. Access time is O(1), provided the hashCode is well-defined.
            For one String field, usually toString returns that field. Implement a fromString method to provide the reverse conversion by using the map.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
    //EnumDeclaration/EnumBody[count(EnumConstant) > 3]//MethodDeclaration/Block//PrimaryExpression
    [PrimaryPrefix/Name[@Image='Arrays.stream' or @Image='Stream.of']]
    [//PrimaryExpression/PrimaryPrefix/Name[@Image = 'values' or @Image = concat(ancestor::EnumDeclaration/@SimpleName, '.values')]]
    [PrimarySuffix[starts-with(@Image, 'find')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
// BAD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Stream.of(values()).filter(v -> v.toString().equals(name)).findAny(); // bad: iterates for every call, O(n) access time
    }
}

Usage: `Fruit f = Fruit.fromString("banana");`

// GOOD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private static final Map<String, Fruit> nameToValue =
            Stream.of(values()).collect(toMap(Object::toString, v -> v));
    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Optional.ofNullable(nameToValue.get(name)); // good, get from Map, O(1) access time
    }
}
            ]]>
        </example>
    </rule>

    <rule name="NonComparableMapKeys"
          language="java"
          message="Map keys should implement Comparable in order to make access fast."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc08">
        <description>Problem: If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access will be slow.
            Solution: Implement Comparable for your Map keys. Do not use classes for the keys which don't implement Comparable, like Thread, Class and Object. At least not for Maps which can grow large.
            Note that equals and hashCode must be implemented properly for the keys, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: check key/elem type in declaration :)
//Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.util.Map')]
(: first type argument does not implement Comparable :)
[TypeArguments/TypeArgument[1]/ReferenceType[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]]
,
(: for when key/elem type ise missing in declaration, check Map.put and Set.add :)
//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.put') and pmd-java:typeIs('java.util.Map')]]
/PrimarySuffix/Arguments/ArgumentList/Expression[1]
(: first arg does not implement Comparable :)
[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
 class Foo {
    Map<Object, String> oMap; // bad, Object does not implement Comparable
    Map<Thread, String> tMap; // bad, Thread does not implement Comparable

    Map oldStyleMap = new HashMap(); // cannot check here

    void putInOldStyleBad() {
        oldStyleMap.put(new Thread(), "value"); // bad
    }

    Map<Comparable, String> cMap; // good

    void putInOldStyleGood() {
        oldStyleMap.put("key", "value");
    }
}

            ]]>
        </example>
    </rule>

    <rule name="NonComparableSetElements"
          language="java"
          message="Set elements should implement Comparable in order to make access by element fast."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc09">
        <description>Problem: A Set is implemented with a Map. If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red-black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access by element will be slow. Iterating through the elements does not suffer from this slow access because no lookup by key in the map is involved.
            Access methods by element which are affected: contains[All], retainAll, remove[All].
            Solution: Implement Comparable for your own Set elements. Avoid using large Sets with elements of types which don't implement Comparable, like Thread, Class and Object. At least when using access by element.
            Note that equals and hashCode must be implemented properly for the elements, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
,
//(FormalParameter|LocalVariableDeclaration)/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import org.apache.hc.client5.http.HttpRoute; // does implement equals/hashCode yet *not* compareTo

class Foo {
  Set<String> strSet = new HashSet<>();
  List<String> strList = new ArrayList<>();
  Set<HttpRoute> fieldRouteSet = new HashSet<>(); // bad
  List<HttpRoute> routeList = new ArrayList<>();

  void byElemBad(Set<HttpRoute> paramRouteSet) { // bad
    paramRouteSet.retainAll(routeList);

    fieldRouteSet.contains(t);

    Set<HttpRoute> localRouteSet = new HashSet<>(); // bad
    localRouteSet.removeAll(routeList);
  }

  void otherCasesGood(Set<HttpRoute> paramRouteSet) {
    strSet.contains("bla");
    strSet.retainAll(strList);
    strSet.remove("other");
    paramRouteSet.iterator().next();
  }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFileStreaming"
          language="java"
          message="FileInputStream and FileOutputStream are not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio05">
        <description>Problem: With FileInputStream and FileOutputStream, file access is not buffered.
            The stream is read-from/written-to file byte by byte, where each operating system call has its overhead, which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use BufferedOutput/InputStream which has a buffer size of 8 kB by default to write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//Resource//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.FileInputStream') or pmd-java:typeIs('java.io.FileOutputStream')]
[not (ancestor::AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
[not (ancestor::TryStatement//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.io.*;

class BufferFileStreaming {
    void bad(String inputFilename, String outputFilename) {
        try (FileInputStream fis = new FileInputStream(inputFilename)) { // bad
            //use fis
        }
    }
    void good(String inputFilename, String outputFilename) {
        try (InputStream bfis = new BufferedInputStream(new FileInputStream(inputFilename))) { // good
            //use bfis
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFilesNewStream"
          language="java"
          message="Files.newInputStream or Files.newOutputStream is not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio06">
        <description>Problem: Files.newInputStream or Files.newOutputStream is not buffered.
            The stream is read from/written to file byte by byte, where each operating system call has its overhead which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use e.g. BufferedInputStream or BufferedOutputStream which has a buffer size of 8 kB to read/write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newOutputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedOutputStream')]) = 0]]
,
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newInputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedInputStream')]) = 0
and (not(.//PrimaryPrefix/Name[pmd-java:typeIs('org.apache.commons.io.IOUtils') and starts-with(@Image, 'IOUtils.read')]))
]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    OutputStream badO(String path) throws IOException {
        return java.nio.file.Files.newOutputStream(Paths.get(path)); // bad
    }
    OutputStream goodO(String path) throws IOException {
        return new BufferedOutputStream(java.nio.file.Files.newOutputStream(Paths.get(path)));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLoadingAllFromFile"
          language="java"
          message="Files.readAll methods load all bytes from a file into memory: a risk of memory problems."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: Files.readAllBytes and Files.readAllLines load all bytes from a file into the heap memory.
            This may result in an OutOfMemoryError crash, or long gc pauses and slow responses.
            Solution: Stream-through: use streaming all the way, don't store the whole thing in memory, don't use byte arrays.
            Often, functionality can be achieved in a streaming way.
            Note: not a problem for small files.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[@Image='Files.readAllBytes' or @Image='Files.readAllLines']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    void bad(Path path) {
        byte[] fileBytes = Files.readAllBytes(path); // bad
        List<String> fileLines = Files.readAllLines(path); // bad
        // process bytes / lines
    }
}

class Good {
    void good(Path in) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(in)) {
            String line = reader.readLine();
            // process line by line
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="HashCodeOnlyCallsSuper"
          language="java"
          message="hashCode only calls super."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: when equals is implemented, hashCode needs to be implemented, too; and if objects are equal, hashCode needs to be equal, too. If hashCode only calls super.hashCode, it is effectively not implemented.
            Strange things can happen, for instance, if super.hashCode calls Object.hashCode, it is unique for each object and when used in Set or as key in Map, equal objects can duplicate in Set, and keys not found in Map.
            Solution: implement hashCode properly, consistent with equals. Meet the equals and hashCode contracts. If objects are equal, hashCode needs to be equal, too. See Effective Java.
        </description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,correctness" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and @Public=true() and @Static=false()]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and MethodDeclarator/FormalParameters/@Size=0 and @Public=true() and @Static=false()]
/Block[count(./BlockStatement/Statement) = 1][count(.//ArgumentList) = 0]//PrimaryExpression[PrimaryPrefix[@SuperModifier=true()]]/PrimarySuffix[@Image='hashCode']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return super.hashCode(); // bad
    }
}

class Good {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingSecurityProviders"
          language="java"
          message="Avoid re-creating security providers, this is expensive."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuosf01">
        <description>Problem: Creating a security provider is expensive because of loading of algorithms and other classes. Additionally, it uses synchronized which leads to lock contention when used with multiple threads.
            Solution: This only needs to happen once in the JVM lifetime, because once loaded, the provider is typically available from the Security class. Create the security provider only once: only in case it is nog available from the Security class, yet.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[not((@Name='main' and @Static=true())or ../Annotation//Name/@Image='PostConstruct'
or .//IfStatement//EqualityExpression[@Operator='=='][
.//PrimaryExpression[pmd-java:typeIs('java.security.Provider')] and .//NullLiteral])]
//AllocationExpression[pmd-java:typeIs('java.security.Provider')]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.security.*;
import javax.crypto.*;
import org.bouncycastle.jce.provider.*;

class Foo {
    public Cipher initBlowfishBad() throws GeneralSecurityException {
        Security.addProvider(new BouncyCastleProvider()); // bad
        // build a Cipher
    }

    public Cipher initBlowfishGood() throws GeneralSecurityException {
        Provider bouncyCastleProvider = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);
        if (bouncyCastleProvider == null) {
            bouncyCastleProvider = new BouncyCastleProvider();
            Security.addProvider(bouncyCastleProvider);
        }
        // build a Cipher
    }
}
            ]]>
        </example>
    </rule>

</ruleset>
