<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common_std-rules"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>
<!--
    <rule name="LimitNestingInLambdas"
          language="java"
          message="Avoid deep nesting of lambdas in lambda expressions."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#isr05">
        <description>Problem: lambda expressions with deep nesting (lambda's in lambda's) are hard to understand and maintain.
            Solution: extract the lambda expression code block(s) into one or more well-named separate method(s).
            Note: A violation when the depth of lambda-with-code-block nesting exceeds (by default) 1,
            or the depth of lambda-single-expression in lambda nesting exceeds (by default) 4.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="brain-overload" type="String" description="for-sonar"/>
            <property name="tag" value="replaces-sonar-rule" type="String" description="for-sonar"/>
            <property name="param-block-max" value="1" type="String" description="Maximum allowed depth of lambda-with-code-block nesting"/>
            <property name="param-single-max" value="4" type="String" description="Maximum allowed depth of lambda-single-expression nesting"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//LambdaExpression[Block][count(ancestor::LambdaExpression/Block) > number($param-block-max)]
|
//LambdaExpression[Expression][count(ancestor::LambdaExpression) > number($param-single-max)]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    public Object singleExpressionLambdas(String a, String b) {
        return detect(a)
                .orElseGet(() -> single0(b)
                .orElseGet(() -> single1(b) // single nesting level 1
                .orElseGet(() -> single2(b)//   2
                .orElseGet(() -> single3(b)//   3
                .orElseGet(() -> singlet4(b)//  4
                .orElseGet(() -> single5(b)//  5 // bad
                .orElseGet(() -> single6(b))))))));//  6 // bad
    }

   public Object blockLambdas(String a, String b) {
        return detect(a)
                .orElseGet(() -> single0(b)
                .orElseGet(() -> {block0(b) // block nesting level 0
                .orElseGet(() -> {block1(b)//  1
                .orElseGet(() -> {block2(b)//  2 // bad
                .orElseGet(() -> single4(b)//  single nesting level 4 // good
                .orElseGet(() -> single5(b)));});});}));//  single nesting level 5, bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnusedAssignments"
          language="java"
          message="Avoid assignments for which the assigned value is never used."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#isr04">
        <description>Problem: Assignments to variables for which the assigned value is not used because a new value is assigned before actual use, is unnecessary work and may indicate a bug.
            Solution: remove the first assignment and make sure that is as intended.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="unused" type="String" description="for-sonar"/>
            <property name="tag" value="suspicious" type="String" description="for-sonar"/>
            <property name="tag" value="replaces-sonar-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: for each assignment node :)
(for $node in //StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name
(: match if for that node the next occurrence of ((assignment without use in same statement) union with (use) is an assignment to the var) :)
return ($node[
(: assignment without use, Name is result :)
((ancestor::BlockStatement/following-sibling::BlockStatement//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name[@Image=$node/@Image]
[not(ancestor::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='=']) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])]
)[1]
|
(: use, PrimaryPrefix is result, so @Image is empty string :)
(ancestor::BlockStatement/following-sibling::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='='] and not(PrimarySuffix/Expression)) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])[1])
(: first is the var name :)
[1]/@Image = $node/@Image])
)
,
(: for each local variable declaration :)
(for $node in (//LocalVariableDeclaration/VariableDeclarator[VariableInitializer]//VariableDeclaratorId)
(: match if for that node the next occurrence of ((assignment without use in same statement) union with (use) is an assignment to the var) :)
return ($node[
(: assignment without use, Name is result :)
((ancestor::BlockStatement/following-sibling::BlockStatement//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name[@Image=$node/@Name]
[not(ancestor::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='=']) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Name])]
)[1]
|
(: use, PrimaryPrefix is result, so @Image is empty string :)
(ancestor::BlockStatement/following-sibling::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='='] and not(PrimarySuffix/Expression)) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Name])[1])
(: first is the var name :)
[1]/@Image = $node/@Name])
)
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[

            ]]>
        </example>
    </rule>

    <rule name="AvoidForEachInStreams"
          language="java"
          message="Prefer side-effect-free functions in streams, use forEach only for logging."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ils01">
        <description>Problem: Streams is a paradigm based on functional programming: the result should depend only on its input and not update any state.
            Use of forEach is actually iterative code masquerading as streams code. It is typically harder to read and less maintainable than the iterative form.
            Solution: Use the for-each (enhanced-for) loop, or the pure functional form. The forEach operation should only be used to report (i.e. log) the result of a stream computation.
        </description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="bad-practice" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression[(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'forEach')]]
[not (./PrimarySuffix//MethodReference[starts-with(@Image, 'log')] or
./PrimarySuffix//PrimaryPrefix/Name[starts-with(lower-case(@Image), 'log')] or
./PrimarySuffix//LambdaExpression//PrimaryPrefix/Name[starts-with(@Image, 'log.')]
)]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
        // forEach in stream
        map = new HashMap<>();
        letters.forEach(l -> map.put(l, 0)); // bad, side effect, modifies map

        // reporting result by logging, good
        letters.forEach(Log::info);

        // iterative form, meant for modifying state, good
        map = new HashMap<>();
        for (String l : letters) {
            map.put(l, 0);
        }

        // pure functional form, good
        map = letters.stream().collect(toMap(l -> l, v -> 0));
            ]]>
        </example>
    </rule>
    -->
</ruleset>
