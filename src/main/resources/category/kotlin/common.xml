<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-remoting-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Kotlin coding, sponsored by Rabobank.</description>

    <rule name="AvoidInMemoryStreamingDefaultConstructor"
          since="7.0"
          language="kotlin"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>
            The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='io']][1]/ancestor::KotlinFile
//Expression//T-Identifier[(@Text='ByteArrayOutputStream' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=32]])
or (@Text='StringWriter' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=16]])]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
import java.io.ByteArrayOutputStream
import java.io.StringWriter

class AvoidInMemoryStreamingDefaultConstructor {
    fun bad() {
        var baos = ByteArrayOutputStream() //bad
        val sw = StringWriter() //bad
        baos = ByteArrayOutputStream(32) //bad - not larger than default // TODO
    }
    fun good() {
        val baos = ByteArrayOutputStream(8192) // 8 kiB
        val sw = StringWriter(2048)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule"
          since="7.0"
          language="kotlin"
          message="StringBuffer is used. It introduces locking overhead, use StringBuilder."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaration/Type//T-Identifier[@Text='StringBuffer'],
//Declaration//PrimaryExpression//T-Identifier[@Text='StringBuffer']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class AvoidStringBuffer {
    var fieldSb: StringBuffer? = null // bad
    fun bad() {
        val sb = StringBuffer() // bad
    }
    fun good() {
        val sb = StringBuilder()
    }
]]>
        </example>
    </rule>
    <rule name="AvoidDecimalAndChoiceFormatAsField"
          since="7.0"
          language="kotlin"
          message="Avoid using NumberFormat, DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>
            Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe.
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
(: check if at least one java.text imports exists as filter for same named classes in other packages :)
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='text']][1]/ancestor::KotlinFile
(: PrimaryExpression finds the constructors instead of type declarations :)
(: filter matches in functions :)
//ClassDeclaration//PrimaryExpression//SimpleIdentifier//T-Identifier[
 (@Text="DecimalFormat" or @Text="ChoiceFormat")
 and not(ancestor::FunctionDeclaration)
]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
class Foo {

    companion object {
        val NUMBER_FORMAT: DecimalFormat = DecimalFormat("###.###") // bad
    }

    private val numFormat: NumberFormat = DecimalFormat("###.###") //bad

    private val limits = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0)
    private val dayOfWeekNames = arrayOf("Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat")
    private val form = ChoiceFormat(limits, dayOfWeekNames) // bad

    fun shouldNotMatchInsideMethod() {
        val format: NumberFormat = DecimalFormat("##.##")
        val choiceFormat = ChoiceFormat(limits, dayOfWeekNames)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule"
          language="kotlin"
          message="XPathExpression is created and compiled every time. Beware it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[.//T-Identifier[@Text='javax'] and .//T-Identifier[@Text='xml'] and .//T-Identifier[@Text='xpath']]/ancestor::KotlinFile
//FunctionBody//T-Identifier[@Text='newXPath']
/ancestor::FunctionBody//T-Identifier[@Text='compile'
or @Text='evaluate' and ancestor::PostfixUnarySuffix/..//ValueArguments[count(./ValueArgument) = 3]]
(: note on limitation, the 2-argument version is not found, difficult to do the typeIs checking like in Java :)
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.w3c.dom.Document
import org.w3c.dom.NodeList
import javax.xml.xpath.*

class AvoidRecompilingXPathExpressionKotlin {
    fun bad1(doc: Document?): NodeList {
        val xpath: XPath = XPathFactory.newInstance().newXPath()
        val expr: XPathExpression = xpath.compile("//book[author='Isaac Asimov']/title/text()") // bad
        return expr.evaluate(doc, XPathConstants.NODESET) as NodeList
    }

    @Throws(XPathExpressionException::class)
    fun bad2(doc: Document?): NodeList {
        val xpath: XPath = XPathFactory.newInstance().newXPath()
        val xPathQuery = "//book[author='Isaac Asimov']/title/text()"
        return xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET) as NodeList // bad
    }
}

object GoodAvoidRecompilingXPathExpressionKt {
    private val tlFac = ThreadLocal.withInitial { XPathFactory.newInstance() }
    private val tlExpr: ThreadLocal<XPathExpression>

    init {
        val xpath = tlFac.get().newXPath()
        val expr: XPathExpression = try {
            xpath.compile("//book[author='Isaac Asimov']/title/text()")
        } catch (e: XPathExpressionException) {
            throw RuntimeException(e)
        }
        tlExpr = ThreadLocal.withInitial { expr } // good
    }

    @Throws(XPathExpressionException::class)
    fun good(doc: Document?): NodeList {
        return tlExpr!!.get().evaluate(doc, XPathConstants.NODESET) as NodeList // good
    }
}
            ]]>
        </example>
    </rule>

</ruleset>
