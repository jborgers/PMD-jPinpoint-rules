<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-remoting-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Kotlin coding, sponsored by Rabobank.</description>

    <rule name="AvoidInMemoryStreamingDefaultConstructor"
          since="7.0"
          language="kotlin"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>
            The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='io']][1]/ancestor::KotlinFile
//Expression//T-Identifier[(@Text='ByteArrayOutputStream' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=32]])
or (@Text='StringWriter' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=16]])]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
import java.io.ByteArrayOutputStream
import java.io.StringWriter

class AvoidInMemoryStreamingDefaultConstructor {
    fun bad() {
        var baos = ByteArrayOutputStream() //bad
        val sw = StringWriter() //bad
        baos = ByteArrayOutputStream(32) //bad - not larger than default
    }
    fun good() {
        val baos = ByteArrayOutputStream(8192) // 8 kiB
        val sw = StringWriter(2048)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule"
          since="7.0"
          language="kotlin"
          message="StringBuffer is used. It introduces locking overhead, use StringBuilder."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaration/Type//T-Identifier[@Text='StringBuffer'],
//Declaration//PrimaryExpression//T-Identifier[@Text='StringBuffer']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class AvoidStringBuffer {
    var fieldSb: StringBuffer? = null // bad
    fun bad() {
        val sb = StringBuffer() // bad
    }
    fun good() {
        val sb = StringBuilder()
    }
]]>
        </example>
    </rule>
    <rule name="AvoidDecimalAndChoiceFormatAsField"
          since="7.0"
          language="kotlin"
          message="Avoid using NumberFormat, DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>
            Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe.
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
(: check if java.text imports exists as filter for same named classes in other packages :)
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='text']]/ancestor::KotlinFile
(: PrimaryExpression finds the constructors instead of type declarations :)
(: filter matches in functions :)
//ClassDeclaration//PrimaryExpression//SimpleIdentifier//T-Identifier[
 (@Text="DecimalFormat" or @Text="ChoiceFormat")
 and not(ancestor::FunctionBody)
]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
class Foo {

    companion object {
        val NUMBER_FORMAT: DecimalFormat = DecimalFormat("###.###") // bad
    }

    private val numFormat: NumberFormat = DecimalFormat("###.###") //bad

    private val limits = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0)
    private val dayOfWeekNames = arrayOf("Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat")
    private val form = ChoiceFormat(limits, dayOfWeekNames) // bad

    fun shouldNotMatchInsideMethod() {
        val format: NumberFormat = DecimalFormat("##.##")
        val choiceFormat = ChoiceFormat(limits, dayOfWeekNames)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingPatterns"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="kotlin"
          message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a constant or instance field."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private constant or instance field.
            java.util.Pattern objects are thread-safe so they can be shared among threads. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
(: check if java.util.regex imports exists as filter for same named classes in other packages :)
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='util'] and .//T-Identifier[@Text='regex']][1]/ancestor::KotlinFile

//FunctionBody//T-Identifier[@Text='Pattern' and ../../../PostfixUnarySuffix//T-Identifier[@Text='compile']
    (: check for variables $action or ${action} in String of compile() call (first in possible call chain): allow dynamic input :)
    and not(((../../..//ValueArgument)[1]//PostfixUnaryExpression//T-Identifier|(../../..//ValueArgument)[1]//T-LineStrRef)[
       @Text=ancestor::FunctionDeclaration//FunctionValueParameter/Parameter/SimpleIdentifier/T-Identifier/@Text
       or @Text=concat('$', ancestor::FunctionDeclaration//FunctionValueParameter/Parameter/SimpleIdentifier/T-Identifier/@Text)])
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.regex.Pattern

internal object Bad {
    const val STR_PAT1: String = "[A-Z][a-z]+"

    fun bad() {
        val p1: Pattern = Pattern.compile(STR_PAT1) // bad
        val p2: Pattern = Pattern.compile("(?=\\p{Lu})") // bad
        val b: Boolean = p1.matcher("Start ").matches()
    }
}

internal object Good {
    val PAT1: Pattern = Pattern.compile("[A-Z][a-z]+")
    val PAT2: Pattern = Pattern.compile("(?=\\p{Lu})")

    fun good() {
        val b: Boolean = PAT1.matcher("Start ").matches()
    }
}
            ]]>
        </example>
    </rule>

</ruleset>
