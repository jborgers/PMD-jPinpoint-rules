<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by Contexts and Dependency Injection (CDI) for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        </description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[@MethodName='select']/MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyClause
    //MethodCall[@MethodName='destroy'][ArgumentList/VariableAccess[@Name=ancestor::
        MethodDeclaration//(VariableDeclarator|AssignmentExpression)[.//MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']]/(VariableId|VariableAccess)/@Name]]
    [MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']])
]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java" message="Interface defines constants. It may expose implementation details."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,bad-practice" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[@Interface=true()]/ClassBody/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface AnimalConsts {
    public static final Dog DOG = new Dog(); //bad
}
public class AnimalUtil {
    private AnimalUtil() {}
    public static final Dog DOG = new Dog(); // good
}
public enum Animal {
    DOG // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.NumberFormat: DecimalFormat and ChoiceFormat are thread-unsafe.&#13;
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
 //FieldDeclaration/ClassType[pmd-java:typeIs('java.text.NumberFormat')]
        ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    public static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("###.###"); // bad

    public void bar() {
        NumberFormat format = new DecimalFormat("###.###"); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected to have different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- assigned to same var in a previous switch case --:)
//SwitchStatement//SwitchFallthroughBranch/ExpressionStatement[AssignmentExpression[not(pmd-java:typeIs('boolean'))]/VariableAccess[1]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[1]/@Name
and (
(:-- assigning same var --:)
AssignmentExpression/VariableAccess[2]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[2]/@Name
or
(:-- assigning same literal --:)
AssignmentExpression/(StringLiteral|NumericLiteral)/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(StringLiteral|NumericLiteral)/@Image
or
(:-- assigning constructor with same argument or same argumentless method  --:)
AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image
)
(:--default case allowed to have duplicates --:)
and not (preceding-sibling::SwitchLabel[@Default=true()])]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe, so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(:- method calls for non-short regex literals and used fields defined with non-short regex literal, or not defined as field -:)
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.lang.String#replaceAll(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#replaceFirst(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.util.regex.Pattern#matches(java.lang.String,java.lang.CharSequence)')
    or pmd-java:matchesSig('java.lang.String#split(java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#matches(java.lang.String)')
    or pmd-java:matchesSig('java.nio.file.FileSystem#getPathMatcher(java.lang.String)')
]
/ArgumentList/*[1][(self::StringLiteral and string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')))
or
self::VariableAccess and @Name=ancestor::ClassBody/FieldDeclaration/VariableDeclarator[StringLiteral[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or not(StringLiteral)]/VariableId/@Name]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
//bad
String bad_replaceInnerLineBreakBySpace() {
    return text.replaceAll("([^\\.\\n])\\n", "$1 "); // bad
}

// good
private static final Pattern INNER_LINE_BREAK_PATTERN = Pattern.compile("([^\\.\\n])\\n");

String good_replaceInnerLineBreakBySpace() {
    return INNER_LINE_BREAK_PATTERN.matcher(text).replaceAll("$1 "); // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>Problem: The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Pre-size the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall[pmd-java:matchesSig('java.io.ByteArrayOutputStream#new()') or pmd-java:matchesSig('java.io.StringWriter#new()')
or
((pmd-java:matchesSig('java.io.ByteArrayOutputStream#new(int)') and (ArgumentList/NumericLiteral/@ValueAsInt <=32
        or ArgumentList/VariableAccess/@Name = ancestor::ClassBody/FieldDeclaration/VariableDeclarator[NumericLiteral/@ValueAsInt <= 32]/VariableId/@Name))
    or (pmd-java:matchesSig('java.io.StringWriter#new(int)') and (ArgumentList/NumericLiteral/@ValueAsInt <=16
        or ArgumentList/VariableAccess/@Name = ancestor::ClassBody/FieldDeclaration/VariableDeclarator[NumericLiteral/@ValueAsInt <= 16]/VariableId/@Name))
)
]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static void bad()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //bad
        StringWriter sw = new StringWriter(); //bad
        baos = new ByteArrayOutputStream(32); //bad - not larger than default
    }
}
class Good {
    public static void good()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); // 8 kiB
        StringWriter sw = new StringWriter(2048);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMultipleConcatStatements"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Multiple statements concatenate to the same String. Use StringBuilder append."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: x += y with only one preceding x += v or x = x + w :)
//AssignmentExpression[@Operator='+='][VariableAccess/@Name=ancestor::Block//VariableDeclarator/VariableId[pmd-java:typeIs('java.lang.String')]/@Name]
[(VariableAccess/@Name = ../preceding-sibling::ExpressionStatement/AssignmentExpression[@Operator='+=']/VariableAccess/@Name
or
VariableAccess/@Name = ../preceding-sibling::ExpressionStatement//InfixExpression[@Operator='+']/VariableAccess/@Name)
and not (
    VariableAccess/@Name = ../preceding-sibling::ExpressionStatement[2]/AssignmentExpression[@Operator='+=']/VariableAccess/@Name
    or
    VariableAccess/@Name = ../preceding-sibling::ExpressionStatement[2]//InfixExpression[@Operator='+']/VariableAccess/@Name
)
]
|
(: x = x + y with only one preceding x += v or x = x + w :)
//InfixExpression[@Operator='+'][VariableAccess/@Name=ancestor::AssignmentExpression/VariableAccess/@Name][VariableAccess/@Name=ancestor::Block//VariableDeclarator/VariableId[pmd-java:typeIs('java.lang.String')]/@Name]
[(VariableAccess/@Name = ancestor::ExpressionStatement/preceding-sibling::ExpressionStatement//InfixExpression[@Operator='+']/VariableAccess/@Name
or
VariableAccess/@Name = ancestor::ExpressionStatement/preceding-sibling::ExpressionStatement/AssignmentExpression[@Operator='+=']/VariableAccess/@Name)
and not (
    VariableAccess/@Name = ancestor::ExpressionStatement/preceding-sibling::ExpressionStatement[2]/AssignmentExpression[@Operator='+=']/VariableAccess/@Name
    or
    VariableAccess/@Name = ancestor::ExpressionStatement/preceding-sibling::ExpressionStatement[2]//InfixExpression[@Operator='+']/VariableAccess/@Name
)
]/..

	]]></value>
            </property>
        </properties>
        <example>
        <![CDATA[
class ConcatsExample {

    private String[] values = {"tic", "tac"};

    String bad() {
        String logStatement = "";
        logStatement += values[0];
        return logStatement += values[1]; // bad
    }
    String good() {
        StringBuilder logStmtBuilder = new StringBuilder();
        return logStmtBuilder.append(values[0]).append(values[1]).toString(); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingPatterns"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.util.regex.Pattern#compile(java.lang.String)')
and not(.//VariableAccess[@Name = ancestor::MethodDeclaration//FormalParameter/VariableId/@Name])]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe."
      externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPath#compile(java.lang.String)') or
    pmd-java:matchesSig('javax.xml.xpath.XPath#evaluate(java.lang.String,java.lang.Object,javax.xml.namespace.QName)')]
             ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static NodeList bad1(Document doc) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
        return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
    }
    public static NodeList bad2(Document doc) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        String xPathQuery = "//book[author='Isaac Asimov']/title/text()";
        return (NodeList) xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET); // bad
    }
}

class Good {
    private static final ThreadLocal<XPathFactory> tlFac = ThreadLocal.withInitial(XPathFactory::newInstance);
    private static final ThreadLocal<XPathExpression> tlExpr;
    static {
        XPath xpath = tlFac.get().newXPath();
        try {
            XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()");
            tlExpr = ThreadLocal.withInitial(() -> expr); // good
        } catch (XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }
    public static NodeList good(Document doc) throws XPathExpressionException {
        return (NodeList) tlExpr.get().evaluate(doc, XPathConstants.NODESET); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: Java 8+ java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration
[ClassType[pmd-java:typeIs('java.time.format.DateTimeFormatter') or pmd-java:typeIs('org.joda.time.format.DateTimeFormatter')]]
[(not(pmd-java:modifiers() = 'static') and VariableDeclarator[@Initializer=true()]) or not(pmd-java:modifiers() = 'final')]
|
//MethodDeclaration//ConstructorCall[pmd-java:matchesSig('org.joda.time.format.DateTimeFormatter#new(_,_)')]
|
//(MethodDeclaration|ConstructorDeclaration)//MethodCall[((pmd-java:matchesSig('java.time.format.DateTimeFormatter#ofPattern(_)')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormat#forPattern(_)'))
   and not(ArgumentList/VariableAccess/@Name = ancestor::Block/..//FormalParameter/VariableId/@Name))
 or pmd-java:matchesSig('java.time.format.DateTimeFormatterBuilder#toFormatter()')
 or pmd-java:matchesSig('java.time.format.DateTimeFormatterBuilder#toFormatter(_)')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormatterBuilder#toFormatter()')
 or pmd-java:matchesSig('org.joda.time.format.ISODateTimeFormat#_()')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormat#fullDateTime()')
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Reflection is used in toString or hashCode, which is expensive."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, like generation by IDE or Lombok.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[starts-with(@MethodName, 'reflection')][(TypeExpression|ConstructorCall)
    [pmd-java:typeIs('org.apache.commons.lang3.builder.EqualsBuilder') or pmd-java:typeIs('org.apache.commons.lang3.builder.HashCodeBuilder')]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    private int state;

    public boolean equals(Object o) {
        return EqualsBuilder.reflectionEquals(o, this); // bad
    }
}

class Good {
    private int state;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Good)) return false;
        return new EqualsBuilder().append(((Good)o).state, state).isEquals();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSimpleDateFormat"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall/ClassType[pmd-java:typeIs('java.text.SimpleDateFormat')
  and not ((ancestor::LocalVariableDeclaration/following-sibling::ExpressionStatement/MethodCall|ancestor::MethodCall)
    [@MethodName='setDateFormat']/VariableAccess[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
      or pmd-java:typeIs('com.fasterxml.jackson.dataformat.xml.XmlMapper')])
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private String toKeyBad(final Date date) {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd"); //bad
        return formatter.format(date);
    }
    private String toKeyGood(final LocalDate localDate) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); //good
        return formatter.format(localDate);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidStringBuffer"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="StringBuffer is used. It introduces locking overhead, use StringBuilder."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall/ClassType[pmd-java:typeIs('java.lang.StringBuffer')]
]]>
                </value>
            </property>
        </properties>
        <example>
class Foo {
    public void bad() {
        var sb = new StringBuffer(); // bad
    }
    public void good() {
        var sb = new StringBuilder(); // good
    }
}
        </example>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Log String is built irrespective of log level."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
[pmd-java:matchesSig('java.lang.StringBuilder#append(java.lang.String)')]
(: variable in append following used in logging :)
[VariableAccess/@Name=(ancestor::ExpressionStatement|ancestor::ForeachStatement|ancestor::DoStatement|ancestor::WhileStatement)
  /(following-sibling::TryStatement|following-sibling::ExpressionStatement)//MethodCall
  [@MethodName=('trace', 'debug', 'info')]
    [
    (: supported logger libs :)
    (VariableAccess[
        pmd-java:typeIs('org.slf4j.Logger')
        or pmd-java:typeIs('java.util.logging.Logger')
        or pmd-java:typeIs('org.apache.commons.logging.Log')
     ])
   or
     (: Slfj4 annotation makes the log variable AmbiguousName as there is no explicit log field :)
     (AmbiguousName[ancestor::ClassDeclaration[pmd-java:hasAnnotation('lombok.extern.slf4j.Slf4j')]])
  ]
    //VariableAccess/@Name
]
(: variable in append following, not used in anything other than logging :)
[not(
VariableAccess/@Name=(ancestor::ExpressionStatement|ancestor::ForeachStatement|ancestor::DoStatement|ancestor::WhileStatement)
  /(following-sibling::TryStatement|following-sibling::ExpressionStatement|following-sibling::ReturnStatement)//MethodCall
  [not(@MethodName=('trace', 'debug', 'info'))
  or VariableAccess[not(pmd-java:typeIs('org.slf4j.Logger')) and not(pmd-java:typeIs('java.util.logging.Logger')) and not(pmd-java:typeIs('org.apache.commons.logging.Log'))]]
    //VariableAccess/@Name
)]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
   public void bad(List values) {
        var logLine = new StringBuilder();
        for (String val : values) {
            logLine.append(val + ", "); // bad
        }
        LOG.debug("log: {}.", logLine);
    }
    public void good(List values) {
        if (LOG.isDebugEnabled()) {
            var logLine = new StringBuilder();
            for (String val : values) {
                logLine.append(val + ", ");
            }
            LOG.debug("log: {}.", logLine);
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidWideScopeXPathExpression"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPathExpression targets a wide scope, this is potentially slow."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPath#compile(java.lang.String)')]/ArgumentList/StringLiteral[starts-with(@Image, '"//')]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    public bad() throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
    }
    public good() throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("/public/library/books/book[author='Isaac Asimov']/title/text()");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidXPathAPIUsage"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPathAPI is used. XPathAPI implementation has bad performance."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall/TypeExpression/ClassType[pmd-java:typeIs('org.apache.xpath.XPathAPI')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPath is used. XPath implementation has bad performance."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPathFactory#newInstance()')]
[not (ancestor::FieldDeclaration/ClassType[pmd-java:typeIs('java.lang.ThreadLocal')])]
	]]></value>
            </property>
        </properties>
    </rule>


    <rule name="MDCPutWithoutRemove"
          message="MDC put is used without finally remove."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="correctness,jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#put(java.lang.String,java.lang.String)')]/ArgumentList/*[1][self::StringLiteral or self::VariableAccess]
[not(@Image=ancestor::TryStatement//FinallyClause//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#remove(java.lang.String)')]/ArgumentList/*[1]/@Image
or ancestor::TryStatement//FinallyClause//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#clear()')]
or @Image=ancestor::ClassBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#remove(java.lang.String)')]/ArgumentList/*[1]/@Image
or ancestor::ClassBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#clear()')]
)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalConcatInLogArgument"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="String concatenation (+) is executed regardless of log level and can be expensive"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
  [@MethodName=('trace','debug','info')]
  [
    (: supported logger libs :)
    (VariableAccess[
        pmd-java:typeIs('org.slf4j.Logger')
        or pmd-java:typeIs('java.util.logging.Logger')
        or pmd-java:typeIs('org.apache.commons.logging.Log')
     ])
   or
     (: Slfj4 annotation makes the log variable AmbiguousName as there is no explicit log field :)
     (AmbiguousName[ancestor::ClassDeclaration[pmd-java:hasAnnotation('lombok.extern.slf4j.Slf4j')]])
  ]
  /ArgumentList[.//InfixExpression[@Operator='+'][(VariableAccess|MethodCall)[pmd-java:typeIs('java.lang.String')] or (StringLiteral and (VariableAccess or MethodCall))]]
[not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
@slf4j
class Foo {
    void bad(String a, String b) {
        log.debug("message: {}", a + b); // bad
    }
    void good(String a, String b) {
        log.debug("message: {}-{}", a, b); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Operation is executed regardless of log level and can be expensive"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.getXXX(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
(: log levels often not enabled in prod :)
  [@MethodName=('trace','debug','info')]
  [
    (: supported logger libs :)
    (VariableAccess[
        pmd-java:typeIs('org.slf4j.Logger')
        or pmd-java:typeIs('java.util.logging.Logger')
        or pmd-java:typeIs('org.apache.commons.logging.Log')
     ])
   or
     (: Slfj4 annotation makes the log variable AmbiguousName as there is no explicit log field :)
     (AmbiguousName[ancestor::ClassDeclaration[pmd-java:hasAnnotation('lombok.extern.slf4j.Slf4j')]])
  ]
(: only if unconditional :)
  [not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
(: and not returned conditionally before :)
  [not(ancestor::ExpressionStatement/preceding-sibling::IfStatement[.//ReturnStatement and .//MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')]])]
(: for operations in log with >0 arguments or toString(); except getters which are assumed as fast :)
  /ArgumentList//MethodCall[
    (ArgumentList[@Size>0] or @MethodName='toString') and not(starts-with(@MethodName, 'get'))
    (: if methods are chained, only report 1 in the chain :)
    and not(ancestor::MethodCall[ArgumentList[@Size>0]]/MethodCall)
  ]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    LOG.debug("customer = {}", customer.toString()); // bad
    LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

    LOG.debug("customer = {}", customer); // good
    if (LOG.isDebugEnabled()) { // good
        LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
    }
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Using SuppressWarnings for a rule that is meant to prevent high risk problems."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - are you sure?) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tags" value="data-mix-up,jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="ruleIdMatches" type="String" value="AvoidUserDataInSharedObjects|AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation[@SimpleName=("SuppressWarnings","SuppressFBWarnings")]//StringLiteral[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@SuppressWarnings({"pmd:AvoidUnguardedMutableFieldsInSharedObjects", "PMD.AvoidUserDataInSharedObjects"}) // suspicious, bad to suppress
@Component @Data
class VMRData {
    private List<OrderDetails> orderList; // a bad idea to have in a singleton, should be solved instead of suppressed
    //..
}
             ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarnings"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Using SuppressWarnings."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - be aware) Problem: This rule detects problems, suppressing them without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation[@SimpleName=("SuppressWarnings","SuppressFBWarnings")]//StringLiteral[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>
    <rule name="UnconditionalCreatedLogArguments"
          language="java"
          message="Avoid unconditional creation of a log argument, it may not be needed."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il06">
        <description>Problem: Creation of a log argument with a toString or other operation(s) may be expensive, while depending on the log level, the result may not be used.&#13;
            Solution: Create the log argument conditionally on the log level, within an if statement. For just 'obj.toString()', just pass 'obj' to the log method and leave it to SLF4J to call toString() only if needed.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
  (: log levels typically/often not enabled :)
  [@MethodName=('trace','debug','info')]
  [
    (: supported logger libs :)
    (VariableAccess[
        pmd-java:typeIs('org.slf4j.Logger')
        or pmd-java:typeIs('java.util.logging.Logger')
        or pmd-java:typeIs('org.apache.commons.logging.Log')
     ])
   or
     (: Slfj4 annotation makes the log variable AmbiguousName as there is no explicit log field :)
     (AmbiguousName[ancestor::ClassDeclaration[pmd-java:hasAnnotation('lombok.extern.slf4j.Slf4j')]])
  ]
  (: no violation if conditionally: only executed if level enabled is okay :)
  [not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
  (: no violation if return conditionally before :)
  [not(ancestor::ExpressionStatement/preceding-sibling::IfStatement[.//ReturnStatement and .//MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')]])]
  (: equals a declared var, with initializer not like obj.get[Xxx], we assume a simple getter is quick; except when in a loop :)
  /ArgumentList//VariableAccess
     [@Name = ancestor::MethodDeclaration//VariableDeclarator[not(MethodCall[starts-with(@MethodName, 'get')] and not(ancestor::WhileStatement or ancestor::ForStatement or ancestor::DoStatement))]/VariableId/@Name]
     (: and it is not used in a return :)
     [not (@Name = ancestor::MethodDeclaration//VariableAccess[not(ancestor::MethodCall[@MethodName=('trace','debug','info')])]/@Name)]
     (: method name starts with log, we assume it is called conditionally :)
     [not(ancestor::MethodDeclaration[starts-with(@Name, 'log')]
 )]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    void bad(Object obj) {
      String logObj = obj.toString();
      log.debug("object to String: {}", logObj); //bad
    }

    void good(Object obj) {
      log.debug("object to String: {}", obj); //good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidTimeUnitConfusion"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="confusing,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//(VariableDeclarator[../PrimitiveType]|FormalParameter[PrimitiveType])/VariableId[
ends-with(lower-case(@Name), 'timetolive')
or ends-with(lower-case(@Name), 'time_to_live')
or ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout')
or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration')
or ends-with(lower-case(@Name), 'durationout')
or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')
or ends-with(lower-case(@Name), 'timestamp')]
,
(: @Value :)
//Annotation[@SimpleName='Value' and .//MemberValuePair[@Image='value']/StringLiteral[
ends-with(lower-case(@Image), 'timetolive')
or ends-with(lower-case(@Image), 'time_to_live}"')
or ends-with(lower-case(@Image), 'time}"')
or ends-with(lower-case(@Image), 'timeout}"')
or ends-with(lower-case(@Image), 'time_out}"')
or ends-with(lower-case(@Image), 'duration}"')
or ends-with(lower-case(@Image), 'durationout}"')
or ends-with(lower-case(@Image), 'duration_out}"')
or ends-with(lower-case(@Image), 'ttl}"')
or ends-with(lower-case(@Image), 'timestamp}"')]]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. Or use Lombok @EqualsAndHashCode, @Value or @Data. Also holds for inner classes.
            If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... , @Entity, Throwable and Executor objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,unpredictable" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:- top level class - not annotated that would make it a non-value object -:)
//ClassDeclaration
[not(pmd-java:hasAnnotation('lombok.Data') or pmd-java:hasAnnotation('lombok.Value')or pmd-java:hasAnnotation('lombok.EqualsAndHashCode')
    or pmd-java:hasAnnotation('javax.ejb.Singleton') or pmd-java:hasAnnotation('jakarta.ejb.Singleton')
    or pmd-java:hasAnnotation('org.springframework.stereotype.Component') or pmd-java:hasAnnotation('org.springframework.stereotype.Controller')
    or pmd-java:hasAnnotation('org.springframework.stereotype.Service') or pmd-java:hasAnnotation('org.springframework.stereotype.Repository')
    or pmd-java:hasAnnotation('org.springframework.context.annotation.Configuration')
    or pmd-java:hasAnnotation('org.springframework.web.bind.annotation.RestController') or pmd-java:hasAnnotation('org.springframework.web.bind.annotation.ControllerAdvice')
    or pmd-java:hasAnnotation('org.springframework.ws.server.endpoint.annotation.Endpoint')
    or pmd-java:hasAnnotation('javax.persistence.Entity') or pmd-java:hasAnnotation('jakarta.persistence.Entity')
    or pmd-java:hasAnnotation('javax.persistence.Embeddable') or pmd-java:hasAnnotation('jakarta.persistence.Embeddable')
    or pmd-java:hasAnnotation('javax.persistence.MappedSuperclass') or pmd-java:hasAnnotation('jakarta.persistence.MappedSuperclass')
    (: JAXB annotations: @XmlType, @XmlRootElement, @XmlAccessorType, @XmlAccessorOrder :)
    or ModifierList/Annotation[starts-with(@SimpleName, 'Xml')]
)]
[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassBody[FieldDeclaration[@Static=false() and (not (pmd-java:hasAnnotation('javax.xml.bind.annotation.XmlElement')))
    and
    (: a getter with result type of a field :)
    (ancestor::ClassBody[1]/MethodDeclaration
       [(@Visibility='public' or ../../@Nested=true()) and @Static=false() and (starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2)]
       [ClassType/@SimpleName=ancestor::ClassBody[1]/FieldDeclaration[@Static=false()]/ClassType/@SimpleName]
    )
    (: and class has no equals nor hashCode method :)
    and (not (ancestor::ClassBody[1]/MethodDeclaration[(@Visibility='public' or ../../@Nested=true()) and @Static=false() and (@Name='equals' and .//FormalParameters[@Size=1]) or (@Name='hashCode' and .//FormalParameters[@Size=0])]))
    (: and class has a toString and #fields <= 1+#getters :)
    and ((ancestor::ClassBody[1]//MethodDeclaration[(@Visibility='public' or ../../@Nested=true()) and @Static=false() and @Name='toString']
            and count(ancestor::ClassBody[1]/FieldDeclaration[@Static=false()]) <=
                (1 + count(ancestor::ClassBody[1]/MethodDeclaration[(@Visibility='public' or ../../@Nested=true()) and @Static=false() and (starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2)]))
            or ancestor::ClassDeclaration[1][ends-with(upper-case(@SimpleName), 'DTO')])
        (: or #fields == #getters :)
        or count(ancestor::ClassBody[1]/FieldDeclaration[@Static=false()]) = count(ancestor::ClassBody[1]/MethodDeclaration[(@Visibility='public' or ../../@Nested=true()) and @Static=false() and (starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2)])
        )
] (:-up to class -:)
]/..
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Getters { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
}
class Good {
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good good = (Good) o;
        return Objects.equals(someState1, good.someState1) && Objects.equals(someState2, good.someState2);
    }

    @Override
    public int hashCode() {
        return Objects.hash(someState1, someState2);
    }
}

            ]]>
        </example>
    </rule>

    <rule name="EqualsOperationInconsistentWithHashCode"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Equals uses a conversion inconsistent with hashCode."
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode and use identical conversions like toUpperCase() in both when needed. Don't use equalsIgnoreCase. (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: the number of toLowerCase on a field used in equals should not be larger than that of hashCode :)
//FieldDeclaration//VariableId[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and (FormalParameters/@Size = 1)]/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toLowerCase()')]//VariableAccess/@Name) >
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and (FormalParameters/@Size = 0)]/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toLowerCase()')]//VariableAccess/@Name)
]
(: go to violating toLowerCase in equals :)
/ancestor::ClassBody[1]//MethodDeclaration[@Name='equals']/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toLowerCase()')]
,
(: the number of toUpperCase on a field used in equals should not be larger than that of hashCode :)
//FieldDeclaration//VariableId[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and (FormalParameters/@Size = 1)]/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toUpperCase()')]//VariableAccess/@Name) >
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and (FormalParameters/@Size = 0)]/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toUpperCase()')]//VariableAccess/@Name)
]
(: go to violating toUpperCase in equals :)
/ancestor::ClassBody[1]//MethodDeclaration[@Name='equals']/Block//MethodCall[pmd-java:matchesSig('java.lang.String#toUpperCase()')]
,
(: equalsIgnoreCase on field, in equals, not allowed :)
//MethodDeclaration[@Name='equals' and (FormalParameters/@Size = 1)]/Block//MethodCall[pmd-java:matchesSig('java.lang.String#equalsIgnoreCase(java.lang.String)')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        if (field1 != null ? !field1.equals(that.field1) : that.field1 != null) return false;
        return field2 != null ? field2.equalsIgnoreCase(that.field2) : that.field2 == null; // ignore case, bad
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad2 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad2 that = (Bad2) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase()); // bad
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad3 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad3 that = (Bad3) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase());
    }
    public int hashCode() {
        return Objects.hash(field1.toLowerCase(), field2.toLowerCase());
    }
}

class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good that = (Good) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2.toUpperCase(), that.field2.toUpperCase()); // ignore case same way
    }
    public int hashCode() {
        return Objects.hash(field1, field2.toUpperCase()); // ignore case same way
    }
}
            ]]>
        </example>
    </rule>

    <rule name="FieldOfHashCodeMissingInEquals"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Equals does not use all fields used by hashCode."
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and FormalParameters/@Size = 1]/Block//(FieldAccess|VariableAccess)/@Name) <
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and FormalParameters/@Size = 0]/Block//(FieldAccess|VariableAccess)/@Name)
]/VariableId
|
//FieldDeclaration/VariableDeclarator[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and FormalParameters/@Size = 1]/Block//MethodCall[@MethodName='toLowerCase']/(FieldAccess|VariableAccess)/@Name) >
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and FormalParameters/@Size = 0]/Block//MethodCall[@MethodName='toLowerCase']/(FieldAccess|VariableAccess)/@Name)
]/VariableId
|
//FieldDeclaration/VariableDeclarator[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and FormalParameters/@Size = 1]/Block//MethodCall[@MethodName='toUpperCase']/(FieldAccess|VariableAccess)/@Name) >
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and FormalParameters/@Size = 0]/Block//MethodCall[@MethodName='toUpperCase']/(FieldAccess|VariableAccess)/@Name)
]/VariableId
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good1 {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good1 that = (Good1) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1); // field2 missing
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInEquals"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Field simply assigned to is missing in equals method."
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah04">
        <description>Problem: If a field which can be assigned separately (independent of other fields) is missing in the equals method, then changing the field in one object has no effect on the equality with another object.
            However, if a field of one of two equal objects is changed, the expectation is that they are no longer equal.&#13;
            Solution: include the missing field in the equals and hashCode method. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
 //FieldDeclaration[@Static=false()]//VariableId[
    (: names used as left hand side in simple assignments in methods or constructor matching fields :)
    (@Name = ancestor::ClassBody[1]/(MethodDeclaration|ConstructorDeclaration)/Block//AssignmentExpression[not(InfixExpression or ConstructorCall or MethodCall or FieldAccess/TypeExpression)]
        /(VariableAccess|FieldAccess)[1]/@Name)
     and
    (: with an equals method defined at that level with 1 argument and not having a throw statement :)
     ancestor::ClassBody[1]/MethodDeclaration[@Name='equals' and FormalParameters/@Size=1 and not (Block/ThrowStatement)]
    (: where names used in equals method matching fields are non-equal to :)
    and not(@Name = ancestor::ClassBody[1]/MethodDeclaration
    [@Name='equals' and FormalParameters/@Size=1]/Block//(VariableAccess|FieldAccess)/@Name)
]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; // bad, missing in equals

    public Bad1(String arg2) {
        field2 = arg2;
    }
    public void setField1(String arg1) {
        field1 = arg1;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInHashCode"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Equals uses a field which is missing in hashCode."
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Two unequal objects can have the same hashCode and end up in the same bucket of a Map. This may result in bad performance, O(n) lookup instead of O(1).&#13;
            Solution: Use the same fields in hashCode as are used in equals. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator[
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='equals' and FormalParameters/@Size = 1]/Block//(FieldAccess|VariableAccess)/@Name) >
(@Name = ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and FormalParameters/@Size = 0]/Block//(FieldAccess|VariableAccess)/@Name)
]/VariableId
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad - missing in hashCode

   public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableLists"
          language="java"
          message="List is not modified after object construction, make it immutable or unmodifiable"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml01">
        <description>Problem: A list which is unnecessarily mutable may accidentally be added to and cause a memory leak. &#13;
            Solution: Make it impossible to modify the list after object construction/initialization: use Java 9 List.of, Java 11 List.copyOf, Collections.unmodifiableList or Guava ImmutableList.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,pitfall" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: a field of type List :)
//FieldDeclaration[//VariableId[pmd-java:typeIs('java.util.List')]]
(: exclude ConfigurationProperties classes :)
[count(ancestor::ClassDeclaration/ModifierList/Annotation[@SimpleName='ConfigurationProperties']) = 0]
(: exclude when JPA annotated :)
[count(ModifierList/Annotation[@SimpleName=('OneToMany', 'ManyToMany')]) = 0]
//VariableId[
    (: with a method defined at that level that does not use the field with a modify operation (case field.modOp) :)
    not(@Name = ancestor::ClassBody/MethodDeclaration/Block//MethodCall[
        starts-with(@MethodName, 'add') or starts-with(@MethodName, 'remove') or
        @MethodName = ('set', 'clear', 'replaceAll', 'retainAll')
    ]/(VariableAccess|FieldAccess)/@Name)
]
[   (: field is initialized with List constructor :)
    ../ConstructorCall[pmd-java:typeIs('java.util.List')]
    or
    (: or static block / constructor has field initialized with List allocation :)
    ancestor::ClassBody/(Initializer|ConstructorDeclaration)//AssignmentExpression[ConstructorCall[pmd-java:typeIs('java.util.List')]]/(VariableAccess|FieldAccess)[1]/@Name = @Name
    or
    (: or constructor has a simple assignment to the field, param or literal: no arguments :)
    ancestor::ClassBody/ConstructorDeclaration/Block//AssignmentExpression[VariableAccess[2][pmd-java:typeIs('java.util.List')]]/VariableAccess[1]/@Name = @Name
]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Bad {
    List unmutated = new ArrayList(Arrays.asList("one", "two")); // bad
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
public class Good {
    List unmutated1 = Collections.unmodifiableList(Arrays.asList("one", "two")); // Java 8
    List unmutated2 = List.of("one", "two"); // Java 9+
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnnecessaryStringBuilderCreation"
          language="java"
          message="Use concatenation (+) instead of new StringBuilder if only one statement."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu05">
        <description>Problem: Creating a StringBuilder and using append is more verbose, less readable and less maintainable than simply using String concatenation (+).
            For one statement resulting in a String, creating a StringBuilder and using append is not faster than simply using concatenation.&#13;
            Solution: Simply concatenate Strings in one statement, it is more concise, better readable and more maintainable.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="bad-practice,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: append used in one chained statement on constructor of StringBuilder and with chained toString :)
//MethodDeclaration//Block//MethodCall[@MethodName = "toString"]/MethodCall[@MethodName='append']
[.//ConstructorCall[pmd-java:typeIs('java.lang.AbstractStringBuilder')]]
|
(: or local declared builder var with an append :)
//MethodDeclaration//Block/LocalVariableDeclaration[
    VariableDeclarator[
        VariableId/@Name=ancestor::Block[1]//MethodCall[@MethodName='append']/VariableAccess/@Name
    ]
    /ConstructorCall/ClassType[pmd-java:typeIs('java.lang.AbstractStringBuilder')]
]
[
    (: and toString is called (possibly chained) on the var in same block, with no other operations than append :)
    ..//MethodCall[@MethodName='append']/VariableAccess/@Name=..//(ReturnStatement|ExpressionStatement|LocalVariableDeclaration)//MethodCall[@MethodName='toString']
        [not(..//MethodCall[@MethodName!=('append') and @MethodName!=('toString')])]//VariableAccess/@Name
]
[
    not(
        ..//MethodCall[@MethodName='append']/VariableAccess[
            (: and not append on var used in inner block like a ForStatement or IfStatement :)
            @Name = ancestor::Block//Block//MethodCall[@MethodName='append']/VariableAccess/@Name
            (: and not append in lambda expression, issue 195 :)
            or ancestor::LambdaExpression
            (: and var not passed as argument to method :)
            or (@Name = ancestor::MethodDeclaration//MethodCall/ArgumentList/VariableAccess/@Name)
        ]
    )
]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    String name;
    String value;

    public String bad() {
        return new StringBuilder()
           .append(name) // bad
           .append(" = ")// bad
           .append(value)// bad
           .toString();
    }

    public String good() {
        return name + " = " + value;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="OptimizeMapOrSetForEnum"
          language="java"
          message="Map has enum keys or Set has enum elements, use EnumMap or EnumSet for more efficiency."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc03">
        <description>Problem: A HashMap and HashSet are rather greedy in memory usage.&#13;
            Solution: Use an EnumMap or EnumSet. It is represented internally with arrays which is extremely compact and efficient.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//(FieldDeclaration|LocalVariableDeclaration)[
    ClassType[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
        /TypeArguments/ClassType[1][pmd-java:typeIs('java.lang.Enum') or @SimpleName = //EnumDeclaration/@SimpleName]
    and
    VariableDeclarator/(MethodCall|ConstructorCall)
        [not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')) or
        (: Set.of() with 1 or 2 elems and Map.of() with 1 key+value don't have the HashSet/Map overhead :)
        (@MethodName='of' and ((pmd-java:typeIsExactly('java.util.Set') and ArgumentList/@Size <= 2) or (pmd-java:typeIsExactly('java.util.Map') and ArgumentList/@Size <= 2))) or
        (: it is exactly a Map or Set, cannot determine implementation #194 :)
        ((@MethodName!='of' and (pmd-java:typeIsExactly('java.util.Set') or pmd-java:typeIsExactly('java.util.Map'))))
        (: cannot determine type, indirect #194 :)
        or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
     )]
]
|
//Initializer//AssignmentExpression[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/(MethodCall|ConstructorCall)
        [not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')) or
        (: Set.of() with 1 or 2 elems and Map.of() with 1 key+value don't have the HashSet/Map overhead :)
        (@MethodName='of' and ((pmd-java:typeIsExactly('java.util.Set') and ArgumentList/@Size <= 2) or (pmd-java:typeIsExactly('java.util.Map') and ArgumentList/@Size <= 2))) or
        (: it is exactly a Map or Set, cannot determine implementation #194 :)
        ((@MethodName!='of' and (pmd-java:typeIsExactly('java.util.Set') or pmd-java:typeIsExactly('java.util.Map'))))
        (: cannot determine type, indirect #194 :)
        or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
     )
]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
Map<YourEnumType, String> map = new EnumMap<>(YourEnumType.class);
Set<YourEnumType> set = EnumSet.allOf(YourEnumType.class);
            ]]>
        </example>
    </rule>

    <rule name="AvoidLombokAnnotationForNonExistentFields"
          language="java"
          message="Avoid Lombok annotations for fields of a class while the class has no fields."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="">
        <description>Problem: Lombok annotations for fields [@Getter, @Setter, @EqualsAndHashCode, @Value, @Data] are of no use and confusing in case the class has no fields.&#13;
            Solution: Remove the Lombok annotation.
        </description>
        <priority>4</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,unused,confusing" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration/ModifierList/Annotation
    [pmd-java:typeIs('lombok.Getter') or pmd-java:typeIs('lombok.Setter') or pmd-java:typeIs('lombok.Value') or
     pmd-java:typeIs('lombok.Data') or pmd-java:typeIs('lombok.EqualsAndHashCode')]
    [ancestor::ClassDeclaration/ClassBody[count(FieldDeclaration) = 0]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
        @Data // bad
        public class BusinessException extends RuntimeException {
            // no fields, no methods
        }
            ]]>
        </example>
    </rule>

    <rule name="AvoidExposingMutableRecordState"
          language="java"
          message="Avoid exposing mutable state of the record. Use copyOf in the compact constructor."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos06">
        <description>Problem: Internal state can be modified from outside of the record, through the implicit accessor method or by the caller of the constructor. Risk of thread-unsafety.
            Solution: Use the record compact constructor to defensively copy the (possibly) mutable object such as a List, Set or Map, e.g. with List.copyOf().
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//RecordDeclaration//RecordComponent/ClassType[(pmd-java:typeIs('java.util.Collection') or pmd-java:typeIs('java.util.Map'))
    and not(../VariableId/@Name = ancestor::RecordDeclaration/RecordBody/CompactConstructorDeclaration
        //AssignmentExpression[VariableAccess/@Name = .//MethodCall[@MethodName='copyOf']
            /ArgumentList/VariableAccess/@Name]/VariableAccess/@Name)
]/..
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
record BadRecord(String name, List<String> list) {
}

record GoodRecord(String name, List<String> list) {
    public GoodRecord {
        list = List.copyOf(list);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="ImproperVariableName"
          language="java"
          message="Give variables and fields a meaningful name."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodeQuality.md#m01">
        <description>Problem: Variables like 'var3' and fields like 'FOUR = 4', do not express what they are used for. This is bad for maintainability.&#13;
            Solution: Let variable names express what they are used for, like 'key' and 'MAX_KEYS = 4'
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="bad-practice,confusing,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//VariableId[matches(@Name, 'VALUE|VAL|INTEGER|INT|LONG|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY', 'i')
(: not allowed only as uppercase :)
and (replace(@Name, 'VALUE|VAL|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '') = ''
   (: not allowed as lower and uppercase :)
   or replace(@Name, 'INTEGER|INT|LONG|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '', 'i') = '')
or starts-with(@Name, 'var') and number(substring-after(@Name, 'var'))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private static final int FOUR_ZERO_NINE_SIX = 4096; // bad
    private static final int VALUE_42 = 42; // bad
    private static int six = 6; // bad
    private int five = 7; // what? bad
    private static final int SIXTIES_START = 1960; // good

    void bar() {
        String var1 = "baz"; // bad
    }
}
            ]]>
        </example>
    </rule>
    <rule name="AvoidReStreamingEnumValues"
          language="java"
          message="Avoid re-streaming enum values to find a value by a field."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc07">
        <description>Problem: the time to find element is O(n); n = the number of enum values. This identical processing is executed for every call. Considered problematic when n > 3.
            Solution: use a static field-to-enum-value Map. Access time is O(1), provided the hashCode is well-defined.
            For one String field, usually toString returns that field. Implement a fromString method to provide the reverse conversion by using the map.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//EnumDeclaration/EnumBody[count(EnumConstant) > 3]//MethodDeclaration/Block
    //MethodCall[pmd-java:matchesSig('java.util.stream.Stream#findFirst()') or pmd-java:matchesSig('java.util.stream.Stream#findAny()')]
    [//MethodCall[pmd-java:matchesSig('java.util.stream.Stream#of(_)') or pmd-java:matchesSig('java.util.Arrays#stream(_)')]
    [ArgumentList/MethodCall[pmd-java:matchesSig('_#values()')]]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
// BAD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Stream.of(values()).filter(v -> v.toString().equals(name)).findAny(); // bad: iterates for every call, O(n) access time
    }
}

Usage: `Fruit f = Fruit.fromString("banana");`

// GOOD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private static final Map<String, Fruit> nameToValue =
            Stream.of(values()).collect(toMap(Object::toString, v -> v));
    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Optional.ofNullable(nameToValue.get(name)); // good, get from Map, O(1) access time
    }
}            ]]>
        </example>
    </rule>

    <rule name="NonComparableMapKeys"
          language="java"
          message="Map keys should implement Comparable in order to make access fast."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc08">
        <description>Problem: If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access will be slow.
            Solution: Implement Comparable for your Map keys. Do not use classes for the keys which don't implement Comparable, like Thread, Class and Object. At least not for Maps which can grow large.
            Note that equals and hashCode must be implemented properly for the keys, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: check key type in declaration :)
//VariableDeclarator/../ClassType[pmd-java:typeIs('java.util.Map')]
(: first type argument does not implement Comparable :)
/TypeArguments/ClassType[1][not(pmd-java:typeIs('java.lang.Comparable'))]
,
(: for when key type is missing in declaration (old style), check Map.put :)
//MethodCall[pmd-java:matchesSig('java.util.Map#put(_,_)')]
(: first arg does not implement Comparable :)
/ArgumentList/*[1][not(pmd-java:typeIs('java.lang.Comparable'))]
[not(pmd-java:typeIs('byte'))][not(pmd-java:typeIs('short'))]
[not(pmd-java:typeIs('int'))][not(pmd-java:typeIs('long'))]
[not(pmd-java:typeIs('float'))][not(pmd-java:typeIs('double'))]
[not(pmd-java:typeIs('boolean'))][not(pmd-java:typeIs('char'))]
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
 class Foo {
    Map<Object, String> oMap; // bad, Object does not implement Comparable
    Map<Thread, String> tMap; // bad, Thread does not implement Comparable

    Map oldStyleMap = new HashMap(); // cannot check here

    void putInOldStyleBad() {
        oldStyleMap.put(new Thread(), "value"); // bad
    }

    Map<Comparable, String> cMap; // good

    void putInOldStyleGood() {
        oldStyleMap.put("key", "value");
    }
}

            ]]>
        </example>
    </rule>

    <rule name="NonComparableSetElements"
          language="java"
          message="Set elements should implement Comparable in order to make access by element fast."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc09">
        <description>Problem: A Set is implemented with a Map. If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red-black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access by element will be slow. Iterating through the elements does not suffer from this slow access because no lookup by key in the map is involved.
            Access methods by element which are affected: contains[All], retainAll, remove[All].
            Solution: Implement Comparable for your own Set elements. Avoid using large Sets with elements of types which don't implement Comparable, like Thread, Class and Object. At least when using access by element.
            Note that equals and hashCode must be implemented properly for the elements, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: declared variable used in Set by-element access :)
//VariableId[@Name = ancestor::ClassBody//MethodCall[@MethodName = ('contains','containsAll','remove','removeAll','retainAll')]/VariableAccess/@Name]
    (: for 3 ways defined as a Set :)
    [(ancestor::FieldDeclaration|ancestor::LocalVariableDeclaration|ancestor::FormalParameter)/ClassType[pmd-java:typeIs('java.util.Set')]
    (: element type does not implement Comparable :)
    /TypeArguments/ClassType[not(pmd-java:typeIs('java.lang.Comparable'))]]/../..
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import org.apache.hc.client5.http.HttpRoute; // does implement equals/hashCode yet *not* compareTo

class Foo {
  Set<String> strSet = new HashSet<>();
  List<String> strList = new ArrayList<>();
  Set<HttpRoute> fieldRouteSet = new HashSet<>(); // bad
  List<HttpRoute> routeList = new ArrayList<>();

  void byElemBad(Set<HttpRoute> paramRouteSet) { // bad
    paramRouteSet.retainAll(routeList);

    fieldRouteSet.contains(t);

    Set<HttpRoute> localRouteSet = new HashSet<>(); // bad
    localRouteSet.removeAll(routeList);
  }

  void otherCasesGood(Set<HttpRoute> paramRouteSet) {
    strSet.contains("bla");
    strSet.retainAll(strList);
    strSet.remove("other");
    paramRouteSet.iterator().next();
  }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFileStreaming"
          language="java"
          message="FileInputStream and FileOutputStream are not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio05">
        <description>Problem: With FileInputStream and FileOutputStream, file access is not buffered.
            The stream is read-from/written-to file byte by byte, where each operating system call has its overhead, which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use BufferedOutput/InputStream which has a buffer size of 8 kB by default to write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//Resource//ConstructorCall[pmd-java:typeIs('java.io.FileInputStream') or pmd-java:typeIs('java.io.FileOutputStream')]
[not (ancestor::TryStatement//ConstructorCall[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('java.io.BufferedOutputStream')])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.io.*;

class BufferFileStreaming {
    void bad(String inputFilename, String outputFilename) {
        try (FileInputStream fis = new FileInputStream(inputFilename)) { // bad
            //use fis
        }
    }
    void good(String inputFilename, String outputFilename) {
        try (InputStream bfis = new BufferedInputStream(new FileInputStream(inputFilename))) { // good
            //use bfis
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFilesNewStream"
          language="java"
          message="Files.newInputStream or Files.newOutputStream is not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio06">
        <description>Problem: Files.newInputStream or Files.newOutputStream is not buffered.
            The stream is read from/written to file byte by byte, where each operating system call has its overhead which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use e.g. BufferedInputStream or BufferedOutputStream which has a buffer size of 8 kB to read/write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[TypeExpression[pmd-java:typeIs('java.nio.file.Files')]
   and (@MethodName='newInputStream' and (not(ancestor::MethodDeclaration//ConstructorCall[pmd-java:typeIs('java.io.BufferedInputStream')]))
      and not(ancestor::MethodDeclaration//MethodCall[starts-with(@MethodName, 'read') and TypeExpression[pmd-java:typeIs('org.apache.commons.io.IOUtils')]])
   or (@MethodName='newOutputStream' and not(ancestor::MethodDeclaration//ConstructorCall[pmd-java:typeIs('java.io.BufferedOutputStream')])))
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    OutputStream badO(String path) throws IOException {
        return java.nio.file.Files.newOutputStream(Paths.get(path)); // bad
    }
    OutputStream goodO(String path) throws IOException {
        return new BufferedOutputStream(java.nio.file.Files.newOutputStream(Paths.get(path)));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLoadingAllFromFile"
          language="java"
          message="Files.readAll methods load all bytes from a file into memory: a risk of memory problems."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: Files.readAllBytes and Files.readAllLines load all bytes from a file into the heap memory.
            This may result in an OutOfMemoryError crash, or long gc pauses and slow responses.
            Solution: Stream-through: use streaming all the way, don't store the whole thing in memory, don't use byte arrays.
            Often, functionality can be achieved in a streaming way.
            Note: not a problem for small files.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.nio.file.Files#readAllBytes(java.nio.file.Path)')
    or pmd-java:matchesSig('java.nio.file.Files#readAllLines(java.nio.file.Path)')
    or pmd-java:matchesSig('java.nio.file.Files#readAllLines(java.nio.file.Path,_)')
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    void bad(Path path) {
        byte[] fileBytes = Files.readAllBytes(path); // bad
        List<String> fileLines = Files.readAllLines(path); // bad
        // process bytes / lines
    }
}

class Good {
    void good(Path in) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(in)) {
            String line = reader.readLine();
            // process line by line
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="HashCodeOnlyCallsSuper"
          language="java"
          message="hashCode only calls super."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: when equals is implemented, hashCode needs to be implemented, too; and if objects are equal, hashCode needs to be equal, too. If hashCode only calls super.hashCode, it is effectively not implemented.
            Strange things can happen, for instance, if super.hashCode calls Object.hashCode, it is unique for each object and when used in Set or as key in Map, equal objects can duplicate in Set, and keys not found in Map.
            Solution: implement hashCode properly, consistent with equals. Meet the equals and hashCode contracts. If objects are equal, hashCode needs to be equal, too. See Effective Java.
        </description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[@Name='equals' and FormalParameters/@Size=1 and @Static=false() and ModifierList/@ExplicitModifiers='public']
/ancestor::ClassBody[1]//MethodDeclaration[@Name='hashCode' and FormalParameters/@Size=0 and @Static=false() and ModifierList/@ExplicitModifiers='public']
/Block[count(descendant::MethodCall)=1][//MethodCall[pmd-java:matchesSig('java.lang.Object#hashCode()')]/SuperExpression]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return super.hashCode(); // bad
    }
}

class Good {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingSecurityProviders"
          language="java"
          message="Avoid re-creating security providers, this is expensive."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"

          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuosf01">
        <description>Problem: Creating a security provider is expensive because of loading of algorithms and other classes. Additionally, it uses synchronized which leads to lock contention when used with multiple threads.
            Solution: This only needs to happen once in the JVM lifetime, because once loaded, the provider is typically available from the Security class. Create the security provider only once: only in case it is nog available from the Security class, yet.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration
   [not((@Name='main' and @Static=true())or ModifierList/Annotation/@SimpleName='PostConstruct'
      or .//IfStatement//InfixExpression
         [@Operator='=='][VariableAccess[pmd-java:typeIs('java.security.Provider')] and NullLiteral]
   )]
//ConstructorCall[pmd-java:typeIs('java.security.Provider') or pmd-java:typeIs('org.bouncycastle.jce.provider.BouncyCastleProvider')]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.security.*;
import javax.crypto.*;
import org.bouncycastle.jce.provider.*;

class Foo {
    public Cipher initBlowfishBad() throws GeneralSecurityException {
        Security.addProvider(new BouncyCastleProvider()); // bad
        // build a Cipher
    }

    public Cipher initBlowfishGood() throws GeneralSecurityException {
        Provider bouncyCastleProvider = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);
        if (bouncyCastleProvider == null) {
            bouncyCastleProvider = new BouncyCastleProvider();
            Security.addProvider(bouncyCastleProvider);
        }
        // build a Cipher
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingEqualsAndHashCodeWithGetterSetter"
          language="java"
          message="Equals and/or hashCode is missing in a class with lombok @Getter or @Setter."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah01">
        <description>Problem: If only the @Setter and/or @Getter annotation is used, and equals and hashcode are not defined, this is probably a mistake. The object has fields and if used in a collection or with equality, it will not behave as expected.
            Solution: include equals and hashCode e.g. by @EqualsAndHashCode or usually better @Data instead of @Setter/@Getter, however, are setters really needed? Prefer immutability, so @Value, combined with @Builder, with @Singular for collection fields.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[
    (pmd-java:hasAnnotation('lombok.Getter') or pmd-java:hasAnnotation('lombok.Setter'))
    and not(
        pmd-java:hasAnnotation('lombok.EqualsAndHashCode')
        or pmd-java:hasAnnotation('org.springframework.context.annotation.Configuration')
        or pmd-java:hasAnnotation('org.springframework.boot.context.properties.ConfigurationProperties')
        or pmd-java:hasAnnotation('jakarta.persistence.Entity')
        or pmd-java:hasAnnotation('javax.persistence.Entity')
        or (
            ./ClassBody/MethodDeclaration[@Name='equals' and @Arity=1 and ./PrimitiveType[@Kind='boolean']]
            and ./ClassBody/MethodDeclaration[@Name='hashCode' and @Arity=0 and ./PrimitiveType[@Kind='int']]
        )
    )
]/ModifierList/Annotation[1]
                ]]></value>
            </property>
            <property name="tags" value="jpinpoint-rule,correctness" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import lombok.*;

@Getter @Setter
// no equals/hashcode annotation
class MissingEqualsHashCodeWithGetterSetterBad { // bad
    String field1;
    String field2;
    // no equals, no hashCode
}

@Getter @Setter @EqualsAndHashCode
class EqualsHashCodeWithGetterSetterOkay {
    String field1;
    String field2;
}

@Builder @Value
class ValueGood {
    String field1;
    String field2;
}
            ]]>
        </example>
    </rule>

</ruleset>
