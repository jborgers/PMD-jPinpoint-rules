<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by Contexts and Dependency Injection (CDI) for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        </description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="memory" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
])
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::VariableDeclarator/VariableDeclaratorId/@Name
])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="bad-practice" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
 //ClassOrInterfaceDeclaration[@Interface=true()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface Foo {
    static final Object CONST = new Object(); //bad
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe.&#13;
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="multi-threading" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator/VariableInitializer/Expression[pmd-java:typeIs('java.text.DecimalFormat') or pmd-java:typeIs('java.text.ChoiceFormat')]
        ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected are different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="suspicious" type="String" description="for-sonar"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement/BlockStatement[
(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
or
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image)
and
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
not(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimarySuffix/Arguments/@Size > 0
or preceding-sibling::SwitchLabel[@Default=true()])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(//MethodDeclaration//(PrimaryPrefix/Name[ends-with(@Image, '.replaceAll') or ends-with(@Image, '.replaceFirst') or @Image='Pattern.matches']
|PrimarySuffix[@Image = 'replaceAll' or ends-with(@Image, '.replaceFirst')])
/following::PrimarySuffix[1]/Arguments[ArgumentList/@Size=2]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.split') or ends-with(@Image, 'getPathMatcher')]/../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
(:--- not (if foreign field (with .), or field with short String or without regex char) ---:)
Name[contains(@Image, '.') or @Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimarySuffix[@Image='getPathMatcher']/../PrimarySuffix/Arguments[ArgumentList/@Size=1]/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]]/VariableDeclaratorId/@Name])
]
,
(: --- String.matches called on formalparams, locals and fields --- :)
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.matches')]
[
(exists(index-of((ancestor::MethodDeclaration//FormalParameter[pmd-java:typeIs('java.lang.String')]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[pmd-java:typeIs('java.lang.String')]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('java.lang.String')]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.'))))
and
(: for matches param is >5 literal or something named :)
../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
(: exclude method calls :)
and not(../PrimarySuffix)
(: exclude for param is method arg or local :)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
(: exclude for param is short fields :)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]
]/VariableDeclaratorId/@Name])
]])
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
//bad
String bad_replaceInnerLineBreakBySpace() {
    return text.replaceAll("([^\\.\\n])\\n", "$1 "); // bad
}

// good
private static final Pattern INNER_LINE_BREAK_PATTERN = Pattern.compile("([^\\.\\n])\\n");

String good_replaceInnerLineBreakBySpace() {
    return INNER_LINE_BREAK_PATTERN.matcher(text).replaceAll("$1 "); // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>Problem: The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.ByteArrayOutputStream') or pmd-java:typeIs('java.io.StringWriter')]
[not(../Arguments/ArgumentList)
or
(pmd-java:typeIs('java.io.ByteArrayOutputStream') and (../Arguments//Literal[number(@Image) <= 32] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Name) <= 32]/@Image]))
or
(pmd-java:typeIs('java.io.StringWriter') and (../Arguments//Literal[number(@Image) <= 16] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Image) <= 16]/@Name]))
]/..
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static void bad()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //bad
        StringWriter sw = new StringWriter(); //bad
        baos = new ByteArrayOutputStream(32); //bad - not larger than default
    }
}
class Good {
    public static void good()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); // 8 kiB
        StringWriter sw = new StringWriter(2048);
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidMultipleConcatStatements" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Multiple statements concatenate to the same String. Use StringBuilder append." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name
[@Image=./../../../../../../../../../../../..//VariableDeclaratorId/@Name
and
./../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]
]
/../../../AssignmentOperator[@Image='+=']/
../Expression//PrimaryExpression/PrimaryPrefix/Name) > 1]/BlockStatement[position()=last()]
|
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[
@Image = ../../../Expression/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
@Image = ./../../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/@Name
]
]) > 1 ]//BlockStatement[position()=last()]//StatementExpression/Expression/AdditiveExpression[@Operator = '+']
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecompilingPatterns" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.util.regex.Pattern') and ends-with(@Image, '.compile') and
count(../../PrimarySuffix[1]/Arguments/ArgumentList/Expression//PrimaryExpression) = 1
and not (
../../PrimarySuffix[1]/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration//ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/(PrimarySuffix|PrimaryPrefix/Name)[ends-with(@Image,'newXPath')]
/ancestor::MethodDeclaration
//PrimaryExpression/(PrimarySuffix|PrimaryPrefix/Name)[ends-with(@Image, 'compile')
or (pmd-java:typeIs('javax.xml.xpath.XPath') and ends-with(@Image, 'evaluate'))]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static NodeList bad1(Document doc) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
        return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
    }
    public static NodeList bad2(Document doc) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        String xPathQuery = "//book[author='Isaac Asimov']/title/text()";
        return (NodeList) xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET); // bad
    }
}

class Good {
    private static final ThreadLocal<XPathFactory> tlFac = ThreadLocal.withInitial(XPathFactory::newInstance);
    private static final ThreadLocal<XPathExpression> tlExpr;
    static {
        XPath xpath = tlFac.get().newXPath();
        try {
            XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()");
            tlExpr = ThreadLocal.withInitial(() -> expr); // good
        } catch (XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }
    public static NodeList good(Document doc) throws XPathExpressionException {
        return (NodeList) tlExpr.get().evaluate(doc, XPathConstants.NODESET); // good
    }
            ]]>
        </example>


    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: Java 8+ java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //FieldDeclaration[@Final=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //FieldDeclaration[@Final=true() and @Static=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')](: has assignment, otherwise check in constructor :)[ancestor::ClassOrInterfaceBodyDeclaration//VariableInitializer],
    //ConstructorDeclaration/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of constructor call :)[not(ancestor::BlockStatement//Expression/PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::ConstructorDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //MethodDeclaration/Block/BlockStatement//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormatter.ofPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'ISODateTimeFormat.')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'DateTimeFormat.fullDateTime')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatterBuilder')][ancestor::PrimaryExpression/PrimarySuffix[@Image="toFormatter"]]
                   ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Reflection is used in toString or hashCode, which is expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, like generation by IDE or Lombok.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-high" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/AllocationExpression/ClassOrInterfaceType
	[
		pmd-java:typeIs('org.apache.commons.lang.builder.EqualsBuilder')
		or pmd-java:typeIs('org.apache.commons.lang.builder.HashCodeBuilder')
	]
[../../../PrimarySuffix[1]
	[
		@Image='reflectionEquals'
		or @Image='reflectionHashCode'
	]
] |
//PrimaryPrefix/Name
	[
		@Image='EqualsBuilder.reflectionEquals'
		or @Image='HashCodeBuilder.reflectionHashCode'
	]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSimpleDateFormat" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."  typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[
    pmd-java:typeIs('java.text.SimpleDateFormat')
    and not (ancestor::ClassOrInterfaceBodyDeclaration//PrimaryPrefix/Name[
       ends-with(@Image, 'setDateFormat')
       and (   pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
            or pmd-java:typeIs('com.fasterxml.jackson.dataformat.xml.XmlMapper'))
    ])
]
                ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="StringBuffer is used. It introduces locking overhead, use StringBuilder." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
                    //VariableDeclarator[../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.StringBuffer')]]
                    ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Log String is built irrespective of log level." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') = 'append')
and count(ancestor::IfStatement) = 0
and
count(ancestor::MethodDeclaration/Block/BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList//PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') != 'append')]) = 0
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidWideScopeXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression targets a wide scope, this is potentially slow." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimarySuffix[
Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/
Literal[starts-with(@Image, '"//')]
and
../PrimaryPrefix/Name[ends-with(@Image, '.compile')]
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathAPIUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathAPI is used. XPathAPI implementation has bad performance." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'XPathAPI.')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPath is used. XPath implementation has bad performance." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/
ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[@Image='XPathFactory.newInstance']
[not (ancestor::FieldDeclaration//ClassOrInterfaceType/@Image = 'ThreadLocal')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. Or use Lombok @EqualsAndHashCode, @Value or @Data. Also holds for inner classes.
            If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... , @Entity, Throwable and Executor objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="unpredictable" type="String" description="for-sonar"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- top level class - not annotated that would make it a non-value object --:)
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(:-- a getter with result type of a field --:)
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)
(:-- and class has no equals or hashCode method --:)
and (not (ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='equals' or @Name='hashCode']))
(:-- and class has a toString and #fields <= 1+#getters --:)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@SimpleName, 'Dto')]
or
(:-- #fields == #getters --:)
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)]
]/.. (:--up to class --:)

(:-- inner classes --:)
,
//ClassOrInterfaceBodyDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[(
ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='equals'])
)
and
((ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[1][ends-with(@SimpleName, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
)]
or
ancestor::ClassOrInterfaceBodyDeclaration[1]/Annotation//Name[@Image='Getter']
]/.. (:--up to class --:)
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Getters { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
}

@Getter
class LombokGetterBad { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";
}

@Getter
@EqualsAndHashCode
class LombokGetterGood {
    private String someState1 = "some1";
    private String someState2 = "some2";
}
            ]]>
        </example>
    </rule>

    <rule name="MDCPutWithoutRemove" message="MDC put is used without finally remove." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="correctness" type="String" description="for-sonar"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)[not(@Image=
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']/Block)//Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)/@Image)
and not((ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']/Block)//Name[@Image='MDC.clear'])
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MinimizeAttributesInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Attribute is set in the session, yet not removed. This may bloat the session." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tmsu01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="memory" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/MethodDeclaration[../..//(VariableDeclaratorId |ReturnStatement/Expression)[pmd-java:typeIs('javax.portlet.PortletSession') or pmd-java:typeIs('javax.servlet.http.HttpSession')]]
/Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'removeAttribute')]
)]]
,
//ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    PortletSession session; // same for HttpSession
    public void setAttribute(String name, Object obj) {
	    session.setAttribute(name, obj);                 // bad
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
}

class Good {
    PortletSession session; // same for HttpSession
	public void setAttribute(String name, final Object obj) {
		session.setAttribute(name, obj);
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
	public void removeAttribute(String name) {
		session.removeAttribute(name);
	}
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalConcatInLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String concatenation (+) is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name[ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or
    ends-with(@Image,'.info')]/../../PrimarySuffix/Arguments/ArgumentList/Expression/AdditiveExpression[pmd-java:typeIs('java.lang.String')]
    [PrimaryExpression/PrimaryPrefix/Name]
    [not(ancestor::IfStatement/Expression/PrimaryExpression/PrimaryPrefix/Name[
        ends-with(@Image,'.isTraceEnabled')
        or ends-with(@Image,'.isDebugEnabled')
        or ends-with(@Image,'.isInfoEnabled')
        or ends-with(@Image,'.isLoggable')
    ])]
]]></value>
            </property>
        </properties>
        <example>
        <![CDATA[
@slf4j
class Foo {
    void bad(String a, String b) {
        log.debug("message: {}", a + b); // bad
    }
    void good(String a, String b) {
        log.debug("message: {}{}", a, b); // good
    }
}
            ]]>
    </example>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Operation is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.getXXX(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
          //PrimaryPrefix/Name
            (: log levels typically/often not enabled :)
            [
            	ends-with(@Image,'.trace')
            	or ends-with(@Image,'.debug')
            	or ends-with(@Image,'.info')
            ]
            (: no violation if conditionally: only executed if level enabled is okay :)
            [not(ancestor::IfStatement//Name
            	[
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
	        ]
            (: no violation if return conditionally before :)
            [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
                [
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
            ]
	        (: in the log method :)
            /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
            [
                (: toString on argument :)
                PrimaryPrefix/Name[ends-with(@Image,'.toString')]
                or
                (: a method call with an argument list :)
                (PrimarySuffix/Arguments/ArgumentList)
                (: exclude a simple getXXX(i), like list.get(0) or env.getProperty(key), assumed to be fast :)
                and not (PrimaryPrefix/Name[contains(@Image,'.get')])
            ]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            LOG.debug("customer = {}", customer.toString()); // bad
            LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

            LOG.debug("customer = {}", customer); // good
            if (LOG.isDebugEnabled()) { // good
                LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
            }
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings for a rule that is meant to prevent high risk problems." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - are you sure?) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="suspicious" type="String" description="for-sonar"/>
            <property name="tag" value="data-mix-up" type="String" description="for-sonar"/>
            <property name="ruleIdMatches" type="String" value="AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="UsingSuppressWarnings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - be aware) Problem: This rule detects problems, suppressing them without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="suspicious" type="String" description="for-sonar"/>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidTimeUnitConfusion" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="confusing" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//Type/PrimitiveType/../..//VariableDeclaratorId[ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl') or ends-with(lower-case(@Name), 'timestamp')]
,
(: @Value :)
//SingleMemberAnnotation/Name[@Image='Value']/..//Literal[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"') or ends-with(lower-case(@Image), 'timestamp}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidTimeUnitConfusionPMD7" since="7.0" class="net.sourceforge.pmd.lang.rule.XPathRule" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="confusing" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//VariableDeclaratorId[preceding-sibling::PrimitiveType|../../PrimitiveType][ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')]
,
(: @Value :)
//Annotation[@SimpleName='Value']//StringLiteral[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="FieldOfHashCodeMissingInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals does not use all fields used by hashCode." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="correctness" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) <
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good1 {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good1 that = (Good1) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1); // field2 missing
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

            ]]>
        </example>
    </rule>

    <rule name="EqualsOperationInconsistentWithHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals uses a conversion inconsistent with hashCode." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode and use identical conversions like toUpperCase() in both when needed. Don't use equalsIgnoreCase. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="correctness" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(concat(@Name, '.toLowerCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image ) >
(concat(@Name, '.toLowerCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image)
]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals']/Block//(Name|PrimarySuffix)[ends-with(@Image,'.toLowerCase')]
,
//FieldDeclaration//VariableDeclaratorId[
(concat(@Name, '.toUpperCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image ) >
(concat(@Name, '.toUpperCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode'and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image)
]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals']/Block//(Name|PrimarySuffix)[ends-with(@Image,'.toUpperCase')]
,
//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//Name[ends-with(@Image, 'equalsIgnoreCase')]

                ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        if (field1 != null ? !field1.equals(that.field1) : that.field1 != null) return false;
        return field2 != null ? field2.equalsIgnoreCase(that.field2) : that.field2 == null; // ignore case
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad2 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad2 that = (Bad2) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase()); // bad
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad3 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad3 that = (Bad3) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase());
    }
    public int hashCode() {
        return Objects.hash(field1.toLowerCase(), field2.toLowerCase());
    }
}

class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good that = (Good) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2.toUpperCase(), that.field2.toUpperCase()); // ignore case
    }
    public int hashCode() {
        return Objects.hash(field1, field2.toUpperCase()); // ignore case
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Field simply assigned to is missing in equals method." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah04">
        <description>Problem: If a field which can be assigned separately (independent of other fields) is missing in the equals method, then changing the field in one object has no effect on the equality with another object.
            However, if a field of one of two equal objects is changed, the expectation is that they are no longer equal.&#13;
            Solution: include the missing field in the equals and hashCode method. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="suspicious" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]//VariableDeclaratorId[
    (: names used as left hand side in simple assignments in methods or constructor matching fields:)
     (@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/(MethodDeclaration|ConstructorDeclaration)
    /..//BlockStatement//StatementExpression
    (: simple assignment :)
    [exists(AssignmentOperator) and not(exists(Expression/PrimaryExpression/PrimarySuffix))
    and exists(Expression/PrimaryExpression/PrimaryPrefix/Name) and not(contains(Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,".")) ]
    /PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)/@Image)
     and (
    (: with an equals method defined at that level with 1 argument and not having a throw statement :)
    ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and not (Block/BlockStatement/Statement/ThrowStatement)]
    (: where names used in equals method matching fields are non-equal to :)
    and not(@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
    [@Name='equals' and MethodDeclarator/FormalParameters/@Size=1]/Block//
    (: name or this.name and name before dot if present :)
    (Name|PrimarySuffix)/(substring-before(concat(@Image, '.'), '.'))) )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; // bad, missing in equals

    public Bad1(String arg2) {
        field2 = arg2;
    }
    public void setField1(String arg1) {
        field1 = arg1;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals uses a field which is missing in hashCode." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ieah03">
        <description>Problem: Two unequal objects can have the same hashCode and end up in the same bucket of a Map. This may result in bad performance, O(n) lookup instead of O(1).&#13;
            Solution: Use the same fields in hashCode as are used in equals. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) >
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad - missing in hashCode

   public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendar"
          language="java"
          message="A Calendar is inefficient in memory usage."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#imu01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use Date, Java 8+ java.time.[Local/Zoned]DateTime.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="memory" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//(Type)[pmd-java:typeIs('java.util.Calendar')]
,
//Name[starts-with(@Image, 'Calendar.')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CalendarStuff {
    Calendar field1; // bad

    private Calendar bad1() {
        return Calendar.getInstance();
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableLists"
          language="java"
          message="List is not modified after object construction, make it immutable or unmodifiable"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml01">
        <description>Problem: A list which is unnecessarily mutable may accidentally be added to and cause a memory leak. &#13;
            Solution: Make it impossible to modify the list after object construction/initialization: use Java 9 List.of, Java 11 List.copyOf, Collections.unmodifiableList or Guava ImmutableList.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="pitfall" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
    (: a field of type List :)
    //FieldDeclaration[pmd-java:typeIs('java.util.List')]
    (: exclude ConfigurationProperties classes :)
    [count(ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties']) = 0]
    (: exclude when JPA annotated :)
    [count(../Annotation//Name[@Image='OneToMany' or @Image='ManyToMany']) = 0]
    //VariableDeclaratorId[
    (: with a method defined at that level that does not use the field with a modify operation (case field.modOp) :)
    not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
    starts-with(substring-after(@Image, '.'), 'add') or
    starts-with(substring-after(@Image, '.'), 'remove') or
    substring-after(@Image, '.') = 'set' or
    substring-after(@Image, '.') = 'clear' or
    substring-after(@Image, '.') = 'replaceAll' or
    substring-after(@Image, '.') = 'retainAll'
    ]/(substring-before(concat(@Image, '.'), '.')))]
    [ (: and case this.field.modOp() :)
not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression
/PrimarySuffix[starts-with(@Image, 'add') or starts-with(@Image, 'remove') or @Image = 'set' or @Image = 'clear' or @Image = 'replaceAll' or @Image = 'retainAll']
/preceding-sibling::PrimarySuffix/@Image)
    ]     (: and :)
    [( (: field is initialized with List allocation :)
    ../VariableInitializer/Expression//AllocationExpression[pmd-java:typeIs('java.util.List')]
    or
    (: or static block / constructor has field initialized with List allocation :)
    ancestor::ClassOrInterfaceBody//(Initializer|ConstructorDeclaration)//AssignmentOperator[exists(../Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.List')])]/..//Name/@Image = @Name
    or
    (: or constructor has a simple assignment to the field, param of literal: no arguments :)
    ancestor::ClassOrInterfaceBody//ConstructorDeclaration//AssignmentOperator[exists(../Expression[pmd-java:typeIs('java.util.List')]) and not(exists(../Expression/PrimaryExpression/PrimarySuffix))]/..//Name/@Image = @Name
    )]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Bad {
    List unmutated = new ArrayList(Arrays.asList("one", "two")); // bad
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
public class Good {
    List unmutated1 = Collections.unmodifiableList(Arrays.asList("one", "two")); // Java 8
    List unmutated2 = List.of("one", "two"); // Java 9+
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnnecessaryStringBuilderCreation"
          language="java"
          message="Use concatenation (+) instead of new StringBuilder if only one statement."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu05">
        <description>Problem: Creating a StringBuilder and using append is more verbose, less readable and less maintainable than simply using String concatenation (+).
            For one statement resulting in a String, creating a StringBuilder and using append is not faster than simply using concatenation.&#13;
            Solution: Simply concatenate Strings in one statement, it is more concise, better readable and more maintainable.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="bad-practice" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(: append used in one chained statement on allocated StringBuilder and with chained toString :)
//MethodDeclaration//Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/../../../PrimarySuffix[@Image = "toString"]/../PrimarySuffix[@Image = "append"][1] (: only report first append in chain :)
|
(: or :)
(: append on builder var, where var is allocated as StringBuilder :)
//MethodDeclaration//Block//PrimaryPrefix/Name[ends-with(@Image, '.append') and starts-with(@Image,
ancestor::Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/ancestor::VariableDeclarator/VariableDeclaratorId/@Name[0])
and
(
(: and either 1. toString is called in a chain after append :)
../../PrimarySuffix[@Image = 'toString'] or
(: or 2. toString is called on the var in same block :)
concat(substring-before(@Image, '.'), '.toString') = ancestor::Block//PrimaryPrefix/Name[ends-with(@Image, '.toString')]/@Image)
(: and not append on var used in inner block like a ForStatement :)
and not(ancestor::Block//Block//PrimaryPrefix/Name[ends-with(@Image, '.append')])
(: and not append in lambda expression, issue 195 :)
and not(ancestor::LambdaExpression)
(: and var not passed as argument to method :)
and not(substring-before(@Image, '.') = ancestor::Block//Statement//PrimarySuffix/Arguments//Name/@Image)
]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    String name;
    String value;

    public String bad() {
        return new StringBuilder()
           .append(name) // bad
           .append(" = ")// bad
           .append(value)// bad
           .toString();
    }

    public String good() {
        return name + " = " + value;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="OptimizeMapOrSetForEnum"
          language="java"
          message="Map has enum keys or Set has enum elemens, use EnumMap or EnumSet for more efficiency."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc03">
        <description>Problem: A HashMap and HashSet are rather greedy in memory usage.&#13;
            Solution: Use an EnumMap or EnumSet. It is represented internally with arrays which is extremely compact and efficient.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="memory" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :) (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//LocalVariableDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//Initializer//StatementExpression[Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
[PrimaryExpression//Name/@Image =
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName]]/VariableDeclarator/VariableDeclaratorId/@Name]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
Map<YourEnumType, String> map = new EnumMap<>(YourEnumType.class);
Set<YourEnumType> set = EnumSet.allOf(YourEnumType.class);
            ]]>
        </example>
    </rule>

    <rule name="AvoidLombokAnnotationForNonExistentFields"
          language="java"
          message="Avoid Lombok annotations for fields of a class while the class has no fields."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="">
        <description>Problem: Lombok annotations for fields [@Getter, @Setter, @EqualsAndHashCode, @Value, @Data] are of no use and confusing in case the class has no fields.&#13;
            Solution: Remove the Lombok annotation.
        </description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="unused" type="String" description="for-sonar"/>
            <property name="tag" value="confusing" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)/Annotation
    [MarkerAnnotation/Name[@Image='Getter' or @Image='Setter' or @Image='Value' or @Image='Data' or @Image='EqualsAndHashCode']]
    [count(..//FieldDeclaration) = 0]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
        @Data // bad
        public class BusinessException extends RuntimeException {
            // no fields, no methods
        }
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalCreatedLogArguments"
          language="java"
          message="Avoid unconditional creation of a log argument, it may not be needed."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il06">
        <description>Problem: Creation of a log argument with a toString or other operation(s) may be expensive, while depending on the log level, the result may not be used.&#13;
            Solution: Create the log argument conditionally on the log level, within an if statement. For just 'obj.toString()', just pass 'obj' to the log method and leave it to SLF4J to call toString() only if needed.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name
    (: log levels typically/often not enabled :)
    [ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or ends-with(@Image,'.info')]
    (: no violation if conditionally: only executed if level enabled is okay :)
    [not(ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: no violation if return conditionally before :)
    [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: an argument in the log method :)
    /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
    [
    (: equals a declared var :)
    (PrimaryPrefix/Name[@Image = ancestor::MethodDeclaration//VariableDeclarator
        (: with initializer not like obj.get[Xxx], we assume a simple getter is quick, unless this is in a loop :)
        [not(contains(string-join(./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image, '-'), '.get')
             (: this.field.get[Xxx] case #209 :)
             or ./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix[@Image = '']/../PrimarySuffix[starts-with(@Image, 'get')])
         or ancestor::WhileStatement or ancestor::ForStatement or ancestor::DoStatement]/VariableDeclaratorId/@Name
    (: and it is not used in a return :)
    and (not(@Image = ancestor::Block//ReturnStatement//Name/@Image))
    (: and it is not used in a constructor of a local var :)
    and (not(@Image = ancestor::Block//AllocationExpression//Name/@Image))
    (: and it is not used as an argument in another method call than log :)
    and (not(@Image = ancestor::Block//PrimaryExpression[PrimaryPrefix/Name
        [not(ends-with(@Image, 'trace') or ends-with(@Image, 'debug') or ends-with(@Image, 'info'))]]/PrimarySuffix/Arguments//Name/@Image))
    (: and it is not used in the method in a blockstatement before a '.', like logObj.toString() other than method call argument.
       It is a contains, so a violation is missed when the log arg/declared var e.g. is 'log' and a 'obj.log()' is used :)
    and (not(contains(string-join(ancestor::MethodDeclaration//Name[ancestor::BlockStatement/(Statement|LocalVariableDeclaration)[count(./StatementExpression//PrimarySuffix//ArgumentList//Name/@Image) = 0]]/@Image, '.'), concat(@Image, '.')) ))
    (: method name starts with log, we assume it is called conditionally :)
    and (not(ancestor::MethodDeclaration[starts-with(@Name, 'log')]))
    ])
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    void bad(Object obj) {
      String logObj = obj.toString();
      log.debug("object to String: {}", logObj); //bad
    }

    void good(Object obj) {
      log.debug("object to String: {}", obj); //good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="ImproperVariableName"
          language="java"
          message="Give variables and fields a meaningful name."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#m01">
        <description>Problem: Variables like 'var3' and fields like 'FOUR = 4', do not express what they are used for. This is bad for maintainability.&#13;
            Solution: Let variable names express what they are used for, like 'key' and 'MAX_KEYS = 4'
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="bad-practice" type="String" description="for-sonar"/>
            <property name="tag" value="confusing" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaratorId[matches(@Name, 'ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN', 'i')
and replace(@Name, 'ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|_', '', 'i') = ''
or starts-with(@Name, 'var') and number(substring-after(@Name, 'var'))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private static final int FOUR_ZERO_NINE_SIX = 4096; // bad
    private static int six = 6; // bad
    private int five = 6; // really bad
    private static final int SIXTIES_START = 1960; // good

    void bar() {
        String var1 = "baz"; // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidExposingMutableRecordState"
          language="java"
          message="Avoid exposing mutable state of the record. Use copyOf in the compact constructor."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos06">
        <description>Problem: Internal state can be modified from outside of the record, through the implicit accessor method or by the caller of the constructor. Risk of thread-unsafety.
            Solution: Use the record compact constructor to defensively copy the (possibly) mutable object such as a List, Set or Map, e.g. with List.copyOf().
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="multi-threading" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//RecordDeclaration//RecordComponent/Type[(pmd-java:typeIs('java.util.Collection') or pmd-java:typeIs('java.util.Map'))
and
not(../VariableDeclaratorId/@Name = ancestor::RecordDeclaration/RecordBody/CompactConstructorDeclaration//StatementExpression
[Expression//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'copyOf')]]/PrimaryExpression/PrimaryPrefix/Name/@Image)]                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
record BadRecord(String name, List<String> list) {
}

record GoodRecord(String name, List<String> list) {
    public GoodRecord {
        list = List.copyOf(list);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReStreamingEnumValues"
          language="java"
          message="Avoid re-streaming enum values to find a value by a field."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc07">
        <description>Problem: the time to find element is O(n); n = the number of enum values. This identical processing is executed for every call. Considered problematic when n > 3.
            Solution: use a static field-to-enum-value Map. Access time is O(1), provided the hashCode is well-defined.
            For one String field, usually toString returns that field. Implement a fromString method to provide the reverse conversion by using the map.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
    //EnumDeclaration/EnumBody[count(EnumConstant) > 3]//MethodDeclaration/Block//PrimaryExpression
    [PrimaryPrefix/Name[@Image='Arrays.stream' or @Image='Stream.of']]
    [//PrimaryExpression/PrimaryPrefix/Name[@Image = 'values' or @Image = concat(ancestor::EnumDeclaration/@SimpleName, '.values')]]
    [PrimarySuffix[starts-with(@Image, 'find')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
// BAD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Stream.of(values()).filter(v -> v.toString().equals(name)).findAny(); // bad: iterates for every call, O(n) access time
    }
}

Usage: `Fruit f = Fruit.fromString("banana");`

// GOOD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private static final Map<String, Fruit> nameToValue =
            Stream.of(values()).collect(toMap(Object::toString, v -> v));
    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Optional.ofNullable(nameToValue.get(name)); // good, get from Map, O(1) access time
    }
}
            ]]>
        </example>
    </rule>

    <rule name="NonComparableMapKeys"
          language="java"
          message="Map keys should implement Comparable in order to make access fast."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc08">
        <description>Problem: If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access will be slow.
            Solution: Implement Comparable for your Map keys. Do not use classes for the keys which don't implement Comparable, like Thread, Class and Object. At least not for Maps which can grow large.
            Note that equals and hashCode must be implemented properly for the keys, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(: check key/elem type in declaration :)
//Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.util.Map')]
(: first type argument does not implement Comparable :)
[TypeArguments/TypeArgument[1]/ReferenceType[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]]
,
(: for when key/elem type ise missing in declaration, check Map.put and Set.add :)
//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.put') and pmd-java:typeIs('java.util.Map')]]
/PrimarySuffix/Arguments/ArgumentList/Expression[1]
(: first arg does not implement Comparable :)
[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
 class Foo {
    Map<Object, String> oMap; // bad, Object does not implement Comparable
    Map<Thread, String> tMap; // bad, Thread does not implement Comparable

    Map oldStyleMap = new HashMap(); // cannot check here

    void putInOldStyleBad() {
        oldStyleMap.put(new Thread(), "value"); // bad
    }

    Map<Comparable, String> cMap; // good

    void putInOldStyleGood() {
        oldStyleMap.put("key", "value");
    }
}

            ]]>
        </example>
    </rule>

    <rule name="NonComparableSetElements"
          language="java"
          message="Set elements should implement Comparable in order to make access by element fast."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoc09">
        <description>Problem: A Set is implemented with a Map. If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red-black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access by element will be slow. Iterating through the elements does not suffer from this slow access because no lookup by key in the map is involved.
            Access methods by element which are affected: contains[All], retainAll, remove[All].
            Solution: Implement Comparable for your own Set elements. Avoid using large Sets with elements of types which don't implement Comparable, like Thread, Class and Object. At least when using access by element.
            Note that equals and hashCode must be implemented properly for the elements, and compareTo must be compatible with equals.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-low" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
,
//(FormalParameter|LocalVariableDeclaration)/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import org.apache.hc.client5.http.HttpRoute; // does implement equals/hashCode yet *not* compareTo

class Foo {
  Set<String> strSet = new HashSet<>();
  List<String> strList = new ArrayList<>();
  Set<HttpRoute> fieldRouteSet = new HashSet<>(); // bad
  List<HttpRoute> routeList = new ArrayList<>();

  void byElemBad(Set<HttpRoute> paramRouteSet) { // bad
    paramRouteSet.retainAll(routeList);

    fieldRouteSet.contains(t);

    Set<HttpRoute> localRouteSet = new HashSet<>(); // bad
    localRouteSet.removeAll(routeList);
  }

  void otherCasesGood(Set<HttpRoute> paramRouteSet) {
    strSet.contains("bla");
    strSet.retainAll(strList);
    strSet.remove("other");
    paramRouteSet.iterator().next();
  }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFileStreaming"
          language="java"
          message="FileInputStream and FileOutputStream are not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio05">
        <description>Problem: With FileInputStream and FileOutputStream, file access is not buffered.
            The stream is read-from/written-to file byte by byte, where each operating system call has its overhead, which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use BufferedOutput/InputStream which has a buffer size of 8 kB by default to write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-high" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="tag" value="io" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//Resource//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.FileInputStream') or pmd-java:typeIs('java.io.FileOutputStream')]
[not (ancestor::AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
[not (ancestor::TryStatement//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.io.*;

class BufferFileStreaming {
    void bad(String inputFilename, String outputFilename) {
        try (FileInputStream fis = new FileInputStream(inputFilename)) { // bad
            //use fis
        }
    }
    void good(String inputFilename, String outputFilename) {
        try (InputStream bfis = new BufferedInputStream(new FileInputStream(inputFilename))) { // good
            //use bfis
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFilesNewStream"
          language="java"
          message="Files.newInputStream or Files.newOutputStream is not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio06">
        <description>Problem: Files.newInputStream or Files.newOutputStream is not buffered.
            The stream is read from/written to file byte by byte, where each operating system call has its overhead which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use e.g. BufferedInputStream or BufferedOutputStream which has a buffer size of 8 kB to read/write at once. Make sure to close it after use.
        </description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-high" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="tag" value="io" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newOutputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedOutputStream')]) = 0]]
,
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newInputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedInputStream')]) = 0
and (not(.//PrimaryPrefix/Name[pmd-java:typeIs('org.apache.commons.io.IOUtils') and starts-with(@Image, 'IOUtils.read')]))
]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    OutputStream badO(String path) throws IOException {
        return java.nio.file.Files.newOutputStream(Paths.get(path)); // bad
    }
    OutputStream goodO(String path) throws IOException {
        return new BufferedOutputStream(java.nio.file.Files.newOutputStream(Paths.get(path)));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLoadingAllFromFile"
          language="java"
          message="Files.readAll methods load all bytes from a file into memory: a risk of memory problems."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: Files.readAllBytes and Files.readAllLines load all bytes from a file into the heap memory.
            This may result in an OutOfMemoryError crash, or long gc pauses and slow responses.
            Solution: Stream-through: use streaming all the way, don't store the whole thing in memory, don't use byte arrays.
            Often, functionality can be achieved in a streaming way.
            Note: not a problem for small files.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-medium" type="String" description="for-sonar"/>
            <property name="tag" value="memory" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[@Image='Files.readAllBytes' or @Image='Files.readAllLines']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    void bad(Path path) {
        byte[] fileBytes = Files.readAllBytes(path); // bad
        List<String> fileLines = Files.readAllLines(path); // bad
        // process bytes / lines
    }
}

class Good {
    void good(Path in) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(in)) {
            String line = reader.readLine();
            // process line by line
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="HashCodeOnlyCallsSuper"
          language="java"
          message="hashCode only calls super."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>Problem: when equals is implemented, hashCode needs to be implemented, too; and if objects are equal, hashCode needs to be equal, too. If hashCode only calls super.hashCode, it is effectively not implemented.
            Strange things can happen, for instance, if super.hashCode calls Object.hashCode, it is unique for each object and when used in Set or as key in Map, equal objects can duplicate in Set, and keys not found in Map.
            Solution: implement hashCode properly, consistent with equals. Meet the equals and hashCode contracts. If objects are equal, hashCode needs to be equal, too. See Effective Java.
        </description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="correctness" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and @Public=true() and @Static=false()]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and MethodDeclarator/FormalParameters/@Size=0 and @Public=true() and @Static=false()]
/Block[count(./BlockStatement/Statement) = 1][count(.//ArgumentList) = 0]//PrimaryExpression[PrimaryPrefix[@SuperModifier=true()]]/PrimarySuffix[@Image='hashCode']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return super.hashCode(); // bad
    }
}

class Good {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingSecurityProviders"
          language="java"
          message="Avoid re-creating security providers, this is expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuosf01">
        <description>Problem: Creating a security provider is expensive because of loading of algorithms and other classes. Additionally, it uses synchronized which leads to lock contention when used with multiple threads.
            Solution: This only needs to happen once in the JVM lifetime, because once loaded, the provider is typically available from the Security class. Create the security provider only once: only in case it is nog available from the Security class, yet.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="tag" value="performance" type="String" description="for-sonar"/>
            <property name="tag" value="sustainability-high" type="String" description="for-sonar"/>
            <property name="tag" value="cpu" type="String" description="for-sonar"/>
            <property name="tag" value="io" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[not((@Name='main' and @Static=true())or ../Annotation//Name/@Image='PostConstruct'
or .//IfStatement//EqualityExpression[@Operator='=='][
.//PrimaryExpression[pmd-java:typeIs('java.security.Provider')] and .//NullLiteral])]
//AllocationExpression[pmd-java:typeIs('java.security.Provider')]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.security.*;
import javax.crypto.*;
import org.bouncycastle.jce.provider.*;

class Foo {
    public Cipher initBlowfishBad() throws GeneralSecurityException {
        Security.addProvider(new BouncyCastleProvider()); // bad
        // build a Cipher
    }

    public Cipher initBlowfishGood() throws GeneralSecurityException {
        Provider bouncyCastleProvider = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);
        if (bouncyCastleProvider == null) {
            bouncyCastleProvider = new BouncyCastleProvider();
            Security.addProvider(bouncyCastleProvider);
        }
        // build a Cipher
    }
}
            ]]>
        </example>
    </rule>

</ruleset>
