<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by Contexts and Dependency Injection (CDI) for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        </description>
        <priority>1</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[@MethodName='select']/MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyClause
    //MethodCall[@MethodName='destroy'][ArgumentList/VariableAccess[@Name=ancestor::
        MethodDeclaration//(VariableDeclarator|AssignmentExpression)[.//MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']]/(VariableId|VariableAccess)/@Name]]
    [MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']])
]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,bad-practice" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[@Interface=true()]/ClassBody/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface AnimalConsts {
    public static final Dog DOG = new Dog(); //bad
}
public class AnimalUtil {
    private AnimalUtil() {}
    public static final Dog DOG = new Dog(); // good
}
public enum Animal {
    DOG // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.NumberFormat: DecimalFormat and ChoiceFormat are thread-unsafe.&#13;
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
 //FieldDeclaration/ClassType[pmd-java:typeIs('java.text.NumberFormat')]
        ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    public static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("###.###"); // bad

    public void bar() {
        NumberFormat format = new DecimalFormat("###.###"); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected to have different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- assigned to same var in a previous switch case --:)
//SwitchStatement//SwitchFallthroughBranch/ExpressionStatement[AssignmentExpression[not(pmd-java:typeIs('boolean'))]/VariableAccess[1]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[1]/@Name
and (
(:-- assigning same var --:)
AssignmentExpression/VariableAccess[2]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[2]/@Name
or
(:-- assigning same literal --:)
AssignmentExpression/(StringLiteral|NumericLiteral)/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(StringLiteral|NumericLiteral)/@Image
or
(:-- assigning constructor with same argument or same argumentless method  --:)
AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image
)
(:--default case allowed to have duplicates --:)
and not (preceding-sibling::SwitchLabel[@Default=true()])]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe, so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(:- method calls for non-short regex literals and used fields defined with non-short regex literal, or not defined as field -:)
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.lang.String#replaceAll(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#replaceFirst(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.util.regex.Pattern#matches(java.lang.String,java.lang.CharSequence)')
    or pmd-java:matchesSig('java.lang.String#split(java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#matches(java.lang.String)')
    or pmd-java:matchesSig('java.nio.file.FileSystem#getPathMatcher(java.lang.String)')
]
/ArgumentList/*[1][(local-name()='StringLiteral' and string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')))
or
(local-name()='VariableAccess') and @Name=ancestor::ClassBody/FieldDeclaration/VariableDeclarator[StringLiteral[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or not(StringLiteral)]/VariableId/@Name]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
//bad
String bad_replaceInnerLineBreakBySpace() {
    return text.replaceAll("([^\\.\\n])\\n", "$1 "); // bad
}

// good
private static final Pattern INNER_LINE_BREAK_PATTERN = Pattern.compile("([^\\.\\n])\\n");

String good_replaceInnerLineBreakBySpace() {
    return INNER_LINE_BREAK_PATTERN.matcher(text).replaceAll("$1 "); // good
}
            ]]>
        </example>
    </rule>

    <!-- temp saved

    (:- String#replaceAll or String#replaceFirst and Pattern.matches for non-short regex literals and used fields defined with non-short regex literal -:)
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.lang.String#replaceAll(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#replaceFirst(java.lang.String,java.lang.String)')
    or (pmd-java:matchesSig('java.util.regex.Pattern#matches(java.lang.String,java.lang.CharSequence)'))]
/ArgumentList[@Size=2]/*[1][(local-name()='StringLiteral' and string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')))
or
(local-name()='VariableAccess') and @Name=ancestor::ClassBody/FieldDeclaration/VariableDeclarator[StringLiteral[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]]/VariableId/@Name]

-->

</ruleset>
