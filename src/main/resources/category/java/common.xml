<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-common-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by Contexts and Dependency Injection (CDI) for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        </description>
        <priority>1</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[@MethodName='select']/MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyClause
    //MethodCall[@MethodName='destroy'][ArgumentList/VariableAccess[@Name=ancestor::
        MethodDeclaration//(VariableDeclarator|AssignmentExpression)[.//MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']]/(VariableId|VariableAccess)/@Name]]
    [MethodCall[@MethodName='current']/TypeExpression/ClassType[@SimpleName='CDI']])
]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java" message="Interface defines constants. It may expose implementation details."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,bad-practice" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[@Interface=true()]/ClassBody/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface AnimalConsts {
    public static final Dog DOG = new Dog(); //bad
}
public class AnimalUtil {
    private AnimalUtil() {}
    public static final Dog DOG = new Dog(); // good
}
public enum Animal {
    DOG // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.NumberFormat: DecimalFormat and ChoiceFormat are thread-unsafe.&#13;
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        </description>
        <priority>1</priority>
        <properties>
            <property name="pmd-version" value="7" type="String" description="for-compatibility"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
 //FieldDeclaration/ClassType[pmd-java:typeIs('java.text.NumberFormat')]
        ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    public static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("###.###"); // bad

    public void bar() {
        NumberFormat format = new DecimalFormat("###.###"); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected to have different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- assigned to same var in a previous switch case --:)
//SwitchStatement//SwitchFallthroughBranch/ExpressionStatement[AssignmentExpression[not(pmd-java:typeIs('boolean'))]/VariableAccess[1]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[1]/@Name
and (
(:-- assigning same var --:)
AssignmentExpression/VariableAccess[2]/@Name=
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/VariableAccess[2]/@Name
or
(:-- assigning same literal --:)
AssignmentExpression/(StringLiteral|NumericLiteral)/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(StringLiteral|NumericLiteral)/@Image
or
(:-- assigning constructor with same argument or same argumentless method  --:)
AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image =
../preceding-sibling::SwitchFallthroughBranch//preceding-sibling::ExpressionStatement/AssignmentExpression/(ConstructorCall/ArgumentList[@Size=1]/StringLiteral|MethodCall[ArgumentList[@Size=0]])/@Image
)
(:--default case allowed to have duplicates --:)
and not (preceding-sibling::SwitchLabel[@Default=true()])]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe, so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(:- method calls for non-short regex literals and used fields defined with non-short regex literal, or not defined as field -:)
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.lang.String#replaceAll(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#replaceFirst(java.lang.String,java.lang.String)')
    or pmd-java:matchesSig('java.util.regex.Pattern#matches(java.lang.String,java.lang.CharSequence)')
    or pmd-java:matchesSig('java.lang.String#split(java.lang.String)')
    or pmd-java:matchesSig('java.lang.String#matches(java.lang.String)')
    or pmd-java:matchesSig('java.nio.file.FileSystem#getPathMatcher(java.lang.String)')
]
/ArgumentList/*[1][(self::StringLiteral and string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')))
or
self::VariableAccess and @Name=ancestor::ClassBody/FieldDeclaration/VariableDeclarator[StringLiteral[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or not(StringLiteral)]/VariableId/@Name]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
//bad
String bad_replaceInnerLineBreakBySpace() {
    return text.replaceAll("([^\\.\\n])\\n", "$1 "); // bad
}

// good
private static final Pattern INNER_LINE_BREAK_PATTERN = Pattern.compile("([^\\.\\n])\\n");

String good_replaceInnerLineBreakBySpace() {
    return INNER_LINE_BREAK_PATTERN.matcher(text).replaceAll("$1 "); // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio01">
        <description>Problem: The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Pre-size the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall[pmd-java:matchesSig('java.io.ByteArrayOutputStream#new()') or pmd-java:matchesSig('java.io.StringWriter#new()')
or
((pmd-java:matchesSig('java.io.ByteArrayOutputStream#new(int)') and (ArgumentList/NumericLiteral/@ValueAsInt <=32
        or ArgumentList/VariableAccess/@Name = ancestor::ClassBody/FieldDeclaration/VariableDeclarator[NumericLiteral/@ValueAsInt <= 32]/VariableId/@Name))
    or (pmd-java:matchesSig('java.io.StringWriter#new(int)') and (ArgumentList/NumericLiteral/@ValueAsInt <=16
        or ArgumentList/VariableAccess/@Name = ancestor::ClassBody/FieldDeclaration/VariableDeclarator[NumericLiteral/@ValueAsInt <= 16]/VariableId/@Name))
)
]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static void bad()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //bad
        StringWriter sw = new StringWriter(); //bad
        baos = new ByteArrayOutputStream(32); //bad - not larger than default
    }
}
class Good {
    public static void good()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); // 8 kiB
        StringWriter sw = new StringWriter(2048);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMultipleConcatStatements"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Multiple statements concatenate to the same String. Use StringBuilder append."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//AssignmentExpression[@Operator='+='][VariableAccess/@Name=ancestor::Block//VariableDeclarator/VariableId[pmd-java:typeIs('java.lang.String')]/@Name]
[VariableAccess/@Name = ../preceding-sibling::ExpressionStatement/AssignmentExpression[@Operator='+=']/VariableAccess/@Name]
|
//InfixExpression[@Operator='+'][VariableAccess/@Name=../VariableAccess/@Name][VariableAccess/@Name=ancestor::Block//VariableDeclarator/VariableId[pmd-java:typeIs('java.lang.String')]/@Name]
[VariableAccess/@Name = ../../preceding-sibling::ExpressionStatement//InfixExpression[@Operator='+']/VariableAccess/@Name]/..
	]]></value>
            </property>
        </properties>
        <example>
        <![CDATA[
class ConcatsExample {

    private String[] values = {"tic", "tac"};

    String bad() {
        String logStatement = "";
        logStatement += values[0];
        return logStatement += values[1]; // bad
    }
    String good() {
        StringBuilder logStmtBuilder = new StringBuilder();
        return logStmtBuilder.append(values[0]).append(values[1]).toString(); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingPatterns"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//MethodCall[pmd-java:matchesSig('java.util.regex.Pattern#compile(java.lang.String)')
and not(.//VariableAccess[@Name = ancestor::MethodDeclaration//FormalParameter/VariableId/@Name])]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe."
      externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPath#compile(java.lang.String)') or
    pmd-java:matchesSig('javax.xml.xpath.XPath#evaluate(java.lang.String,java.lang.Object,javax.xml.namespace.QName)')]
             ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static NodeList bad1(Document doc) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
        return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
    }
    public static NodeList bad2(Document doc) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        String xPathQuery = "//book[author='Isaac Asimov']/title/text()";
        return (NodeList) xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET); // bad
    }
}

class Good {
    private static final ThreadLocal<XPathFactory> tlFac = ThreadLocal.withInitial(XPathFactory::newInstance);
    private static final ThreadLocal<XPathExpression> tlExpr;
    static {
        XPath xpath = tlFac.get().newXPath();
        try {
            XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()");
            tlExpr = ThreadLocal.withInitial(() -> expr); // good
        } catch (XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }
    public static NodeList good(Document doc) throws XPathExpressionException {
        return (NodeList) tlExpr.get().evaluate(doc, XPathConstants.NODESET); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" language="java"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: Java 8+ java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration
[ClassType[pmd-java:typeIs('java.time.format.DateTimeFormatter') or pmd-java:typeIs('org.joda.time.format.DateTimeFormatter')]]
[(not(pmd-java:modifiers() = 'static') and VariableDeclarator[@Initializer=true()]) or not(pmd-java:modifiers() = 'final')]
|
//MethodDeclaration//ConstructorCall[pmd-java:matchesSig('org.joda.time.format.DateTimeFormatter#new(_,_)')]
|
//(MethodDeclaration|ConstructorDeclaration)//MethodCall[((pmd-java:matchesSig('java.time.format.DateTimeFormatter#ofPattern(_)')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormat#forPattern(_)'))
   and not(ArgumentList/VariableAccess/@Name = ancestor::Block/..//FormalParameter/VariableId/@Name))
 or pmd-java:matchesSig('java.time.format.DateTimeFormatterBuilder#toFormatter()')
 or pmd-java:matchesSig('java.time.format.DateTimeFormatterBuilder#toFormatter(_)')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormatterBuilder#toFormatter()')
 or pmd-java:matchesSig('org.joda.time.format.ISODateTimeFormat#_()')
 or pmd-java:matchesSig('org.joda.time.format.DateTimeFormat#fullDateTime()')
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Reflection is used in toString or hashCode, which is expensive."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, like generation by IDE or Lombok.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[starts-with(@MethodName, 'reflection')][(TypeExpression|ConstructorCall)
    [pmd-java:typeIs('org.apache.commons.lang3.builder.EqualsBuilder') or pmd-java:typeIs('org.apache.commons.lang3.builder.HashCodeBuilder')]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    private int state;

    public boolean equals(Object o) {
        return EqualsBuilder.reflectionEquals(o, this); // bad
    }
}

class Good {
    private int state;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Good)) return false;
        return new EqualsBuilder().append(((Good)o).state, state).isEquals();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSimpleDateFormat"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall/ClassType[pmd-java:typeIs('java.text.SimpleDateFormat')
  and not ((ancestor::LocalVariableDeclaration/following-sibling::ExpressionStatement/MethodCall|ancestor::MethodCall)
    [@MethodName='setDateFormat']/VariableAccess[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
      or pmd-java:typeIs('com.fasterxml.jackson.dataformat.xml.XmlMapper')])
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private String toKeyBad(final Date date) {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd"); //bad
        return formatter.format(date);
    }
    private String toKeyGood(final LocalDate localDate) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); //good
        return formatter.format(localDate);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidStringBuffer"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="StringBuffer is used. It introduces locking overhead, use StringBuilder."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ConstructorCall/ClassType[pmd-java:typeIs('java.lang.StringBuffer')]
]]>
                </value>
            </property>
        </properties>
        <example>
class Foo {
    public void bad() {
        var sb = new StringBuffer(); // bad
    }
    public void good() {
        var sb = new StringBuilder(); // good
    }
}
        </example>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Log String is built irrespective of log level."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
[pmd-java:matchesSig('java.lang.StringBuilder#append(java.lang.String)')]
(: variable in append following used in logging :)
[VariableAccess/@Name=(ancestor::ExpressionStatement|ancestor::ForeachStatement|ancestor::DoStatement|ancestor::WhileStatement)
  /(following-sibling::TryStatement|following-sibling::ExpressionStatement)//MethodCall
  [@MethodName=('trace', 'debug', 'info')]
  [VariableAccess[pmd-java:typeIs('org.slf4j.Logger') or pmd-java:typeIs('java.util.logging.Logger') or pmd-java:typeIs('org.apache.commons.logging.Log')]]
    //VariableAccess/@Name
]
(: variable in append following not used in anything other than logging :)
[not(
VariableAccess/@Name=(ancestor::ExpressionStatement|ancestor::ForeachStatement|ancestor::DoStatement|ancestor::WhileStatement)
  /(following-sibling::TryStatement|following-sibling::ExpressionStatement)//MethodCall
  [not(@MethodName=('trace', 'debug', 'info'))
  or VariableAccess[not(pmd-java:typeIs('org.slf4j.Logger')) and not(pmd-java:typeIs('java.util.logging.Logger')) and not(pmd-java:typeIs('org.apache.commons.logging.Log'))]]
    //VariableAccess/@Name
)]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
   public void bad(List values) {
        var logLine = new StringBuilder();
        for (String val : values) {
            logLine.append(val + ", "); // bad
        }
        LOG.debug("log: {}.", logLine);
    }
    public void good(List values) {
        if (LOG.isDebugEnabled()) {
            var logLine = new StringBuilder();
            for (String val : values) {
                logLine.append(val + ", ");
            }
            LOG.debug("log: {}.", logLine);
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidWideScopeXPathExpression"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPathExpression targets a wide scope, this is potentially slow."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPath#compile(java.lang.String)')]/ArgumentList/StringLiteral[starts-with(@Image, '"//')]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    public bad() throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
    }
    public good() throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("/public/library/books/book[author='Isaac Asimov']/title/text()");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidXPathAPIUsage"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPathAPI is used. XPathAPI implementation has bad performance."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall/TypeExpression/ClassType[pmd-java:typeIs('org.apache.xpath.XPathAPI')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="XPath is used. XPath implementation has bad performance."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig('javax.xml.xpath.XPathFactory#newInstance()')]
[not (ancestor::FieldDeclaration/ClassType[pmd-java:typeIs('java.lang.ThreadLocal')])]
	]]></value>
            </property>
        </properties>
    </rule>

<!-- complex rule TODO ImplementEqualsHashCodeOnValueObjects -->

    <rule name="MDCPutWithoutRemove"
          message="MDC put is used without finally remove."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance,correctness" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#put(java.lang.String,java.lang.String)')]/ArgumentList/*[1][self::StringLiteral or self::VariableAccess]
[not(@Image=ancestor::TryStatement//FinallyClause//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#remove(java.lang.String)')]/ArgumentList/*[1]/@Image
or ancestor::TryStatement//FinallyClause//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#clear()')]
or @Image=ancestor::ClassBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#remove(java.lang.String)')]/ArgumentList/*[1]/@Image
or ancestor::ClassBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']//MethodCall[pmd-java:matchesSig('org.slf4j.MDC#clear()')]
)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalConcatInLogArgument"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="String concatenation (+) is executed regardless of log level and can be expensive"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
  [@MethodName=('trace','debug','info')]
  [VariableAccess[pmd-java:typeIs('org.slf4j.Logger') or pmd-java:typeIs('java.util.logging.Logger') or pmd-java:typeIs('org.apache.commons.logging.Log')]]
  /ArgumentList[.//InfixExpression[@Operator='+'][(VariableAccess|MethodCall)[pmd-java:typeIs('java.lang.String')] or (StringLiteral and (VariableAccess or MethodCall))]]
[not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
@slf4j
class Foo {
    void bad(String a, String b) {
        log.debug("message: {}", a + b); // bad
    }
    void good(String a, String b) {
        log.debug("message: {}-{}", a, b); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Operation is executed regardless of log level and can be expensive"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.getXXX(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
(: log levels often not enabled in prod :)
  [@MethodName=('trace','debug','info')]
(: supported logging libs :)
  [VariableAccess[pmd-java:typeIs('org.slf4j.Logger') or pmd-java:typeIs('java.util.logging.Logger') or pmd-java:typeIs('org.apache.commons.logging.Log')]]
(: only if unconditional :)
  [not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
(: and not returned conditionally before :)
  [not(ancestor::ExpressionStatement/preceding-sibling::IfStatement[.//ReturnStatement and .//MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')]])]
(: for operations in log with >0 arguments or toString(); except getters which are assumed as fast :)
  /ArgumentList//MethodCall[(ArgumentList[@Size>0] or @MethodName='toString') and not(starts-with(@MethodName, 'get'))]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    LOG.debug("customer = {}", customer.toString()); // bad
    LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

    LOG.debug("customer = {}", customer); // good
    if (LOG.isDebugEnabled()) { // good
        LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
    }
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Using SuppressWarnings for a rule that is meant to prevent high risk problems."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - are you sure?) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious,data-mix-up" type="String" description="classification"/>
            <property name="ruleIdMatches" type="String" value="AvoidUserDataInSharedObjects|AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation[@SimpleName=("SuppressWarnings","SuppressFBWarnings")]//StringLiteral[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@SuppressWarnings({"pmd:AvoidUnguardedMutableFieldsInSharedObjects", "PMD.AvoidUserDataInSharedObjects"}) // suspicious, bad to suppress
@Component @Data
class VMRData {
    private List<OrderDetails> orderList; // a bad idea to have in a singleton, should be solved instead of suppressed
    //..
}
             ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarnings"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="Using SuppressWarnings."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>(Informative - be aware) Problem: This rule detects problems, suppressing them without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation[@SimpleName=("SuppressWarnings","SuppressFBWarnings")]//StringLiteral[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>
    <rule name="UnconditionalCreatedLogArguments"
          language="java"
          message="Avoid unconditional creation of a log argument, it may not be needed."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#il06">
        <description>Problem: Creation of a log argument with a toString or other operation(s) may be expensive, while depending on the log level, the result may not be used.&#13;
            Solution: Create the log argument conditionally on the log level, within an if statement. For just 'obj.toString()', just pass 'obj' to the log method and leave it to SLF4J to call toString() only if needed.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall
    (: log levels typically/often not enabled :)
  [@MethodName=('trace','debug','info')]
  (: supported logger libs :)
  [VariableAccess[pmd-java:typeIs('org.slf4j.Logger') or pmd-java:typeIs('java.util.logging.Logger') or pmd-java:typeIs('org.apache.commons.logging.Log')]]
  (: no violation if conditionally: only executed if level enabled is okay :)
  [not(ancestor::IfStatement/MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')])]
  (: no violation if return conditionally before :)
  [not(ancestor::ExpressionStatement/preceding-sibling::IfStatement[.//ReturnStatement and .//MethodCall[@MethodName = ('isTraceEnabled', 'isDebugEnabled','isInfoEnabled', 'isLoggable')]])]
  (: equals a declared var, with initializer not like obj.get[Xxx], we assume a simple getter is quick; except when in a loop :)
  /ArgumentList//VariableAccess
     [@Name = ancestor::MethodDeclaration//VariableDeclarator[not(MethodCall[starts-with(@MethodName, 'get')] and not(ancestor::WhileStatement or ancestor::ForStatement or ancestor::DoStatement))]/VariableId/@Name]
     (: and it is not used in a return :)
     [not (@Name = ancestor::MethodDeclaration//VariableAccess[not(ancestor::MethodCall[@MethodName=('trace','debug','info')])]/@Name)]
     (: method name starts with log, we assume it is called conditionally :)
     [not(ancestor::MethodDeclaration[starts-with(@Name, 'log')]
 )]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    void bad(Object obj) {
      String logObj = obj.toString();
      log.debug("object to String: {}", logObj); //bad
    }

    void good(Object obj) {
      log.debug("object to String: {}", obj); //good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidTimeUnitConfusion"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing."
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,confusing" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//(VariableDeclarator[../PrimitiveType]|FormalParameter[PrimitiveType])/VariableId[
ends-with(lower-case(@Name), 'timetolive')
or ends-with(lower-case(@Name), 'time_to_live')
or ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout')
or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration')
or ends-with(lower-case(@Name), 'durationout')
or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')
or ends-with(lower-case(@Name), 'timestamp')]
,
(: @Value :)
//Annotation[@SimpleName='Value' and .//MemberValuePair[@Image='value']/StringLiteral[
ends-with(lower-case(@Image), 'timetolive')
or ends-with(lower-case(@Image), 'time_to_live}"')
or ends-with(lower-case(@Image), 'time}"')
or ends-with(lower-case(@Image), 'timeout}"')
or ends-with(lower-case(@Image), 'time_out}"')
or ends-with(lower-case(@Image), 'duration}"')
or ends-with(lower-case(@Image), 'durationout}"')
or ends-with(lower-case(@Image), 'duration_out}"')
or ends-with(lower-case(@Image), 'ttl}"')
or ends-with(lower-case(@Image), 'timestamp}"')]]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

</ruleset>
