<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-remoting-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidDeprecatedHttpConnectors" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid the use of deprecated/thread-unsafe HTTP connectors" typeResolution="true"
      externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi06" >
    <description>Problem: Several HTTP client connection managers are thread-unsafe which may cause session data mix-up or have other issues for which they were made deprecated.&#13;
        Solutions: Upgrade to httpclient-4.5+ and use org.apache.http.impl.conn.PoolingHttpClientConnectionManager and e.g. org.apache.http.impl.client.HttpClientBuilder. (jpinpoint-rules)</description>
    <priority>2</priority>
    <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
        <property name="version" value="2.0"/>
        <property name="xpath">
            <value><![CDATA[
//ImportDeclaration/Name[@Image='org.apache.commons.httpclient.SimpleHttpConnectionManager'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.http.impl.conn.PoolingClientConnectionManager'
or @Image='org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager'
or @Image='org.apache.http.impl.conn.SingleClientConnManager'
or @Image='org.apache.http.impl.client.DefaultHttpClient'
or @Image='org.apache.http.impl.client.SystemDefaultHttpClient'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.commons.httpclient.MultiThreadedHttpConnectionManager'
]
|
//ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.client.DefaultHttpClient')
or pmd-java:typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.commons.httpclient.MultiThreadedHttpConnectionManager')
]
|
//AllocationExpression[pmd-java:typeIs('org.apache.commons.httpclient.HttpClient')
]
		     ]]></value>
        </property>
    </properties>
        <example>
            <![CDATA[
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager; // bad
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;

public class Bad {
    private MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager(); // bad
}
class Good {
    private PoolingHttpClientConnectionManager mgr = new PoolingHttpClientConnectionManager();
}
            ]]>
        </example>
</rule>

    <rule name="JAXBContextCreatedForEachMethodCall" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="JAXBContext is created for each method call, which is expensive."  typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXBContext creation is expensive because it does much class loading.  &#13;
            Solution: Since JAXBContext objects are thread safe, they can be shared between requests and reused. So, reuse created instances, e.g. as singletons.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration[not (Annotation//Name[@Image='PostConstruct'])]
 /MethodDeclaration//Expression[pmd-java:typeIs('javax.xml.bind.JAXBContext')]
 /PrimaryExpression/PrimaryPrefix/Name[@Image = 'JAXBContext.newInstance']
                ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="ObjectMapperCreatedForEachMethodCall" message="An ObjectMapper or JsonMapper is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOJAR01">
        <description>Problem: Jackson ObjectMapper/JsonMapper creation is expensive because it does much class loading.  &#13;
            Solution: Since ObjectMapper/JsonMapper objects are thread-safe after configuration in one thread, they can be shared afterwards between requests and reused. So, reuse created instances, from a static field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.json.JsonMapper') and
         ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'build')]) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//VariableDeclarator[
    pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
]/VariableInitializer//PrimaryPrefix/Name[ends-with(@Image, 'build')]
			]]></value>
            </property>
         </properties>
        <example>
            <![CDATA[
public static ObjectMapper createMapper() {
    return new ObjectMapper(); // violation
}

public static JsonMapper createMapper() {
    return JsonMapper.builder().build(); // violation
}
            ]]>
        </example>
    </rule>

    <rule name="GsonCreatedForEachMethodCall" message="A Gson object is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOJAR03">
        <description>Problem: Gson creation is relatively expensive. A JMH benchmark shows a 24x improvement reusing one instance. &#13;
            Solution: Since Gson objects are thread-safe after creation, they can be between threads. So, reuse created instances, from a static field. Pay attention
            to use thread-safe (custom) adapters and serializers.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	pmd-java:typeIs('com.google.gson.Gson')
	and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
    pmd-java:typeIs('com.google.gson.GsonBuilder')
    and ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'create')]
    and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXMLGregorianCalendar" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XMLGregorianCalendar is used. It is slow in JAXB." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar05">
        <description>Problem: XMLGregorianCalendar is a large object, involving substantial processing. It is created with the poorly performing DatatypeFactory.
            Solution: Add a converter for alternative date handling with joda-time or Java 8 java.time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>

            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="HttpClientBuilderWithoutDisableConnectionState" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A HttpClient builder is used and disableConnectionState is not called. HTTP client tracks connection state while using TLS" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi07">
        <description>Problem: NTLM authenticated connections and SSL/TLS connections with client certificate authentication are stateful: they have a specific user identity/security context per session. If HttpClients have enabled connection state tracking which is the default, established TLS connections will not be reused because it is assumed that the user identity or security context may differ.
            Then performance will suffer due to a full TLS handshake for each request.&#13;
            Solution: HttpClients should disable connection state tracking in order to reuse TLS connections, since service calls for one pool have the same user identity/security context for all sessions. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(:locally created http client builder without disableConnectionState :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
(@Image="HttpClientBuilder.create" or @Image="HttpAsyncClientBuilder.create" or @Image="HttpClients.custom") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
,
(: method param http client builder without disableConnectionState :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
(@Image="HttpClientBuilder" or @Image="HttpAsyncClientBuilder" or @Image="HttpClients") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="HttpClientBuilderWithoutPoolSize" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used and the connection pool is not configured. HttpClient defaults of 2 per route and 20 max total are probably not right." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi03">
        <description>Problem: by default only 2 connections are available per route. When two external calls are being made, a third thread requesting a connection must wait for a free connection.&#13;
            Solution: HttpClients should explicitly define the number of connections per route. If only one route is used, make the max number of connections equal to conn per route.
            Either use 1. setConnectionManager and call setMaxTotal and setDefaultMaxPerRoute on that connection manager, or 2. no ConnectionManager: call setMaxConnTotal and setMaxConnPerRoute on the client directly. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
    and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
       and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration (: only when returning a connection manager :)
    [ResultType/Type[pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')]]
   //FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
,
(: new PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration//PrimaryExpression//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create() // bad, missing setMaxConnPerRoute/setMaxConnTotal or setConnectionManager
                .disableConnectionState()
                .build();

        return HttpClientBuilder.create() // good, both setMaxConnPerRoute and setMaxConnTotal called on client
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good, setConnectionManager called, pool config delegated
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderPoolSettingsIgnored" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used with a ConnectionManager and MaxConn settings on the client are ignored. Remove them." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi09">
        <description>Problem: If you use setConnectionManager, the connection pool must be configured on that Connection Manager. Pool settings on the client are ignored and lost. &#13;
            Solution: HttpClients should either 1. use setConnectionManager and *only* call setMaxTotal and setDefaultMaxPerRoute on that ConnectionManager or
            2. not use a ConnectionManager and call setMaxConnTotal and setMaxConnPerRoute on the client directly (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder with setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
,
(: method param http client builder setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClient')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')])
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create()
                .setConnectionManager(conMgr)
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL) // bad, ignored
                .build();

        return HttpClientBuilder.create() // good
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used and not all three timeouts are configured. The defaults are probably not optimal (e.g. infinite). " typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IBI10">
        <description>Problem: For connectionRequestTimeout, connectTimeout, socketTimeout (for HttpComponentsClientHttpRequestFactory) or readTimeout (for RequestConfig) the default timeout settings are not optimal in most cases. &#13;
            Solution: Set the timeouts explicitly to proper reasoned values. See best practice values via the link. Use the setDefaultRequestConfig with a method with a RequestConfig object on HttpClient builders to set the timeouts.(jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setDefaultRequestConfig to set timeouts :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
]
,
(: method param http client builder without setDefaultRequestConfig or by RequestConfigCallback to set timeouts :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
  and not(ancestor::ClassOrInterfaceBody//PrimarySuffix[@Image='setRequestConfigCallback']
    and ancestor::ClassOrInterfaceBody//MethodDeclaration[ResultType//ClassOrInterfaceType[@Image='RequestConfig.Builder']]
    /Block[count(.//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')]) = 3] )
]
,
(: RequestConfig creation without setConnectionRequestTimeout/setConnectTimeout/setSocketTimeout :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
   (pmd-java:typeIs('org.apache.http.client.config.RequestConfig') and @Image='RequestConfig.custom')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
]
,
(: HttpComponentsClientHttpRequestFactory without httpClient and without setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   (: not if setHttpClient called on it :)
   and not(ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        (: not if one argument provided (HttpClient) as ctor arg :)
        or ancestor::Expression//Arguments[@Size = 1])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
]
,
(: HttpComponentsClientHttpRequestFactory with local httpClient and with not all three of setConnectionRequestTimeout/setConnectTimeout/[setReadTimeout or setSocketTimeout] :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   and (ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        or ancestor::Expression//Arguments//PrimaryPrefix[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])>0
]
,
(: HttpComponentsClientHttpRequestFactory as param and with not all three of setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])>0
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        RequestConfig requestConfig = RequestConfig.custom()
            .setSocketTimeout(4000)
            .build(); // bad, not all timeouts set

        return HttpClientBuilder.create()
            .setDefaultRequestConfig(requestConfig) // good
            .build();
            ]]>
        </example>
    </rule>

    <rule name="DefaultFeignClientWithoutTLSConnectionReuse" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Default Feign client is used with (mutual) TLS. This is HttpURLConnection that creates a new connection for each call with TLS overhead." typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi21">
        <description>Problem: the default http client of Feign is java.net.HttpURLConnection that does not pool connections when using mutual TLS. This causes connection handshake overhead: extra CPU usage and higher latency.&#13;
            Solution: switch to a Feign client that supports HTTP connection pooling with mTLS, for instance Apache HttpClient 4 with disableConnectionState and proper connection pool size and timeouts. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: default client constructor with sslSocketFactory :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('feign.Client.Default')
and not(ancestor::Expression//Arguments[ArgumentList/@Size=2]//Expression[1]//NullLiteral)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import feign.Client;

public class MyFeignClient {

    public Client createClient(SSLSocketFactory sslSocketFactory){
        return new Client.Default(sslSocketFactory, null); // bad
    }

    public Client createClient(){
        return new Client.Default(null, null); // good
    }

    public Feign.Builder feignBuilder() {
        Client feignClient =
            new Client.Default(setupSSLContextForMutualTLS().getSocketFactory(), new DefaultHostnameVerifier()); // bad
        return Feign.builder().client(feignClient);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidJAXBUtil"
          language="java"
          message="The JAXB utility class is not optimized for performance."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXB utility methods do not reuse JAXBContext when more that one context is used. &#13;
            Solution: use JAXB API directly for marshalling and unmarshalling to gain all the performance benefits as described in IUOXAR04 and IUOXAR06.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('javax.xml.bind.JAXB')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class XMLConversion {
    public <T> T myUnmarshal(final Source response, final Class<T> clazz) {
        return JAXB.unmarshal(response, clazz); // bad
    }
    public void myMarshal(final Object response, StringWriter stringWriter) {
        JAXB.marshal(response, stringWriter); // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UseCloseableForHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="HttpClient is used instead of ClosableHttpClient. "
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi08">
        <description>Problem: if HttpClient connections are not closed properly when needed, resources are not released and connections may not (or not quick enough) become available from the pool.&#13;
            Solution: Use ClosableHttpClient to allow for invoking close on it to properly close the connection. Or use HttpComponentsClientHttpRequestFactory(httpClient) to let it manage closing. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: bad: HttpClient without HttpComponentsClientHttpRequestFactory :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')
   and not(ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')])]
,
(: bad: HttpClient with HttpComponentsClientHttpRequestFactory, yet if passed a param of constructor it is good :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')]
   [ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory') and
   not(../Arguments//Expression[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and not(ancestor::MethodDeclaration//Name[ends-with(@Image, '.setHttpClient')])]]
]]>
                </value>
            </property>
        </properties>
        <example>
        <![CDATA[
   void bad() {
        HttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }

    void good() {
        CloseableHttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }
    void good2() {
        HttpClient httpClient = HttpClientBuilder.create().disableConnectionState().build();
        ClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidModifyingObjectMapper" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="ObjectMapper is configured/modified, only initialize it right after construction."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuojar02">
        <description>Problem: ObjectMapper is thread-safe only after configuration. Configuring an ObjectMapper is not thread-safe.  &#13;
            Solution: Avoid configuring objectMappers except when initializing: right after construction. It is recommended to create ObjectReaders and ObjectWriters from ObjectMapper and pass those around since they are immutable and therefore thread-safe. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: exclude method annotated with PostConstruct :)
//ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='PostConstruct']) = 0]
(: exclude factory where config is in method returning 'this' and one method, typically build(), returning objectMapper :)
/MethodDeclaration[count(Block//ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix[@ThisModifier=true()])=0
or ancestor::ClassOrInterfaceBody[count(.//MethodDeclaration/ResultType/Type[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]) != 1]]
(: modify operations on objectMapper in a method where objectMapper is a formal parameter or field :)
//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::MethodDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration)[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
,
(: modify operations on objectMapper in a constructor where objectMapper is a formal parameter or static field :)
//ConstructorDeclaration//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::ConstructorDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration[@Static=true()])[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public class OldStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper();
        private final ObjectMapper mapperField = new ObjectMapper();

        static {
            staticObjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        public OldStyle() {
            mapperField.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        ObjectMapper bad(ObjectMapper mapper) {
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // bad
            return mapper;
        }
    }

    public class NewStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidDeprecatedHystrix" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Netflix Hystrix is deprecated. Use an alternative like resilience4j"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi11">
        <description>Problem: Hystrix is not actively maintained anymore.&#13;
            Solution: Netflix recommends to use open source alternatives like resilience4j. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[starts-with(@Image, "com.netflix.hystrix")]
]]>
                </value>
            </property>
        </properties>
        <example>
        </example>
    </rule>

    <rule name="AvoidRecreatingHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="An HttpClient is created and combined with request-response."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi12">
        <description>Problem: Apache HttpClient with its connection pool and timeouts should be setup once and then used for many requests. It is quite expensive to create and can only provide the benefits of pooling when reused in all requests for that connection.&#13;
            Solution: Create/build HttpClient with proper connection pooling and timeouts once, and then use it for requests. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration[count(.//Annotation//Name[@Image='Configuration']) = 0]
    //MethodDeclaration//VariableInitializer//Name[
    @Image='HttpClientBuilder.create' or @Image='HttpClients.custom' or @Image='HttpAsyncClientBuilder.create']
    [ancestor::MethodDeclaration//ClassOrInterfaceType[@Image='HttpEntity' or @Image='ResponseEntity']]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    ResponseEntity<Object> connectBad(Object req) {
        HttpEntity<Object> requestEntity = new HttpEntity<>(req);

        HttpClient httpClient = HttpClientBuilder.create().setMaxConnPerRoute(10).build(); // bad
        return remoteCall(httpClient, requestEntity);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="RetryCanCauseOverload" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Be careful with retrying: multiple retry locations in a call chain can cause overload."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi13">
        <description>Problem: Multiple Retry locations in a call chain multiply the number of calls. For 2x retry on 3 locations (service calls) in a chain calling a system which is just recovering,
            results in 3 x 3 x 3 = 27 calls instead of 1. This may cause it not being able to restart.&#13;
            Solution: Have the retry mechanism in one location in the chain only, recommended only the one closest to the user. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image='Retry']
,
//Annotation//Name[@Image='Retryable']
,
//FieldDeclaration//ClassOrInterfaceType[@Image='Retry']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.annotation.Retry;

@Retry(name = "some-service") // inform
public class Foo {
    public Response callSomeService() {
        //...and someService does a Retry for a call to the next service
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReactorDebugOverhead" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not use Reactor debugging in production, it has much overhead."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi14">
        <description>Problem: For troubleshooting Reactor, Blockhound can be used. It needs proper stack traces which can be achieved by Hooks.onOperatorDebug(). This can have much CPU overhead. &#13;
            Solution: Remove Hooks.onOperatorDebug() when not debugging. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('reactor.core.publisher.Hooks')]//Name[ends-with(@Image, 'Hooks.onOperatorDebug')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.Hooks;

public class Foo {
    public void bar() {
        Hooks.onOperatorDebug(); //bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDiscardingHttpClientConfig" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not replace the configured httpClient provided in the constructor of the factory."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi15">
        <description>Problem: Apache HttpComponentsClientHttpRequestFactory has a constructor which takes a HttpClient and also a setter: setHttpClient.
            If you use both on the same factory, you discard all configuration done on the one provided in the constructor because it is replaced by the one provided to the setter.  &#13;
            Solution: Don't use both on the same factory, provide the HttpClient only once to the factory. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Statement[StatementExpression[//ArgumentList]/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableDeclarator[.//AllocationExpression/ClassOrInterfaceType[@Image='HttpComponentsClientHttpRequestFactory'][..//ArgumentList]]
    /VariableDeclaratorId/concat(@Name, '.setHttpClient')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create()
                .setMaxConnTotal(config.getMaxTotalConnections())
                .setMaxConnPerRoute(config.getMaxConnPerRoute())
                .build());

        factory.setHttpClient(createHttpClient(config)); //bad
        return factory;
    }
}

class Good {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory =
            new HttpComponentsClientHttpRequestFactory(createFullyConfiguredHttpClient(config));
        return factory;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidHttpHostOneArgumentConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the HttpHost constructor with only hostname, provide port number and protocol as well."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi16">
        <description>Problem: the HttpHost constructor with one argument must only be provided with a host name, the default port 80 and protocol http are implied.
            The mistake of providing a URL and assuming it will be parsed into hostname, port and protocol is easily made.
            When this HttpHost is then used for a route and stored socketConfig for, port 80 is added for the host and the socketConfig is stored with the wrong key and will not be used.
            It is typically difficult to find out if the config is actually used. Note that http://github.com/jborgers/http-client-monitor helps here.&#13;
            Solution: Use the HttpHost constructor with 2 (including port) or preferably 3 arguments (including port and protocol). (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression[pmd-java:typeIs("org.apache.http.HttpHost")]/Arguments/ArgumentList[count(./Expression) = 1]/../..
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.HttpHost;

class Foo {
    private static final String URL = "localhost:8080";
    private static final HttpHost hostBad1 = new HttpHost("localhost:8080"); // bad

    void bar() {
        HttpHost hostBad2 = new HttpHost(URL);//bad
        HttpHost hostGood1 = new HttpHost("localhost", 8080, "http"); //good
    }
}
]]>
        </example>
    </rule>


    <rule name="AvoidClientHttpRequestFactorySupplier" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid use of ClientHttpRequestFactorySupplier."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi17">
        <description>Problem: The org.springframework.boot.web.client.ClientHttpRequestFactorySupplier may return a HttpComponentsClientHttpRequestFactory which you supply as @Bean, however,
            this can silently go wrong and e.g. an unconfigured SimpleClientHttpRequestFactory can be returned.
            Default pool size and timeouts will be used, possibly resulting in very slow connection use.&#13;
            Solution: Provide your own supplier with explicit pool sizing and timeouts by a class implementing Supplier. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[@Image='ClientHttpRequestFactorySupplier']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.boot.web.client')]]]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.boot.web.client.ClientHttpRequestFactorySupplier;
import org.springframework.web.client.RestTemplate;

class Bad {
    void bad() {
        RestTemplate restTemplate = new RestTemplateBuilder(rt -> rt.getInterceptors()
               .add((request, body, execution) -> {
                   request.getHeaders().add("SomeKey", someKey);
                   return execution.execute(request, body);
               }))
               .requestFactory(new ClientHttpRequestFactorySupplier()) // bad
               .uriTemplateHandler(defaultUriBuilderFactory)
               .build();
       return restTemplate;
    }
}

class MyClientHttpRequestFactorySupplier implements Supplier<ClientHttpRequestFactory> {

    public ClientHttpRequestFactory get() {
           PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();
           poolingHttpClientConnectionManager.setDefaultMaxPerRoute(MAX_CONN_PER_ROUTE);
           poolingHttpClientConnectionManager.setMaxTotal(MAX_CONN_TOTAL);

           CloseableHttpClient httpClient = HttpClients.custom()
                 .setConnectionManager(poolingHttpClientConnectionManager)
                 .disableConnectionState()
                 .build();
           return new HttpComponentsClientHttpRequestFactory(httpClient);
    }
}
and use it to replace the bad line in Bad example:
            .requestFactory(new MyClientHttpRequestFactorySupplier()) // good
]]>
        </example>
    </rule>

    <rule name="SetQueueCapacityForTaskExecutor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Configure the queue capacity for the ThreadPoolTaskExecutor."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia05">
        <description>The org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor queue capacity is not configured.
            Problem: It has a default queue capacity which is unlimited which can lead to an out of memory situation. &#13;
            Solution: Call setQueueCapacity, for instance with a value equal to CorePoolSize.
            Note that the pool will only grow beyond CorePoolSize up to MaxPoolSize when the queue is full. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//LocalVariableDeclaration//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
/ancestor::MethodDeclaration[.//Name[ends-with(@Image,'setCorePoolSize') or ends-with(@Image,'setMaxPoolSize')] and not(.//Name[ends-with(@Image,'.setQueueCapacity')])]
//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
   private ThreadPoolTaskExecutor bad() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // bad
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }

   private ThreadPoolTaskExecutor good() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setQueueCapacity(10); // good
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }
]]>
        </example>
    </rule>

    <rule name="BufferingClientHttpRequestFactoryIsMemoryGreedy" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="BufferingClientHttpRequestFactory is memory greedy. Only use when multiple reads of the response body cannot be avoided."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi18">
        <description>org.springframework.http.client.BufferingClientHttpRequestFactory is used.
            Problem: It buffers all incoming and outgoing streams fully in memory which may result in high memory usage. &#13;
            Solution: Avoid multiple reads of the response body so it is not needed. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: somehow typeIs does not work with spring-web-6.0, do it old school way :)
//AllocationExpression/ClassOrInterfaceType[@Image='BufferingClientHttpRequestFactory']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.http.client')]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.http.client.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    public RestTemplate createMemoryGreedyRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(new BufferingClientHttpRequestFactory(factory)); // bad
    }

    public RestTemplate createStreamTroughRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(factory); // good
    }
}
]]>
        </example>
    </rule>

    <rule name="HttpClientImproperConnectionTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="ApacheHttpClient RequestConfig connectionRequestTimeout and connectTimeout have values which are typically too high."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi20">
        <description>org.apache.http.client.config.RequestConfig is used with connectionRequestTimeout and connectTimeout values above 500 milli seconds.
            Problem: 1. connectTimeout is for establishing a connection which should be quick, say below 200 ms.
            2. connectionRequestTimeout is for requesting a connection from the connection manager, which should be almost as quick, say below 250 ms.
            If timeouts are long, requests will wait long for an unavailable service and cause high thread usage and possibly overload.  &#13;
            Solution: Set connectTimeout and connectionRequestTimeout to values based om tests, for instance 200 ms and 250 ms. respectively (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: use of field, local var and return statement :)
//FieldDeclaration[Type/PrimitiveType[@Image='int' or @Image='long']]//VariableDeclaratorId[@Name =
ancestor::ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type
[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory']/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Name/@Image]
/(../VariableInitializer//Literal[number(@Image) > 500]|
  ancestor::ClassOrInterfaceBodyDeclaration//SingleMemberAnnotation[Name/@Image='Value']//Literal[number(substring-before(substring-after(@Image, ':'), '}')) > 500])
,
(: use of literal, local var and return statement : :)
//ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory'
]/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Literal[number(@Image) > 500]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.client.config.RequestConfig;

public class HttpClientStuff {
    private static final int CONNECTION_TIMEOUTMILLIS = 1000; // bad // timeout until a connection is established
    private static final int CONNECTIONREQUEST_TIMEOUTMILLIS = 5000; // bad // timeout when requesting a connection from the connection manager
    private static final int SOCKET_TIMEOUTMILLIS = 5000; // timeout of waiting for data

    public RequestConfig requestConfigWithTimeouts() {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectionRequestTimeout(CONNECTIONREQUEST_TIMEOUTMILLIS)
                .setConnectTimeout(CONNECTION_TIMEOUTMILLIS)
                .setSocketTimeout(SOCKET_TIMEOUTMILLIS)
                .build();
        return requestConfig;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidObjectMapperAsField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ObjectMapper as field, use ObjectReader or ObjectWriter instead."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#iuojar02">
        <description>Problem: Configuring an ObjectMapper is thread-unsafe.  &#13;
            Solution: Create ObjectReaders and ObjectWriters from ObjectMapper and only share those as field, since they are immutable and therefore thread-safe.
            Exceptions: A convertValue method is not provided by ObjectReader nor ObjectWriter, therefore in those cases this rule is not applied.
            Also when used like jaxMsgConverter.setObjectMapper(objectMapper) it is not considered a violation. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(for $node in (//FieldDeclaration[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
(: if class not in classpath, can use following line :)
(:or (Type//ClassOrInterfaceType[@Image='ObjectMapper'] and //ImportDeclaration/Name[starts-with(@Image, 'com.fasterxml.jackson.databind.')]):)
]//VariableDeclaratorId)
(: exception: do not match if that field name is used in its class with a convertValue method :)
return ($node[not(ancestor::ClassOrInterfaceDeclaration//PrimaryPrefix/Name[@Image = concat($node/@Name, '.convertValue')])
(: exception: do not match if used with jaxMsgConverter.setObjectMapper(objectMapper) :)
and not($node/@Name = ancestor::ClassOrInterfaceDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, 'setObjectMapper')]]
(:[pmd-java:typeIs('org.springframework.http.converter.json.MappingJackson2HttpMessageConverter')] - somehow class resolution fails :)
/PrimarySuffix//PrimaryPrefix/Name/@Image)
]))
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public class BadStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper(); // bad
        private final ObjectMapper mapperField = new ObjectMapper(); //bad
    }

    class GoodStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AxualProducerCreatedForEachMethodCall"
          message="An Axual (Kafka) producer is created for each method call, which is expensive and takes resources."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia10">
        <description>Problem: each Producer takes threads and memory. If you create it in each method call, and call this frequently, it will result in an explosion of threads and memory used and lead to Out Of Memory Error.  &#13;
            Solution: Since the Axual Producer is thread-safe, it should be shared e.g. from a static field.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//VariableDeclarator[pmd-java:typeIs('io.axual.client.producer.Producer')]
[ancestor::TypeDeclaration[count(./Annotation//Name[@Image='Configuration'])=0]]
			]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.axual.client.producer.Producer;

public class AxualProducerBad {
    public void publishToEventStream() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig); // bad
        producer.produce(msg);
    }
}

class AxualProducerGood1{
    private static final Producer<String, String> producer = AxualClient.buildProducer(producerConfig);
}

@Configuration
class AxualProducerGood2{
    public Producer<String, String> axualProducer() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig);
        return producer;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLeakingRetryEventConsumers"
          message="Avoid leaking of retry event consumers."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#pml06">
        <description>Problem: A resilience4j retry event consumer is added to a retry event publisher for every method call. Likely a lambda retaining one or more objects.
            This will result in a growing list of consumers: a memory leak. Besides, the event will be sent to the growing number of consumers, taking more and more CPU time.&#13;
            Solution: Only call EventPublisher.onRetry (that is, add a consumer) in the same scope as the Retry instance lives. Note there is no way to unregister a consumer.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[pmd-java:typeIs('io.github.resilience4j.retry.Retry') and ends-with(@Image, '.getEventPublisher')]
(: any on-method: onRetry, onError, .. :)
[../../PrimarySuffix[starts-with(@Image, 'on')]]
(: it is a field :)
[exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('io.github.resilience4j.retry.Retry')]
/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.Retry;

public class Foo {
    Retry retryField;
    RetryRegistry reg;
    final AtomicInteger retryCountField = new AtomicInteger();

    Foo() {
        retryField = reg.retry("one per service");
        retryField.getEventPublisher().onRetry(event -> retryCountField.getAndIncrement()); // good
    }

    void callService() {
        AtomicInteger retryCountLocal = new AtomicInteger();
        retryField.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // bad, lambda and AtomicInt leak

        Retry retryLocal = reg.retry("one per method call");
        retryLocal.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // good, no leak

        // same for onSuccess, onError, onIgnoredError
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidHardcodedConnectionConfig"
          message="Avoid hardcoded connection configuration."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi22">
        <description>Problem: configuring connection settings like timeouts and pool sizes in code (int values) makes it difficult to manage and tune these settings.&#13;
            Solution: use property files, e.g. yml, to define the values for these settings for each called service.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[Type/@TypeImage='int']/VariableDeclarator[VariableDeclaratorId[@Final = true()][contains(upper-case(@Name), 'TIMEOUT') or contains(upper-case(@Name), 'DURATIONOUT')
or(contains(upper-case(@Name), 'MAX') and contains(upper-case(@Name), 'ROUTE'))]]
[VariableInitializer//Literal or VariableDeclaratorId/@Image=ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression[Expression//Literal]//Name/@Image]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class AvoidHardcodedConnectionConfig {
    private static final int CONNECTION_TIMEOUT = 50000;// bad
    private static final int SOCKET_TIMEOUT = 250000;// bad
    private static final int TRANSACTION_TIMEOUT_SECONDS = 2;// bad
    private static final int CONNECTION_TIMEOUTMILLIS = 1000;// bad

    private static final int MAX_CONN_PER_ROUTE = 10;// bad
    static final int MAX_PER_ROUTE = 100;// bad
    final int MAX_NUM_ROUTES = 2; // bad
    int some_timeout_ms = 300; //good, variable
    private static final String LOGIN_TIMEOUT_PROPERTY_KEY = "loginTimeout"; // good, not an int
    final int other_timeout_s_blank; // bad, blank final and hard coded
    private final int connectTimeoutMillis; // good, not hard coded

    AvoidHardcodedConnectionConfig(@Value("${connect_timeout:1000}") int connectTimeoutMillis) {
        this.connectTimeoutMillis = connectTimeoutMillis; // good, not hard coded
        other_timeout_s_blank = 5; // field bad
        final int timeout_s_local = 4; // good, method level
        int otherTimeoutInS = 3; // good, var
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSaajSoapMessaging"
          message="Avoid SAAJ SOAP messaging, use Axiom instead."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ibi23">
        <description>Problem: SAAJ uses DOM to load the XML document in memory which uses a TransformerFactory. The implementation class of it is loaded on every call which causes lock contention under load. This means long response times.&#13;
            Solution: Use Axiom SOAP messaging which uses the faster StAX. If you want to stick to SAAJ, add the proper JVM parameter to prevent the class loading.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.ws.soap.saaj') or starts-with(@Image, 'com.sun.xml.messaging.saaj.soap')]
|
//Type//ClassOrInterfaceType[@Image='SaajSoapMessageFactory']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.ws.soap.saaj.SaajSoapMessage; // bad
import org.springframework.ws.soap.saaj.SaajSoapMessageFactory; // bad
import com.sun.xml.messaging.saaj.soap.*; // bad

class Foo {
    private final SaajSoapMessageFactory mfField; // bad
}
            ]]>
        </example>
    </rule>

</ruleset>
