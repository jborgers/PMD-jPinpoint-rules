<ruleset name="jpinpoint-common_std-rules"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidApacheCommonsFileItemNonStreaming"
          language="java"
          message="Avoid memory intensive FileItem.get and FileItem.getString"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isio03">
        <description>
            Problem: Use of FileItem.get and FileItem.getString could exhaust memory since they load the entire file into memory&#13;
            Solution: Use streaming methods and buffering.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodCall[@MethodName="get" or @MethodName="getString"][VariableAccess[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]]
    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public class FileStuff {
       private String bad(FileItem fileItem) {
            return fileItem.getString();
       }

       private InputStream good(FileItem fileItem) {
            return fileItem.getInputStream();
       }
    }
                ]]>
        </example>
    </rule>

    <rule name="AvoidConcatInLoop"
          language="java"
          message="A String is concatenated in a loop. Use StringBuilder.append."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#isu02">
        <description>A String is built in a loop by concatenation. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected. &#13;
            Solution: Use the StringBuilder append method.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(//ForeachStatement | //WhileStatement | //DoStatement)//AssignmentExpression[
    (: a += ...;  - a being a string OR a = ... + a + ...; - a being a string :)
    @Operator = '+=' or @Operator = '=']/VariableAccess[pmd-java:typeIs('java.lang.String')]
/.. (: Go up to report on the StatementExpression :)
	]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class StringStuff {
   private String bad(String arg) {
        String log = "";
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            log += val;
        }
        return log;
    }

   private String good(String arg) {
        StringBuilder sb = new StringBuilder();
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            sb.append(val);
        }
        return sb.toString();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="LetFieldsMeetSerializable"
          language="java"
          message="Fields in a Serializable class should be serializable or transient."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#isr02">
        <description>Problem: Field in a Serializable class is not serializable nor transient. When (de)serialization happens, a RuntimeException will be thrown and (de)serialization fails.
            Solution: make the field either transient, make its class implement Serializable or interface extend Serializable.
            Note: Classes extending Throwable do, by inheritance, implement Serializable, yet are excluded in this rule, since they are typically never actually serialized.
            An exception to this exception is when extending RemoteException, then fields should be transient or serializable.
        </description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,pitfall,replaces-sonar-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[ImplementsList/ClassType[@SimpleName='Serializable']
or pmd-java:typeIs('java.io.Serializable')
(: Throwable is the exception, except RemoteException :)
and not(pmd-java:typeIs('java.lang.Throwable') and not(pmd-java:typeIs('java.rmi.RemoteException')))]
(: non-transient, non-static, non-primitive fields :)
//FieldDeclaration[not(pmd-java:modifiers() = 'transient') and not(pmd-java:modifiers() = 'static')]
[not(.//PrimitiveType)]
[ClassType[not(pmd-java:typeIs('java.io.Serializable'))]]
(: and can be resolved :)
[ClassType[pmd-java:typeIs('java.lang.Object')]]
(: if has type args, type args which are not serializable like List<String, Thread>):)
[not(exists(.//TypeArguments))
    or exists(.//TypeArguments/ClassType[not(pmd-java:typeIs('java.io.Serializable'))
                                         (: and can be resolved :)
                                         and pmd-java:typeIs('java.lang.Object')]
    )
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo implements Serializable {
    String meets;
    Exception exMeets;
    Serializable ser;
    Thread t1NotMeets; // bad, Thread is not serializable
    transient Thread t2meets;
    List<String> listOfStrings = new ArrayList();
    List<Thread> listOfThreads = new ArrayList(); // bad
    Map<String,String> mapToString = new HashMap();
    Map<String,Thread> mapToThread = new HashMap(); //bad
}

class Bar extends Exception {
    Thread t1NotMeets;
    transient Thread t2meets;
}

class Baz extends RemoteException {
    Thread t1NotMeets; // bad
    transient Thread t2meets;
}
            ]]>
        </example>
    </rule>

</ruleset>