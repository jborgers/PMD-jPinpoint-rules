<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-concurrent-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
  //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.take')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.')))
]    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get')]
    (: future.get or variant called on formal param :)
    [(exists(index-of((ancestor::MethodDeclaration//FormalParameter[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on local var :)
    exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on field :)
    exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    )
    (: .get without arguments :)
    and not(../../PrimarySuffix/Arguments/ArgumentList)
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public static String bad(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(); // bad
    }

    public static String good(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(10, TimeUnit.SECONDS); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and @GuardedBy or use volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: static field, non-final, non-volatile, non-guarded by :)
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[@Static=true() and @Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]
,
(: static field, non-guarded, some often used known mutable types, declaration side :)
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true()]/Type/ReferenceType/ClassOrInterfaceType[
(((pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL')) or pmd-java:typeIs('java.io.File'))
 or (ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0]))
 and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='GuardedBy'])
])
,
(: static field, non-guarded, some often used known collection/array types, allocation side:)
(//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true() and not (../Annotation//Name[@Image='GuardedBy'])]/
VariableDeclarator/VariableInitializer[((ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0)
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[ArrayDimsAndInits and xs:int(ArrayDimsAndInits and (xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0 or ArrayDimsAndInits/Expression//Name))]
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[(pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet'))]
or Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='Arrays.asList']
)])
,
(: static-block allocations of non-empty arrays :)
//Initializer//AllocationExpression[((ArrayDimsAndInits and ((xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0) or exists(ArrayDimsAndInits/Expression//Name) or exists(ArrayDimsAndInits/ArrayInitializer//Expression)))
or
(: static-block allocations of known mutable types :)
ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet') or pmd-java:typeIs('java.util.EnumMap')])
and
(: given the field is not @GuardedBy :)
ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='GuardedBy']) = 0]/FieldDeclaration//VariableDeclaratorId/@Name
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    enum Bad {
        VAL1;
        static final Map<String, Bad> STRING_TO_ENUM = new HashMap<>(); // bad
    }
    enum Good {
        VAL1;
        static final Map<String, Good> STRING_TO_ENUM; // good
        static {
            Map<String, Good> map = new HashMap<>();
            STRING_TO_ENUM = Collections.unmodifiableMap(map);
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[pmd-java:typeIs('javax.xml.bind.Marshaller')
 or pmd-java:typeIs('javax.xml.bind.Unmarshaller')
 or pmd-java:typeIs('javax.xml.bind.Validator')
 or pmd-java:typeIs('javax.xml.validation.Validator')]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            4. Use synchronized for accessors to inherited fields, or better: make field private and use proper accessors on base class level using @GuardedBy.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: assignment to a field :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[(@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
or
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), @Image))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), @Image))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()])
or ancestor::MethodDeclaration[@Name='afterPropertiesSet']
)]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidNonPrivateFieldsInSharedObjects"
          message="Avoid non-private objects shared among threads. Make fields private to ensure thread-safety."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc11">
        <description>
            Problem: A singleton, or more general: an object shared among threads, has a field that is not private.
            These field can possibly be modified from other classes.&#13;
            Solution: Make the fields private.
            Note: fields are excluded when annotated with: @Autowired/@Value/@Inject.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[
    (
      @Image='Component'
      or @Image='Service'
      or @Image='Controller'
      or @Image='RestController'
      or @Image='Repository'
      or (@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN'])
    )
    (: not shared when request or prototype scope :)
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
    (: if @NotThreadSafe no checking :)
    and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
]
(: non-static, non-final and non-private fields :)
/../../../ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Private=false() and @Final=false()
(: field not injection framework annotated :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='Value' or @Image='Inject'])]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInSharedObjects"
          message="Avoid unguarded non-final or mutable fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
(: not shared when request or prototype scope :)
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
    or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: ConfigurationProperties assumed executed only once, no violation, except if Lombok Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: non-final and non-volatile fields :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment level annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: not annotated GuardedBy :)
)
and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableInheritedFieldsInSharedObjects"
          message="Mutator method called on inherited field. Avoid unguarded mutable inherited fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a (inherited) field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: primary expression used :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//../PrimaryExpression//PrimaryPrefix/Name[(
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(:  has arguments (a method call), and  a compound like date.setTime, map.put, list.set :)
(contains(@Image, '.set') or contains(@Image, '.put') or contains(@Image, '.clear') or contains(@Image, '.add') or contains(@Image, '.remove') or contains(@Image, '.replace')) and
(: not starting with a capital, a Class :)
not (starts-with(@Image, upper-case(substring(@Image, 1, 1)))) and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: expression not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not used in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded assignments to non-final fields in objects using synchronized. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. In case you are sure the class is used in single threaded context only, remove current use of synchronized and annotate the class with @NotThreadSafe to make this explicit. &#13;
            2. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: assignment to a field :)
/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded non-final or mutable fields in objects using synchronized. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the class is used in single threaded context only, annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: non-final and non-volatile fields :)
/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: mutable types not annotated with GuardedBy :)
) and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="NotProperlySynchronizingOnThisWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy('this')"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which this annotation is applied should only be accessed when holding the built-in 'this' lock by using synchronized.&#13;
            Solution: Make access thread-safe: synchronize access by method modifier or a synchronized(this) block.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[(@Synchronized=false() or @Static=true())
and not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
//PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
(ancestor::ClassOrInterfaceBody|ancestor::EnumBody)//Annotation//Name[@Image='GuardedBy']/..//Literal[@Image='"this"']/
ancestor::ClassOrInterfaceBodyDeclaration/FieldDeclaration//VariableDeclaratorId/@Name
and (
not (ancestor::SynchronizedStatement)
or ancestor::SynchronizedStatement/Expression//Name)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        @GuardedBy("this")
        private String txt;

        public String getText() { return txt; } // bad
        public void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        @GuardedBy("this")
        private String txt;

        public synchronized String getText() { return txt; }
        public synchronized void setText(String t) { txt = t; }
    }
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnFieldWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy(field)"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which the GuardedBy annotation is applied is not accessed thread-safely as described by GuardedBy.&#13;
            Solution: Make access thread-safe: synchronize access by a synchronized(LOCK) block with LOCK being a final field.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded-by literal *IS* a field (should be private final) :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[substring(@Image, 2, (string-length(@Image) - 2))=
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS NOT* in a synchronized block with the GuardedBy literal:)
    and (not(concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
    ,
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded by literal *IS NOT* a field :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[not (substring(@Image, 2, (string-length(@Image) - 2)) =
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name)
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS* in a synchronized block with the GuardedBy literal:)
    and (
    (concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() { return txt; } // bad
        public synchronized void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() {
            synchronized(LOCK) { return txt; }
        }
        public void setText(String t) {
            synchronized(LOCK) { txt = t; }
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidStaticXmlFactories" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid static XML Factories" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOXAR09">
        <description>An XML Factory like DocumentBuilderFactory, TransformerFactory, MessageFactory is used as static field. Problem: These factory objects are typically not thread-safe and rather expensive to create because of class loading. &#13;
            Solution: Create the Factories as local variables and use command line arguments to specify the implementation class. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBodyDeclaration//FieldDeclaration[@Static=true() and (
    pmd-java:typeIs('javax.xml.parsers.DocumentBuilderFactory') or
    pmd-java:typeIs('javax.xml.parsers.SAXParserFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLInputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLOutputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLEventFactory') or
    pmd-java:typeIs('javax.xml.transform.TransformerFactory') or
    pmd-java:typeIs('javax.xml.validation.SchemaFactory') or
    pmd-java:typeIs('javax.xml.datatype.DatatypeFactory') or
    pmd-java:typeIs('javax.xml.soap.MessageFactory')
    )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Bad {
    private static final DocumentBuilderFactory DB_FACTORY = DocumentBuilderFactory.newInstance(); // shared, bad
 }

 public class Good {
    public build() {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); // local var, good
        // use dbFactory
    }
 }
            ]]>
        </example>
    </rule>

    <rule name="AvoidIncrementOrDecrementForVolatileField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ++, --, +=, -= for volatile fields" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc09">
        <description>A compound statement like i++, i--, i += 1 or i -= 1 may seem one statement and thread-safe for a volatile field. Problem: The operation is actually two separate statements executed non-atomically and therefore not thread-safe. &#13;
            Solution: Guard the field properly with synchronized or use atomics like AtomicInteger. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/(AssignmentOperator[@Image='+=' or @Image='-=']/..|
(PreIncrementExpression|PostfixExpression[@Image='++' or @Image='--']))/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[@Image =
//FieldDeclaration[@Volatile = true()]/VariableDeclarator/VariableDeclaratorId/@Name]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Foo {
    private volatile int i;
    private volatile String str = "";

    public int bad() {
        i++; // bad
        --i; // bad
        i += 1; // bad
        str += "a"; // bad
    }
    public int good(int v) {
        i = 5; // good
        i = v + 5; // good
        str = "other"; // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidVolatileInPrototypeScope" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="No need for volatile in prototype scope" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc10">
        <description>A field is defined as volatile while the class has prototype scope. Problem: volatile has some overhead, especially for writes. When getting the bean from the Spring applicationContext, prototype scope means that each invocation creates a new object so the field is not shared. &#13;
            Solution: Since only one thread can access the field, there is no need for violatile and it can be removed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //FieldDeclaration[@Volatile = true() and
    ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix/
    (Name[ends-with(@Image,'SCOPE_PROTOTYPE')]|Literal[contains(@Image, 'prototype')])]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Bad {
    private volatile String id;
}

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Good {
    private String id;
}
            ]]>
        </example>
    </rule>

    <!-- for pmd-7
    //FieldDeclaration[index-of(pmd-java:explicitModifiers(), 'volatile') > 0 and
    ancestor::ClassOrInterfaceDeclaration//Annotation[@SimpleName='Scope']//MemberValuePair[
    FieldAccess[ends-with(@Name,'SCOPE_PROTOTYPE')] | StringLiteral[contains(@Image, 'prototype')]]]
    -->


    <rule name="SynchronizingForLocalVars" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Local variables don't need synchronization" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc12">
        <description>In the synchronized block, only local variables seem to be accessed. Problem: synchronization has overhead and may introduce lock contention. &#13;
            Solution: Remove synchronized because local variables are only accessible by the owning thread and are not shared. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: var.x() in synchronized block, var in list of local vars and all var.x in synchronized block are local vars:)
//SynchronizedStatement[count(./Block//PrimaryPrefix/Name[
    index-of(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name, substring-before(@Image, '.')) >= 0]) =
count(./Block//(PrimaryPrefix/Name|PrimarySuffix)[substring-before(@Image, '.')])
and
(: vars used in synchronized block are all local vars :)
count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name |
     ./Block//(PrimaryPrefix/Name|PrimarySuffix)[@Image != '' and not(contains(@Image, '.'))]/@Image))
 = count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name ))]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private Map<String, String> mapField;

    protected Map<String, String> bad() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) { // bad
          if (addHeaders == null) {
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }

  protected Map<String, String> good() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) {
          if (mapField == null) {
              mapField = new HashMap<>();
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidFutureJoinWithoutTimeout"
          message="Avoid future.join without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia07">
        <description>
            Problem: Stalls indefinitely in case of hanging thread(s) and consumes a thread.&#13;
            Solution: Provide a timeout before the join and handle the timeout. For example a future.get(timeout, unit), a orTimeout() or a completeOnTimeout(). You may want to use CompletableFuture.allOf() too.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: future.join method reference without timeout in method :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')
and not(ancestor::MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')][../../PrimarySuffix//ArgumentList])
]
/../PrimarySuffix//MethodReference[@Image='join']
,
(: future.join in lambda without timeout in method :)
//PrimaryExpression/PrimaryPrefix/LambdaExpression//Name[ends-with(@Image, '.join')
and not(ancestor::MethodDeclaration//PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')]
[../../PrimarySuffix//ArgumentList])
]
(: join has no arguments, #198 :)
[../../PrimarySuffix/Arguments[@Size=0]]
,
(: CompletableFuture.allOf(futures).join() without timeout :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/../PrimarySuffix[@Image='join'
and not(ancestor::MethodDeclaration//PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')])]
(: join has no arguments, #198 :)
[../PrimarySuffix/Arguments[@Size=0]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    private List<Order> getOrdersBad(List<CompletableFuture<Order>> getOrdersFutures) {

        List<Order> orders = getOrdersFutures.stream()
            .map(CompletableFuture::join) // bad, NO timeout provided above
            .collect(Collectors.toList());
        return orders;
    }

    private List<Order> getOrdersGood(List<CompletableFuture<Order>> getOrdersFutures) {
        // added to deal with timeout
        CompletableFuture<Void> allFuturesResult = CompletableFuture.allOf(getOrdersFutures.toArray(new CompletableFuture[getOrdersFutures.size()]));
        try {
            allFuturesResult.get(5L, TimeUnit.SECONDS); // good
        } catch (Exception e) { // should make explicit Exceptions
            //log error
        }
        List<Order> orders = getOrdersFutures.stream()
                .filter(future -> future.isDone() && !future.isCompletedExceptionally()) // keep only the ones completed -- added to deal with timeout
                .map(CompletableFuture::join) // good, timeout provided above
                .collect(Collectors.toList());
        return orders;
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidCommonPoolForFutureAsync"
          message="Avoid using the common thread pool for future.supplyAsync, use a separate pool."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia08">
        <description>
            Problem: Future.supplyAsync is typically used for remote calls. By default, it uses the common pool.
            The number of threads in the common pool is equal to the number of CPU's, which is suitable for in-memory processing.
            For I/O, however, this number is typically not suitable because most time is spent waiting for the response and not in CPU.
            The common pool must not be used for blocking calls. &#13;
            Solution: A separate, properly sized, pool of threads (an Executor) should be used for the async calls.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name[@Image='CompletableFuture.supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
,
//PrimaryPrefix/Name[@Image='supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
[/CompilationUnit/ImportDeclaration/Name[@Image = 'java.util.concurrent.CompletableFuture.supplyAsync']]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private final ExecutorService asyncPool = Executors.newFixedThreadPool(8);

    void bad() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account))) // bad
         .toArray(CompletableFuture[]::new);
    }

    void good() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account), asyncPool)) // good
         .toArray(CompletableFuture[]::new);
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCommonPoolForBlockingCalls" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the ForkJoinPool::commonPool used in parallelStream for blocking calls."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia09">
        <description>Problem: Blocking calls for instance remote calls, may exhaust the common pool for some time thereby blocking all other use of the common pool.
            In addition, nested use of the common pool can lead to deadlock. Do not use the common pool for blocking calls. The parallelStream() call uses the common pool.&#13;
            Solution: Use a dedicated thread pool with enough threads to get proper parallelism. The number of threads in the common pool is equal to the number of CPUs - 1 and meant to utilize all of them.
            It assumes CPU intensive non-blocking processing of in-memory data.  (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: assumption: if import of web client / http client is present, parallelStreaming is for remote calls :)
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.web.client') or starts-with(@Image, 'org.apache.commons.httpclient')]/
ancestor::CompilationUnit//PrimaryExpression
[(PrimarySuffix/@Image='parallelStream' or ends-with(PrimaryPrefix/Name/@Image, 'parallelStream')
and exists(PrimarySuffix/pmd-java:typeIs('java.util.stream.Stream'))
and not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')]))
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.concurrent.*;
import java.util.stream.*;
import java.util.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    final List<String> list = new ArrayList();
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> storeDataRemoteCall(elem));
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> storeDataRemoteCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(10, TimeUnit.MILLISECONDS));
    }

    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> storeDataRemoteCall(elem))
        ).get();
    }

    String storeDataRemoteCall(String elem) {
        // do remote call, blocking. We don't use the returned value.
        RestTemplate tmpl;
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidUserDataInSharedObjects" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do *not* use user data in shared objects, it causes user data mix-up."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodeQuality.md#ssc03">
        <description>The name of the field indicates user data. Problem: the field will be shared among users. If it is different data for each user, it can mix-up: a user may access data of another user, this is really bad.&#13;
            Solution: Do *not* put the user related data in a shared object e.g. by Spring @Component annotation. Use a POJO. Or, if it is not user data, rename the field. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/ancestor::TypeDeclaration//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Static=false()][Type/ReferenceType][ancestor::ClassOrInterfaceDeclaration[1][@Static=false()]]/VariableDeclarator/VariableDeclaratorId[matches(@Name,
'User[Id|Ref|Reference]*$|Customer[Id|Ref|Reference]*$|Session[Id|Ref|Reference]*$|Order[Id|Ref|Reference|List]*$|Account[Id|Ref|Reference|List]*$|Transaction[Id|Ref|Reference|List]*$|Contract[Id|Ref|Reference|List]*$', 'i')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Component
@Data
public class VMRData {
    private String channel;
    private String vmrId;
    private List<OrderDetails> orderList; // bad
    private Headers headers;
    private List<OrderReference> ordersRequiringAdditionalSignature;
    private String authUser; // bad
    private String executionDate;
    private String minimumLevel;
    private String sessionId; // bad
    private String payloadData;
    private String vmrUserId; // bad
    private String userref; // bad
    private String customerReference; // bad
    private String contract; // bad
}

@Component
@Setter
@Getter
 class VMROrderDetails {
    private static final String DESC_OF_ORDER = "order details"; // ok
    private final VMROrderDetails finalOrder = new VMROrderDetails(); // ok
    private OrderReference orderReference; // bad
    private Account originatorAccount; // bad
    private Amount amount;
    private String action;
    private List<CancellationHistory> cancellationHistories;
    private String modifyType;
    private String order; // bad
    private String transactionRef; // bad
}

]]>
        </example>
    </rule>

    <rule name="AvoidParallelStreamWithCommonPool" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Beware: parallelStream with the common pool is rarely a good choice."
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia11">
        <description>Problem: Collection.parallelStream uses the common pool, with #threads = #CPUs - 1. It is designed to distribute much CPU work over the cores. It is not for remote calls or other blocking calls.
            In addition, parallelizing has overhead and risks, should only be used for much pure CPU processing.&#13;
            Solution: For remote/blocking calls: Use a dedicated thread pool with enough threads to get proper parallelism independent of the number of cores.
            For pure CPU processing: use ordinary sequential streaming unless the work takes more than about 0,1 ms in sequential form and proves to be faster with parallelization.
            So only for large collections and much processing without having to wait.   (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/(PrimarySuffix[@Image='parallelStream' or @Image='parallel']|PrimaryPrefix/Name[ends-with(@Image, '.parallelStream') or ends-with(@Image, '.parallel')])
(: and exists(PrimarySuffix[pmd-java:typeIs('java.util.stream.Stream')]) - with 'var' type is lost in typeIs :)
(: no arguments :)
[following::PrimarySuffix[1][@ArgumentCount = 0]]
[not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')])]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class Foo {
    final Map<String, String> map = new HashMap();
    final List<String> list = new ArrayList();
    final List<String> hugeList = new ArrayList(); //1000+ elements
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> someCall(elem)); //bad
    }
    void bad2() {
        map.entrySet().parallelStream().forEach(entry -> someCall(entry.getValue())); //bad
    }
    void exceptionalProperUse() {
       hugeList.parallelStream().forEach(elem -> heavyCalculations(elem)); //flagged but may be good, should suppress when proven to be faster than sequential form
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> someCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(3, TimeUnit.SECONDS);
    }
    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> someCall(elem))
        ).get();
    }

    String someCall(String elem) {
        // do some call, don't know if remote or blocking. We don't use the returned value.
        return "";
    }

    String heavyCalculations(String elem) {
        // calculate a lot
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidParallelFlux"
          message="Avoid dividing the data and parallel processing because this is typically slower."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia12">
        <description>Problem: With Reactor Flux.parallel.runOn, the data is divided on a number of 'rails' matching the number of CPU cores.
            This is only useful in case much CPU processing is performed: if the sequential form takes more than 0,1 ms of CPU time.
            With remote calls this is usually not the case. In addition, it introduces more complexity with risk of failures.&#13;
            Solution: Remove parallel().runOn. Unless the CPU work takes more than 0,1 ms in sequential form and proves to be faster with parallelization.
            So only for large collections and much CPU processing.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimarySuffix[@Image='parallel' and ../PrimaryPrefix/Name[@Image = 'Flux.fromIterable']
and //ImportDeclaration/Name[starts-with(@Image, 'reactor.core.publisher')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;

class FooBad {
    public Flux<Account> getResponseAccounts(List<AccountKey> accountKeys, List<FieldName> requestedFields) {
        return Flux.fromIterable(accountKeys)
                .parallel(schedulerProperties.getParallelism()) //bad
                .runOn(scheduler)
                .flatMap(accountKey -> constructAccountDetails(accountKey, requestedFields))
                .sequential();
    }
}

class FooGood {
    public Flux<Account> getResponseAccounts(List<AccountKey> accountKeys, List<FieldName> requestedFields) {
        return Flux.fromIterable(accountKeys)
                .flatMap(accountKey -> constructAccountDetails(accountKey, requestedFields));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMDCInReactor"
          message="Avoid using MDC with Reactor."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia13">
        <description>Problem: Mapped Diagnostic Context (MDC) of logging frameworks uses ThreadLocals to store things like traceIds from headers, userId, correlationId.
            Reactive programming uses multiple threads to handle a request, and one thread can deal with asynchronous steps of many requests.
            Therefore, MDC is tricky to use in reactive context and may take much processing time to propagate, likely so for much data in the MDC.&#13;
            Solution: Propagate by use of deferContextual and use directly from the Context only when and where needed. Avoid MDC propagation mechanisms.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.setContextMap' and
(ancestor::MethodDeclaration/ResultType/Type[@TypeImage='Flux' or TypeImage='Mono']
or ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter[pmd-java:typeIs('reactor.util.context.Context')])]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;
import reactor.util.context.Context;
import org.slf4j.MDC;
import net.logstash.logback.argument.StructuredArguments;

class FooBad {
  public Flux<ServerResponse> doIt(Map<String,String> contextMap) {
      return Flux.fromIterable(service.doWork())
          .doOnNext(s -> MDC.setContextMap(contextMap))
          .doOnNext(
              response -> {
                  log.info("your log"); // includes trace ids from MDC, put in a ServletFilter, specified by log configuration
          });
      }
}

class FooGood {
    public Flux<ServerResponse> doIt() {
        // using deferContextual gives access to the read-only ContextView created in the ContextFilter
        return Flux.deferContextual(contextView -> service.doWork()
            .doOnNext(response -> {
                log.info("your log", StructuredArguments.entries((Map)contextView));
            }));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReactorOnEachOperator"
          message="Avoid using Reactor Hooks.onEachOperator."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#ia14">
        <description>Problem: Using Reactor Hooks.onEachOperator means executing the code on every operator in the Reactor flow, for every element. This typically means much processing time.&#13;
            Solution: Just do processing when and where actually needed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='Hooks.onEachOperator']
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;

@Configuration
public class FooBad {
    private String MDC_CONTEXT_REACTOR_KEY = "CONTEXT";
    @PostConstruct
    private void contextOperatorHook() {
        Hooks.onEachOperator(MDC_CONTEXT_REACTOR_KEY,
                Operators.lift((scannable, coreSubscriber) -> new MdcContextLifter<>(coreSubscriber))
        );
    }
}
            ]]>
        </example>
    </rule>

</ruleset>


