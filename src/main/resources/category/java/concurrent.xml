<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-concurrent-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
  //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.take')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.')))
]    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get')]
    (: future.get or variant called on formal param :)
    [(exists(index-of((ancestor::MethodDeclaration//FormalParameter[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on local var :)
    exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on field :)
    exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    )
    (: .get without arguments :)
    and not(../../PrimarySuffix/Arguments/ArgumentList)
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public static String bad(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(); // bad
    }

    public static String good(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(10, TimeUnit.SECONDS); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields. Make final immutable or access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and @GuardedBy or use volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: static field, non-final, non-volatile, non-guarded by :)
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[@Static=true() and @Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]
,
(: static field, non-guarded, some often used known mutable types, declaration side :)
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true()]/Type/ReferenceType/ClassOrInterfaceType[
(((pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL')) or pmd-java:typeIs('java.io.File'))
 or (ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0]))
 and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='GuardedBy'])
])
,
(: static field, non-guarded, some often used known collection/array types, allocation side:)
(//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true() and not (../Annotation//Name[@Image='GuardedBy'])]/
VariableDeclarator/VariableInitializer[((ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0)
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[ArrayDimsAndInits and xs:int(ArrayDimsAndInits and (xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0 or ArrayDimsAndInits/Expression//Name))]
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[(pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet'))]
or Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='Arrays.asList']
)])
,
(: static-block allocations of non-empty arrays :)
//Initializer//AllocationExpression[((ArrayDimsAndInits and ((xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0) or exists(ArrayDimsAndInits/Expression//Name) or exists(ArrayDimsAndInits/ArrayInitializer//Expression)))
or
(: static-block allocations of known mutable types :)
ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet') or pmd-java:typeIs('java.util.EnumMap')])
and
(: given the field is not @GuardedBy :)
ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='GuardedBy']) = 0]/FieldDeclaration//VariableDeclaratorId/@Name
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    enum Bad {
        VAL1;
        static final Map<String, Bad> STRING_TO_ENUM = new HashMap<>(); // bad
    }
    enum Good {
        VAL1;
        static final Map<String, Good> STRING_TO_ENUM; // good
        static {
            Map<String, Good> map = new HashMap<>();
            STRING_TO_ENUM = Collections.unmodifiableMap(map);
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[pmd-java:typeIs('javax.xml.bind.Marshaller')
 or pmd-java:typeIs('javax.xml.bind.Unmarshaller')
 or pmd-java:typeIs('javax.xml.bind.Validator')
 or pmd-java:typeIs('javax.xml.validation.Validator')]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads. Access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            4. Use synchronized for accessors to inherited fields, or better: make field private and use proper accessors on base class level using @GuardedBy.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: assignment to a field :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[(@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
or
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), @Image))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), @Image))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()])
or ancestor::MethodDeclaration[@Name='afterPropertiesSet']
)]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidNonPrivateFieldsInSharedObjects"
          message="Avoid non-private objects shared among threads. Make fields private to ensure thread-safety."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc11">
        <description>
            Problem: A singleton, or more general: an object shared among threads, has a field that is not private.
            These field can possibly be modified from other classes.&#13;
            Solution: Make the fields private.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[
    (
      @Image='Component'
      or @Image='Service'
      or @Image='Controller'
      or @Image='RestController'
      or @Image='Repository'
      or (@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN'])
    )
    (: not shared when request or prototype scope :)
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
    (: if @NotThreadSafe no checking :)
    and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
]
(: non-static, non-final and non-private fields :)
/../../../ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Private=false() and @Final=false()]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInSharedObjects"
          message="Avoid unguarded non-final or mutable fields in objects shared among threads. Make final immutable or access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
(: not shared when request or prototype scope :)
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
    or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: ConfigurationProperties assumed executed only once, no violation, except if Lombok Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: non-final and non-volatile fields :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment level annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: not annotated GuardedBy :)
)
and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableInheritedFieldsInSharedObjects"
          message="Mutator method called on inherited field. Avoid unguarded mutable inherited fields in objects shared among threads. Make final immutable or access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a (inherited) field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: primary expression used :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//../PrimaryExpression//PrimaryPrefix/Name[(
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(:  has arguments (a method call), and  a compound like date.setTime, map.put, list.set :)
(contains(@Image, '.set') or contains(@Image, '.put') or contains(@Image, '.clear') or contains(@Image, '.add') or contains(@Image, '.remove') or contains(@Image, '.replace')) and
(: not starting with a capital, a Class :)
not (starts-with(@Image, upper-case(substring(@Image, 1, 1)))) and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: expression not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not used in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded assignments to non-final fields in objects using synchronized. Access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. In case you are sure the class is used in single threaded context only, remove current use of synchronized and annotate the class with @NotThreadSafe to make this explicit. &#13;
            2. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: assignment to a field :)
/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded non-final or mutable fields in objects using synchronized. Make final immutable or access thread-safely and use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the class is used in single threaded context only, annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: non-final and non-volatile fields :)
/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: mutable types not annotated with GuardedBy :)
) and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="NotProperlySynchronizingOnThisWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy('this')"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which this annotation is applied should only be accessed when holding the built-in 'this' lock by using synchronized.&#13;
            Solution: Make access thread-safe: synchronize access by method modifier or a synchronized(this) block.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[@Synchronized=false()
and not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
//PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[@Image='"this"']/
ancestor::ClassOrInterfaceBodyDeclaration/FieldDeclaration//VariableDeclaratorId/@Name
and (
not (ancestor::SynchronizedStatement)
or ancestor::SynchronizedStatement/Expression//Name)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        @GuardedBy("this")
        private String txt;

        public String getText() { return txt; } // bad
        public void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        @GuardedBy("this")
        private String txt;

        public synchronized String getText() { return txt; }
        public synchronized void setText(String t) { txt = t; }
    }
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnFieldWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy(field)"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which the GuardedBy annotation is applied is not accessed thread-safely as described by GuardedBy.&#13;
            Solution: Make access thread-safe: synchronize access by a synchronized(LOCK) block with LOCK being a final field.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded-by literal *IS* a field (should be private final) :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[substring(@Image, 2, (string-length(@Image) - 2))=
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS NOT* in a synchronized block with the GuardedBy literal:)
    and (not(concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
    ,
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded by literal *IS NOT* a field :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[not (substring(@Image, 2, (string-length(@Image) - 2)) =
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name)
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS* in a synchronized block with the GuardedBy literal:)
    and (
    (concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() { return txt; } // bad
        public synchronized void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() {
            synchronized(LOCK) { return txt; }
        }
        public void setText(String t) {
            synchronized(LOCK) { txt = t; }
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidStaticXmlFactories" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid static XML Factories" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOXAR09">
        <description>An XML Factory like DocumentBuilderFactory, TransformerFactory, MessageFactory is used as static field. Problem: These factory objects are typically not thread-safe and rather expensive to create because of class loading. &#13;
            Solution: Create the Factories as local variables and use command line arguments to specify the implementation class. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBodyDeclaration//FieldDeclaration[@Static=true() and (
    pmd-java:typeIs('javax.xml.parsers.DocumentBuilderFactory') or
    pmd-java:typeIs('javax.xml.parsers.SAXParserFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLInputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLOutputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLEventFactory') or
    pmd-java:typeIs('javax.xml.transform.TransformerFactory') or
    pmd-java:typeIs('javax.xml.validation.SchemaFactory') or
    pmd-java:typeIs('javax.xml.datatype.DatatypeFactory') or
    pmd-java:typeIs('javax.xml.soap.MessageFactory')
    )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Bad {
    private static final DocumentBuilderFactory DB_FACTORY = DocumentBuilderFactory.newInstance(); // shared, bad
 }

 public class Good {
    public build() {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); // local var, good
        // use dbFactory
    }
 }
            ]]>
        </example>
    </rule>

    <rule name="AvoidIncrementOrDecrementForVolatileField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ++, --, +=, -= for volatile fields" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc09">
        <description>A compound statement like i++, i--, i += 1 or i -= 1 may seem one statement and thread-safe for a volatile field. Problem: The operation is actually two separate statements executed non-atomically and therefore not thread-safe. &#13;
            Solution: Guard the field properly with synchronized or use atomics like AtomicInteger. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/(AssignmentOperator[@Image='+=' or @Image='-=']/..|
(PreIncrementExpression|PostfixExpression[@Image='++' or @Image='--']))/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[@Image =
//FieldDeclaration[@Volatile = true()]/VariableDeclarator/VariableDeclaratorId/@Name]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Foo {
    private volatile int i;
    private volatile String str = "";

    public int bad() {
        i++; // bad
        --i; // bad
        i += 1; // bad
        str += "a"; // bad
    }
    public int good(int v) {
        i = 5; // good
        i = v + 5; // good
        str = "other"; // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidVolatileInPrototypeScope" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="No need for volatile in prototype scope" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc10">
        <description>A field is defined as volatile while the class has prototype scope. Problem: volatile has some overhead, especially for writes. When getting the bean from the Spring applicationContext, prototype scope means that each invocation creates a new object so the field is not shared. &#13;
            Solution: Since only one thread can access the field, there is no need for violatile and it can be removed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //FieldDeclaration[@Volatile = true() and
    ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix/
    (Name[ends-with(@Image,'SCOPE_PROTOTYPE')]|Literal[contains(@Image, 'prototype')])]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Bad {
    private volatile String id;
}

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Good {
    private String id;
}
            ]]>
        </example>
    </rule>

    <rule name="SynchronizingForLocalVars" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Local variables don't need synchronization" typeResolution="true"
          externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc12">
        <description>In the synchronized block, only local variables seem to be accessed. Problem: synchronization has overhead and may introduce lock contention. &#13;
            Solution: Remove synchronized because local variables are only accessible by the owning thread and are not shared. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: var.x() in synchronized block, var in list of local vars and all var.x in synchronized block are local vars:)
//SynchronizedStatement[count(./Block//PrimaryPrefix/Name[index-of(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name, substring-before(@Image, '.')) >= 0]) =
count(./Block//PrimaryPrefix/Name[substring-before(@Image, '.')])
and
(: vars used in synchronized block are all local vars :)
count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name | ./Block//PrimaryPrefix/Name[not(contains(@Image, '.'))]/@Image))
 = count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name ))]

                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private Map<String, String> mapField;

    protected Map<String, String> bad() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) { // bad
          if (addHeaders == null) {
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }

  protected Map<String, String> good() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) {
          if (mapField == null) {
              mapField = new HashMap<>();
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }
            ]]>
        </example>
    </rule>

</ruleset>


