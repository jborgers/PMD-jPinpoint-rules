<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-concurrent-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0">
    <description>jPinpoint rule set for performance aware Java coding, sponsored by Rabobank.</description>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance" type="String" description="classification"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodCall[pmd-java:matchesSig('java.util.concurrent.CompletionService#take()')]
                    ]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
public static <T> void collectAllCollectionReplyFromThreads(CompletionService<List<T>> completionService) {
    try {
        Future<List<T>> futureLocal = completionService.take(); // bad
        Future<List<T>> futuresGood = completionService.poll(3, TimeUnit.SECONDS); // good
        responseCollector.addAll(futuresGood.get(10, TimeUnit.SECONDS)); // good
    } catch (InterruptedException | ExecutionException e) {
        LOGGER.error("Error in Thread : {}", e);
    } catch (TimeoutException e) {
        LOGGER.error("Timeout in Thread : {}", e);
    }
}
     ]]></example>
    </rule>

    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig('java.util.concurrent.Future#get()')]
                ]]></value>
            </property>
        </properties>
        <example><![CDATA[
public static String bad(CompletableFuture<String> complFuture) throws Exception {
    return complFuture.get(); // bad
}

public static String good(CompletableFuture<String> complFuture) throws Exception {
    return complFuture.get(10, TimeUnit.SECONDS); // good
}
         ]]></example>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and @GuardedBy or use volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: static field, non-final, non-volatile, non-guarded by :)
//FieldDeclaration[
    pmd-java:modifiers() = ('static')
    and not(pmd-java:modifiers() = ('final','volatile'))
    and not(./ModifierList/Annotation[pmd-java:typeIs('net.jcip.annotations.GuardedBy')])
]
,
(: static field, non-guarded, some often used known mutable types, declaration side :)
//FieldDeclaration[
    pmd-java:modifiers() = ('static')
    and (./ClassType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL')) or pmd-java:typeIs('java.io.File')]
    or ./VariableDeclarator/ArrayInitializer[@Length > 0])
    and not(./ModifierList/Annotation[pmd-java:typeIs('net.jcip.annotations.GuardedBy')])
]
,
(: static field, non-guarded, some often used known collection/array types, allocation side:)
//FieldDeclaration[
    pmd-java:modifiers() = ('static') and not(./ModifierList/Annotation[pmd-java:typeIs('net.jcip.annotations.GuardedBy')])
    and .//ConstructorCall/ClassType[
       (pmd-java:typeIs('java.util.ArrayList') and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableList(_*)')]) )
       or ((pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.EnumMap')) and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableMap(_*)')]))
       or (pmd-java:typeIs('java.util.HashSet') and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableSet(_*)')]))
    ]
    or .//ArrayInitializer[@Length > 0]
    or .//ArrayAllocation[.//ArrayDimExpr/NumericLiteral[@ValueAsInt > 0]]
    or .//MethodCall[pmd-java:matchesSig('java.util.Arrays#asList(_*)') and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableList(_*)')])]
]
,
(: static-block allocations of non-empty arrays :)
//Initializer//ArrayAllocation[ArrayType/ArrayDimensions[@Size > 0]/ArrayDimExpr/NumericLiteral[@ValueAsInt > 0]
  or exists(.//ArrayDimExpr/VariableAccess/@Name)
  or exists(.//ArrayInitializer/*)]
,
(: static-block allocations of known mutable types :)
//Initializer//ExpressionStatement//ConstructorCall[
       (
         (pmd-java:typeIs('java.util.ArrayList') and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableList(_*)')]) )
           or ((pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.EnumMap')) and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableMap(_*)')]))
           or (pmd-java:typeIs('java.util.HashSet') and not(ancestor::MethodCall[pmd-java:matchesSig('java.util.Collections#unmodifiableSet(_*)')]))
       )
  and not(../VariableAccess/@Name = ancestor::ClassDeclaration//FieldDeclaration[count(ModifierList/Annotation[pmd-java:typeIs('net.jcip.annotations.GuardedBy')]) > 0]/VariableDeclarator/VariableId/@Name)
]
                ]]></value>
            </property>
        </properties>
        <example><![CDATA[
enum Bad {
    VAL1;
    static final Map<String, Bad> STRING_TO_ENUM = new HashMap<>(); // bad
}
enum Good {
    VAL1;
    static final Map<String, Good> STRING_TO_ENUM; // good
    static {
        Map<String, Good> map = new HashMap<>();
        STRING_TO_ENUM = Collections.unmodifiableMap(map);
    }
}
        ]]></example>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[ClassType[pmd-java:typeIs('javax.xml.bind.Marshaller')
  or pmd-java:typeIs('javax.xml.bind.Unmarshaller')
  or pmd-java:typeIs('javax.xml.bind.Validator')
  or pmd-java:typeIs('javax.xml.validation.Validator')]
]
			     ]]></value>
            </property>
        </properties>
        <example><![CDATA[
class Exporter {

    private javax.xml.bind.Unmarshaller sharedUnmarshaller; // bad
    private javax.xml.bind.Validator sharedValidator; // bad

    public Thing doSomething(File xml) {
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller(); // good, create one each time
        return (Thing) unmarshaller.unmarshal(xml);
    }
}
        ]]></example>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="${doc_root}/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mix-up session data. &#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            4. Use synchronized for accessors to inherited fields, or better: make field private and use proper accessors on base class level using @GuardedBy.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tags" value="jpinpoint-rule,multi-threading,data-mix-up" type="String" description="classification"/>
            <property name="xpath">
                <value><![CDATA[
(: annotations that make singleton like components in Spring and EJB :)
//ClassDeclaration[
  (
       pmd-java:hasAnnotation('org.springframework.stereotype.Service')
    or pmd-java:hasAnnotation('org.springframework.stereotype.Component')
    or pmd-java:hasAnnotation('org.springframework.stereotype.Controller')
    or pmd-java:hasAnnotation('org.springframework.stereotype.Repository')
    or pmd-java:hasAnnotation('org.springframework.web.bind.annotation.RestController')
    or (pmd-java:hasAnnotation('javax.ejb.Singleton') and ModifierList/Annotation[pmd-java:typeIs('javax.ejb.ConcurrencyManagement')]/AnnotationMemberList/MemberValuePair/FieldAccess[./TypeExpression[pmd-java:typeIs('javax.ejb.ConcurrencyManagementType')] and @Name="BEAN"])
   )
   (: no @RequestScope annotation :)
   and not (pmd-java:hasAnnotation('org.springframework.context.annotation.Scope') and .//AnnotationMemberList/MemberValuePair[
       StringLiteral[contains(@Image,'request') or contains(@Image,'prototype')]
       or FieldAccess[@Name='SCOPE_REQUEST' or @Name='SCOPE_PROTOTYPE']/TypeExpression[pmd-java:typeIs('org.springframework.beans.factory.config.ConfigurableBeanFactory')]]
    )
    (: no request or prototype @Scope, literal or via constant :)
  and not(pmd-java:hasAnnotation('org.springframework.web.context.annotation.RequestScope'))
  (: if @NotThreadSafe no checking :)
  and not(pmd-java:hasAnnotation('net.jcip.annotations.NotThreadSafe'))
  (: no checking if @ConfigurationProperties and no @Setter :)
  and not(pmd-java:hasAnnotation('org.springframework.boot.context.properties.ConfigurationProperties'))
  and not(pmd-java:hasAnnotation('lombok.Setter'))
]
(: assignment to a field, get left hand of assignment :)
//AssignmentExpression/*[1][
   (
       (: non-final, non-volatile and non-GuardedBy fields :)
       @Name = ancestor::ClassBody//FieldDeclaration[
                   not(pmd-java:modifiers() = ('final','volatile')
                        or pmd-java:hasAnnotation('net.jcip.annotations.GuardedBy')
                   )]//VariableId/@Name
       or (
         (: not 'this' and extends a base class :)
         ancestor::ClassDeclaration//ExtendsList
         and not (
           (: var is not a local var :)
           @Name = ancestor::Block//LocalVariableDeclaration//VariableId/@Name
           or
           (: var is not a param :)
           @Name = ancestor::MethodDeclaration//FormalParameter/VariableId/@Name
           or
           (: var is not a field of current class TODO - repeat of line above, can be avoided? :)
           @Name = ancestor::ClassBody//FieldDeclaration[(pmd-java:modifiers() = ('final','volatile') or pmd-java:hasAnnotation('net.jcip.annotations.GuardedBy'))]//VariableId/@Name
         )
         and not(
              ancestor::SynchronizedStatement
              or ancestor::MethodDeclaration[pmd-java:modifiers() = 'synchronized']
             )
       )
     )
     (: field not on accessor method with assignment, annotated with framework annotation :)
     and not(
          ancestor::MethodDeclaration[
                pmd-java:hasAnnotation('org.springframework.beans.factory.annotation.Autowired')
                or pmd-java:hasAnnotation('javax.annotation.PostConstruct')
                or pmd-java:hasAnnotation('org.springframework.batch.core.annotation.BeforeStep')
                or pmd-java:hasAnnotation('org.springframework.beans.factory.annotation.Value')
                or pmd-java:hasAnnotation('javax.inject.Inject')
             ]
          (: field not assigned in non-public accessor method annotated with VisibleForTesting :)
          or (ancestor::MethodDeclaration[pmd-java:hasAnnotation('com.google.common.annotations.VisibleForTesting') and not(@Visibility='public')])
          (: annotation is not enough? :)
          or ancestor::MethodDeclaration[@Name='afterPropertiesSet']
        )
 ]
]]></value>
            </property>
        </properties>
        <example><![CDATA[
@Service
class MyService {

    private final LOCK = new Object();

    @Value("${batchService.http.url}")
    private String batchUrl;

    @GuardedBy("LOCK")
    @Value("${otherService.http.url}")
    private String otherUrl;

    public void setBatchUrl(final String url) {
        this.batchUrl = url; // bad: unguarded accessor method
    }

    public void setOtherUrl(final String url) {
        synchronized(LOCK) {
            this.batchUrl = url; // good: synchronized accessor method
        }
    }
}
            ]]></example>
    </rule>
</ruleset>
