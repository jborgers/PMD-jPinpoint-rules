<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-kotlin-rules" 
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd"> 

<description>
         jPinpoint specific rules for performance aware Kotlin coding, sponsored by Rabobank.
</description>

<!-- IMPORTANT NOTICE: The content of this file is generated. Do not edit this file directly since changes may be lost when this file is regenerated! -->

<!-- BEGIN Included file 'common.xml' -->
    <rule name="AvoidDecimalAndChoiceFormatAsField"
          since="7.0"
          language="kotlin"
          message="Avoid using NumberFormat, DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio01">
        <description>
            Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe.
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        (jpinpoint-kotlin-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="3.1"/>
            <property name="xpath">
                <value><![CDATA[
(: check if java.text imports exists as filter for same named classes in other packages :)
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='text']]/ancestor::KotlinFile
(: PrimaryExpression finds the constructors instead of type declarations :)
(: filter matches in functions :)
//ClassDeclaration//PrimaryExpression//SimpleIdentifier//T-Identifier[
 (@Text="DecimalFormat" or @Text="ChoiceFormat")
 and not(ancestor::FunctionDeclaration)
]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
class Foo {

    companion object {
        val NUMBER_FORMAT: DecimalFormat = DecimalFormat("###.###") // bad
    }

    private val numFormat: NumberFormat = DecimalFormat("###.###") //bad

    private val limits = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0)
    private val dayOfWeekNames = arrayOf("Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat")
    private val form = ChoiceFormat(limits, dayOfWeekNames) // bad

    fun shouldNotMatchInsideMethod() {
        val format: NumberFormat = DecimalFormat("##.##")
        val choiceFormat = ChoiceFormat(limits, dayOfWeekNames)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor"
          since="7.0"
          language="kotlin"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio01">
        <description>
            The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)
        (jpinpoint-kotlin-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[.//T-Identifier[@Text='java'] and .//T-Identifier[@Text='io']][1]/ancestor::KotlinFile
//Expression//T-Identifier[(@Text='ByteArrayOutputStream' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=32]])
or (@Text='StringWriter' and ../../../
PostfixUnarySuffix//ValueArguments[not(ValueArgument) or ValueArgument//T-IntegerLiteral[number(@Text)<=16]])]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
import java.io.ByteArrayOutputStream
import java.io.StringWriter

class AvoidInMemoryStreamingDefaultConstructor {
    fun bad() {
        var baos = ByteArrayOutputStream() //bad
        val sw = StringWriter() //bad
        baos = ByteArrayOutputStream(32) //bad - not larger than default
    }
    fun good() {
        val baos = ByteArrayOutputStream(8192) // 8 kiB
        val sw = StringWriter(2048)
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule"
          language="kotlin"
          message="XPathExpression is created and compiled every time. Beware it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution (sure? - TODO) .
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[.//T-Identifier[@Text='javax'] and .//T-Identifier[@Text='xml'] and .//T-Identifier[@Text='xpath']]/ancestor::KotlinFile
//FunctionBody//T-Identifier[@Text='newXPath']
/ancestor::FunctionBody//T-Identifier[@Text='compile'
or @Text='evaluate' and ancestor::PostfixUnarySuffix/..//ValueArguments[count(./ValueArgument) = 3]]
(: note on limitation, the 2-argument version is not found, difficult to do the typeIs checking like in Java :)
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.w3c.dom.Document
import org.w3c.dom.NodeList
import javax.xml.xpath.*

class AvoidRecompilingXPathExpressionKotlin {
    fun bad1(doc: Document?): NodeList {
        val xpath: XPath = XPathFactory.newInstance().newXPath()
        val expr: XPathExpression = xpath.compile("//book[author='Isaac Asimov']/title/text()") // bad
        return expr.evaluate(doc, XPathConstants.NODESET) as NodeList
    }

    @Throws(XPathExpressionException::class)
    fun bad2(doc: Document?): NodeList {
        val xpath: XPath = XPathFactory.newInstance().newXPath()
        val xPathQuery = "//book[author='Isaac Asimov']/title/text()"
        return xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET) as NodeList // bad
    }
}
// TODO Good example
            ]]>
        </example>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule"
          since="7.0"
          language="kotlin"
          message="StringBuffer is used. It introduces locking overhead, use StringBuilder."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaration/Type//T-Identifier[@Text='StringBuffer'],
//Declaration//PrimaryExpression//T-Identifier[@Text='StringBuffer']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class AvoidStringBuffer {
    var fieldSb: StringBuffer? = null // bad
    fun bad() {
        val sb = StringBuffer() // bad
    }
    fun good() {
        val sb = StringBuilder()
    }
]]>
        </example>
    </rule>

<!-- END Included file 'common.xml' -->
<!-- BEGIN Included file 'remoting.xml' -->
    <rule name="AvoidDeprecatedHystrix"
          since="7.0"
          language="kotlin"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          message="Netflix Hystrix is deprecated. Use an alternative like resilience4j"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi11">
        <description>Problem: Hystrix is not actively maintained anymore.&#13;
            Solution: Netflix recommends to use open source alternatives like resilience4j. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
//ImportHeader[starts-with(@joinTokenText, 'importcom.netflix.hystrix')]
]]>
                </value>
            </property>
        </properties>
        <example>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutDisableConnectionState"
          since="7.0"
          language="kotlin"
          message="A HttpClient builder is used and disableConnectionState is not called. HTTP client tracks connection state while using TLS."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi07">
        <description>
            Problem: NTLM authenticated connections and SSL/TLS connections with client certificate authentication are stateful: they have a specific user identity/security context per session. If HttpClients have enabled connection state tracking which is the default, established TLS connections will not be reused because it is assumed that the user identity or security context may differ.
            Then performance will suffer due to a full TLS handshake for each request.&#13;
            Solution: HttpClients should disable connection state tracking in order to reuse TLS connections, since service calls for one pool have the same user identity/security context for all sessions. (jpinpoint-rules)
        (jpinpoint-kotlin-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="xpath">
                <value><![CDATA[
(:locally created http client builder without disableConnectionState :)
//PostfixUnarySuffix//SimpleIdentifier/T-Identifier[@Text="custom"
  and ancestor::PostfixUnaryExpression/PrimaryExpression/SimpleIdentifier/T-Identifier/@Text="HttpClients"
  and not(ancestor::PostfixUnaryExpression/PostfixUnarySuffix/NavigationSuffix/SimpleIdentifier/T-Identifier/@Text="disableConnectionState")]
,
//PostfixUnarySuffix//SimpleIdentifier/T-Identifier[@Text="create"
  and ancestor::PostfixUnaryExpression/PrimaryExpression/SimpleIdentifier/T-Identifier[(@Text="HttpClientBuilder" or @Text="HttpAsyncClientBuilder")
  and not(ancestor::PostfixUnaryExpression/PostfixUnarySuffix/NavigationSuffix/SimpleIdentifier/T-Identifier/@Text="disableConnectionState")]]
,
(: method param http client builder without disableConnectionState :)
//FunctionValueParameter/Parameter/Type/TypeReference/UserType/SimpleUserType/SimpleIdentifier/T-Identifier[(@Text="HttpClients" or @Text="HttpClientBuilder" or @Text="HttpAsyncClientBuilder")
  and not(ancestor::FunctionDeclaration//PostfixUnarySuffix/NavigationSuffix/SimpleIdentifier/T-Identifier/@Text="disableConnectionState")]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
    private fun createHttpClientBuilder(properties: ConnectionProperties) =
        HttpClients.custom()
            .setDefaultRequestConfig(createRequestConfig(properties))
            .setMaxConnTotal(properties.maxConnTotal)
            .setMaxConnPerRoute(properties.maxConnPerRoute) // violation, no disableConnectionState() call
]]>
        </example>
    </rule>

<!-- END Included file 'remoting.xml' -->
</ruleset>
