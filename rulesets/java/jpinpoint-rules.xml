<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-rules" 
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd"> 

<description>
         jPinpoint specific rules for performance aware Java coding, sponsored by Rabobank.
</description>

<!-- IMPORTANT NOTICE: The content of this file is generated. Do not edit this file directly since changes may be lost when this file is regenerated! -->

<!-- BEGIN Included file 'common.xml' -->
    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by CDI for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
])
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::VariableDeclarator/VariableDeclaratorId/@Name
])]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendar"
          language="java"
          message="A Calendar is inefficient in memory usage."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#imu01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use Date, Java 8+ java.time.[Local/Zoned]DateTime or joda time [Local]DateTime.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//(Type)[pmd-java:typeIs('java.util.Calendar')]
,
//Name[starts-with(@Image, 'Calendar.')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class CalendarStuff {
    Calendar field1; // bad

    private Calendar bad1() {
        return Calendar.getInstance();
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
 //ClassOrInterfaceDeclaration[@Interface=true()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public interface Foo {
    static final Object CONST = new Object(); //bad
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe. The usual solution
            is to create a new local one when needed in a method.
        (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator/VariableInitializer/Expression[pmd-java:typeIs('java.text.DecimalFormat') or pmd-java:typeIs('java.text.ChoiceFormat')]
        ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected are different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement/BlockStatement[
(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
or
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image)
and
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
not(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimarySuffix/Arguments/@Size > 0
or preceding-sibling::SwitchLabel[@Default=true()])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidExposingMutableRecordState"
          language="java"
          message="Avoid exposing mutable state of the record. Use copyOf in the compact constructor."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#voedos06">
        <description>Problem: Internal state can be modified from outside of the record, through the implicit accessor method or by the caller of the constructor. Risk of thread-unsafety.
            Solution: Use the record compact constructor to defensively copy the (possibly) mutable object such as a List, Set or Map, e.g. with List.copyOf().
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//RecordDeclaration//RecordComponent/Type[(pmd-java:typeIs('java.util.Collection') or pmd-java:typeIs('java.util.Map'))
and
not(../VariableDeclaratorId/@Name = ancestor::RecordDeclaration/RecordBody/CompactConstructorDeclaration//StatementExpression
[Expression//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'copyOf')]]/PrimaryExpression/PrimaryPrefix/Name/@Image)]                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
record BadRecord(String name, List<String> list) {
}

record GoodRecord(String name, List<String> list) {
    public GoodRecord {
        list = List.copyOf(list);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(//MethodDeclaration//(PrimaryPrefix/Name[ends-with(@Image, '.replaceAll') or ends-with(@Image, '.replaceFirst') or @Image='Pattern.matches']
|PrimarySuffix[@Image = 'replaceAll' or ends-with(@Image, '.replaceFirst')])
/following::PrimarySuffix[1]/Arguments[ArgumentList/@Size=2]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.split') or ends-with(@Image, 'getPathMatcher')]/../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
(:--- not (if foreign field (with .), or field with short String or without regex char) ---:)
Name[contains(@Image, '.') or @Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimarySuffix[@Image='getPathMatcher']/../PrimarySuffix/Arguments[ArgumentList/@Size=1]/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]]/VariableDeclaratorId/@Name])
]
,
(: --- String.matches called on formalparams, locals and fields --- :)
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.matches')]
[
(exists(index-of((ancestor::MethodDeclaration//FormalParameter[pmd-java:typeIs('java.lang.String')]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[pmd-java:typeIs('java.lang.String')]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('java.lang.String')]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.'))))
and
(: for matches param is >5 literal or something named :)
../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
(: exclude method calls :)
and not(../PrimarySuffix)
(: exclude for param is method arg or local :)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
(: exclude for param is short fields :)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]
]/VariableDeclaratorId/@Name])
]])
]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio01">
        <description>The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.ByteArrayOutputStream') or pmd-java:typeIs('java.io.StringWriter')]
[not(../Arguments/ArgumentList)
or
(pmd-java:typeIs('java.io.ByteArrayOutputStream') and (../Arguments//Literal[number(@Image) <= 32] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Name) <= 32]/@Image]))
or
(pmd-java:typeIs('java.io.StringWriter') and (../Arguments//Literal[number(@Image) <= 16] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Image) <= 16]/@Name]))
]/..
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static void bad()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //bad
        StringWriter sw = new StringWriter(); //bad
        baos = new ByteArrayOutputStream(32); //bad - not larger than default
    }
}
class Good {
    public static void good()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); // 8 kiB
        StringWriter sw = new StringWriter(2048);
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidLombokAnnotationForNonExistentFields"
          language="java"
          message="Avoid Lombok annotations for fields of a class while the class has no fields."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="">
        <description>Problem: Lombok annotations for fields [@Getter, @Setter, @EqualsAndHashCode, @Value, @Data] are of no use and confusing in case the class has no fields.&#13;
            Solution: Remove the Lombok annotation.
        (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)/Annotation
    [MarkerAnnotation/Name[@Image='Getter' or @Image='Setter' or @Image='Value' or @Image='Data' or @Image='EqualsAndHashCode']]
    [count(..//FieldDeclaration) = 0]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
        @Data // bad
        public class BusinessException extends RuntimeException {
            // no fields, no methods
        }
            ]]>
        </example>
    </rule>

    <rule name="AvoidMultipleConcatStatements" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Multiple statements concatenate to the same String. Use StringBuilder append." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name
[@Image=./../../../../../../../../../../../..//VariableDeclaratorId/@Name
and
./../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]
]
/../../../AssignmentOperator[@Image='+=']/
../Expression//PrimaryExpression/PrimaryPrefix/Name) > 1]/BlockStatement[position()=last()]
|
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[
@Image = ../../../Expression/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
@Image = ./../../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/@Name
]
]) > 1 ]//BlockStatement[position()=last()]//StatementExpression/Expression/AdditiveExpression[@Operator = '+']
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidMutableLists"
          language="java"
          message="List is not modified, make it immutable or unmodifiable"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml01">
        <description>Problem: A list which is unnecessarily mutable may accidentally be added to and cause a memory leak. &#13;
            Solution: Make it impossible to modify the list after initialization: use Java 9 List.of, Java 11 List.copyOf, Collections.unmodifiableList or Guava ImmutableList.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    (: a field of type List :)
    //FieldDeclaration[pmd-java:typeIs('java.util.List')]
    (: exclude ConfigurationProperties classes :)
    [count(ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties']) = 0]
    (: exclude when JPA annotated :)
    [count(../Annotation//Name[@Image='OneToMany' or @Image='ManyToMany']) = 0]
    //VariableDeclaratorId[
    (: with a method defined at that level that does not use the field with a modify operation (case field.modOp) :)
    not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
    starts-with(substring-after(@Image, '.'), 'add') or
    starts-with(substring-after(@Image, '.'), 'remove') or
    substring-after(@Image, '.') = 'set' or
    substring-after(@Image, '.') = 'clear' or
    substring-after(@Image, '.') = 'replaceAll' or
    substring-after(@Image, '.') = 'retainAll'
    ]/(substring-before(concat(@Image, '.'), '.')))]
    [ (: and case this.field.modOp() :)
not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression
/PrimarySuffix[starts-with(@Image, 'add') or starts-with(@Image, 'remove') or @Image = 'set' or @Image = 'clear' or @Image = 'replaceAll' or @Image = 'retainAll']
/preceding-sibling::PrimarySuffix/@Image)
    ]     (: and :)
    [( (: field is initialized with List allocation :)
    ../VariableInitializer/Expression//AllocationExpression[pmd-java:typeIs('java.util.List')]
    or
    (: or static block / constructor has field initialized with List allocation :)
    ancestor::ClassOrInterfaceBody//(Initializer|ConstructorDeclaration)//AssignmentOperator[exists(../Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.List')])]/..//Name/@Image = @Name
    or
    (: or constructor has a simple assignment to the field, param of literal: no arguments :)
    ancestor::ClassOrInterfaceBody//ConstructorDeclaration//AssignmentOperator[exists(../Expression[pmd-java:typeIs('java.util.List')]) and not(exists(../Expression/PrimaryExpression/PrimarySuffix))]/..//Name/@Image = @Name
    )]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Bad {
    List unmutated = new ArrayList(Arrays.asList("one", "two")); // bad
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
public class Good {
    List unmutated1 = Collections.unmodifiableList(Arrays.asList("one", "two")); // Java 8
    List unmutated2 = List.of("one, "two"); // Java 9+
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReStreamingEnumValues"
          language="java"
          message="Avoid re-streaming enum values to find a value by a field."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc07">
        <description>Problem: the time to find element is O(n); n = the number of enum values. This identical processing is executed for every call. Considered problematic when n > 3.
            Solution: use a static field-to-enum-value Map. Access time is O(1), provided the hashCode is well-defined.
            For one String field, usually toString returns that field. Implement a fromString method to provide the reverse conversion by using the map.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //EnumDeclaration/EnumBody[count(EnumConstant) > 3]//MethodDeclaration/Block//PrimaryExpression
    [PrimaryPrefix/Name[@Image='Arrays.stream' or @Image='Stream.of']]
    [//PrimaryExpression/PrimaryPrefix/Name[@Image = 'values' or @Image = concat(ancestor::EnumDeclaration/@SimpleName, '.values')]]
    [PrimarySuffix[starts-with(@Image, 'find')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
// BAD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Stream.of(values()).filter(v -> v.toString().equals(name)).findAny(); // bad: iterates for every call, O(n) access time
    }
}

Usage: `Fruit f = Fruit.fromString("banana");`

// GOOD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private static final Map<String, Fruit> nameToValue =
            Stream.of(values()).collect(toMap(Object::toString, v -> v));
    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Optional.ofNullable(nameToValue.get(name)); // good, get from Map, O(1) access time
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingPatterns" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.util.regex.Pattern') and ends-with(@Image, '.compile') and
count(../../PrimarySuffix[1]/Arguments/ArgumentList/Expression//PrimaryExpression) = 1
and not (
../../PrimarySuffix[1]/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call. Problem: Creation XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching in Thread locals may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration//ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.newXPath')]
/ancestor::ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.compile')]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static NodeList bad(Document doc) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
        return expr.evaluate(doc, XPathConstants.NODESET);
    }
}

class Good {
    private static final ThreadLocal<XPathFactory> tlFac = ThreadLocal.withInitial(XPathFactory::newInstance);
    private static final ThreadLocal<XPathExpression> tlExpr;
    static {
        XPath xpath = tlFac.get().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // good
        tlExpr = ThreadLocal.withInitial(expr); // good
    }
    public static NodeList good(Document doc) {
        return tlExpr.get().evaluate(doc, XPathConstants.NODESET); // good
    }
}
            ]]>
        </example>


    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: org.joda.time.format.DateTimeFormatter or Java 8 java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //FieldDeclaration[@Final=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //FieldDeclaration[@Final=true() and @Static=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')](: has assignment, otherwise check in constructor :)[ancestor::ClassOrInterfaceBodyDeclaration//VariableInitializer],
    //ConstructorDeclaration/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of constructor call :)[not(ancestor::BlockStatement//Expression/PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::ConstructorDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //MethodDeclaration/Block/BlockStatement//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormatter.ofPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'ISODateTimeFormat.')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'DateTimeFormat.fullDateTime')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatterBuilder')][ancestor::PrimaryExpression/PrimarySuffix[@Image="toFormatter"]]
                   ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Reflection is used in toString or hashCode, which is expensive." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, preferably using Guava.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/AllocationExpression/ClassOrInterfaceType
	[
		pmd-java:typeIs('org.apache.commons.lang.builder.EqualsBuilder')
		or pmd-java:typeIs('org.apache.commons.lang.builder.HashCodeBuilder')
	]
[../../../PrimarySuffix[1]
	[
		@Image='reflectionEquals'
		or @Image='reflectionHashCode'
	]
] |
//PrimaryPrefix/Name
	[
		@Image='EqualsBuilder.reflectionEquals'
		or @Image='HashCodeBuilder.reflectionHashCode'
	]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSimpleDateFormat" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."  typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use a Joda-Time DateTimeFormat to create a specific DateTimeFormatter or Java 8 java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[
    pmd-java:typeIs('java.text.SimpleDateFormat')
    and not (ancestor::ClassOrInterfaceBodyDeclaration//PrimaryPrefix/Name[
       ends-with(@Image, 'setDateFormat')
       and (   pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
            or pmd-java:typeIs('com.fasterxml.jackson.dataformat.xml.XmlMapper'))
    ])
]
                ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="StringBuffer is used. It introduces locking overhead, use StringBuilder." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
                    //VariableDeclarator[../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.StringBuffer')]]
                    ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidTimeUnitConfusion" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//Type/PrimitiveType/../..//VariableDeclaratorId[ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')]
,
(: @Value :)
//SingleMemberAnnotation/Name[@Image='Value']/..//Literal[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidTimeUnitConfusionPMD7" since="7.0" class="net.sourceforge.pmd.lang.rule.XPathRule" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//VariableDeclaratorId[preceding-sibling::PrimitiveType|../../PrimitiveType][ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')]
,
(: @Value :)
//Annotation[@SimpleName='Value']//StringLiteral[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Log String is built irrespective of log level." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') = 'append')
and count(ancestor::IfStatement) = 0
and
count(ancestor::MethodDeclaration/Block/BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList//PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') != 'append')]) = 0
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnnecessaryStringBuilderCreation"
          language="java"
          message="Use concatenation (+) instead of new StringBuilder if only one statement."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu05">
        <description>Problem: Creating a StringBuilder and using append is more verbose, less readable and less maintainable than simply using String concatenation (+).
            For one statement resulting in a String, creating a StringBuilder and using append is not faster than simply using concatenation.&#13;
            Solution: Simply concatenate Strings in one statement, it is more concise, better readable and more maintainable.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: append used in one chained statement on allocated StringBuilder and with chained toString :)
//MethodDeclaration//Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/../../../PrimarySuffix[@Image = "toString"]/../PrimarySuffix[@Image = "append"][1] (: only report first append in chain :)
|
(: or :)
(: append on builder var, where var is allocated as StringBuilder :)
//MethodDeclaration//Block//PrimaryPrefix/Name[ends-with(@Image, '.append') and starts-with(@Image,
ancestor::Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/ancestor::VariableDeclarator/VariableDeclaratorId/@Name[0])
and
(
(: and either 1. toString is called in a chain after append :)
../../PrimarySuffix[@Image = 'toString'] or
(: or 2. toString is called on the var in same block :)
concat(substring-before(@Image, '.'), '.toString') = ancestor::Block//PrimaryPrefix/Name[ends-with(@Image, '.toString')]/@Image)
(: and not append on var used in inner block like a ForStatement :)
and not(ancestor::Block//Block//PrimaryPrefix/Name[ends-with(@Image, '.append')])
(: and not append in lambda expression, issue 195 :)
and not(ancestor::LambdaExpression)
(: and var not passed as argument to method :)
and not(substring-before(@Image, '.') = ancestor::Block//Statement//PrimarySuffix/Arguments//Name/@Image)
]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    String name;
    String value;

    public String bad() {
        return new StringBuilder()
           .append(name) // bad
           .append(" = ")// bad
           .append(value)// bad
           .toString();
    }

    public String good() {
        return name + " = " + value;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidWideScopeXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression targets a wide scope, this is potentially slow." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimarySuffix[
Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/
Literal[starts-with(@Image, '"//')]
and
../PrimaryPrefix/Name[ends-with(@Image, '.compile')]
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathAPIUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathAPI is used. XPathAPI implementation has bad performance." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'XPathAPI.')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPath is used. XPath implementation has bad performance." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/
ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[@Image='XPathFactory.newInstance']
[not (ancestor::FieldDeclaration//ClassOrInterfaceType/@Image = 'ThreadLocal')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="BufferOutputStream"
          language="java"
          message="Files.newOutputStream is not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio05">
        <description>Problem: Files.newOutputStream is not buffered.
            The stream is written to file byte by byte, where each operating system call has its overhead which makes it slow.
            Solution: Use buffering to write a chunk of bytes at once with much lower overhead.
            Use e.g. BufferedOutputStream which has a buffer size of 8 kB to write at once.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newOutputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedOutputStream')]) = 0]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    OutputStream bad(String path) throws IOException {
        return java.nio.file.Files.newOutputStream(Paths.get(path)); // bad
    }
    OutputStream good(String path) throws IOException {
        return new BufferedOutputStream(java.nio.file.Files.newOutputStream(Paths.get(path)));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. Or use Lombok @EqualsAndHashCode, @Value or @Data. Also holds for inner classes.
            If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... , @Entity, Throwable and Executor objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- top level class - not annotated that would make it a non-value object --:)
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(:-- a getter with result type of a field --:)
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)
(:-- and class has no equals or hashCode method --:)
and (not (ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='equals' or @Name='hashCode']))
(:-- and class has a toString and #fields <= 1+#getters --:)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@SimpleName, 'Dto')]
or
(:-- #fields == #getters --:)
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)]
]/.. (:--up to class --:)

(:-- inner classes --:)
,
//ClassOrInterfaceBodyDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[(
ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='equals'])
)
and
((ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[1][ends-with(@SimpleName, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
)]
or
ancestor::ClassOrInterfaceBodyDeclaration[1]/Annotation//Name[@Image='Getter']
]/.. (:--up to class --:)
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Getters { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
}

@Getter
class LombokGetterBad { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";
}

@Getter
@EqualsAndHashCode
class LombokGetterGood {
    private String someState1 = "some1";
    private String someState2 = "some2";
}
            ]]>
        </example>
    </rule>

    <rule name="ImproperVariableName"
          language="java"
          message="Give variables and fields a meaningful name."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#m01">
        <description>Problem: Variables like 'var3' and fields like 'FOUR = 4', do not express what they are used for. This is bad for maintainability.&#13;
            Solution: Let variable names express what they are used for, like 'key' and 'MAX_KEYS = 4'
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaratorId[matches(@Name, 'ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN', 'i')
and replace(@Name, 'ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|_', '', 'i') = ''
or starts-with(@Name, 'var') and number(substring-after(@Name, 'var'))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private static final int FOUR_ZERO_NINE_SIX = 4096; // bad
    private static int six = 6; // bad
    private int five = 6; // really bad
    private static final int SIXTIES_START = 1960; // good

    void bar() {
        String var1 = "baz"; // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="InconsistentEqualsAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals does not use all fields used by hashCode or it uses inconsistent conversion." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: Use the same fields in equals and hashCode and if conversions are needed, use identical conversions in both. So don't use equalsIgnoreCase. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) <
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
,
//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//Name[ends-with(@Image, 'equalsIgnoreCase')]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad1 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryoutBad3 that = (EqHashTryoutBad3) o;
        return Objects.equals(field1, that.field1); // field2 missing
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad2 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryoutBad2 that = (EqHashTryoutBad2) o;
        if (field1 != null ? !field1.equals(that.field1) : that.field1 != null) return false;
        return field2 != null ? field2.equalsIgnoreCase(that.field2) : that.field2 == null; // ignore case
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        result = 31 * result + (field2 != null ? field2.hashCode() : 0);
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MDCPutWithoutRemove" message="MDC put is used without finally remove." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//StatementExpression//Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)[not(@Image=
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion']/Block)//Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)/@Image)
and not((ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion']/Block)//Name[@Image='MDC.clear'])
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MinimizeAttributesInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Attribute is set in the session, yet not removed. This may bloat the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/MethodDeclaration[../..//(VariableDeclaratorId |ReturnStatement/Expression)[pmd-java:typeIs('javax.portlet.PortletSession') or pmd-java:typeIs('javax.servlet.http.HttpSession')]]
/Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'removeAttribute')]
)]]
,
//ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    PortletSession session; // same for HttpSession
    public void setAttribute(String name, Object obj) {
	    session.setAttribute(name, obj);                 // bad
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
}

class Good {
    PortletSession session; // same for HttpSession
	public void setAttribute(String name, final Object obj) {
		session.setAttribute(name, obj);
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
	public void removeAttribute(String name) {
		session.removeAttribute(name);
	}
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Field simply assigned to is missing in equals method." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah04">
        <description>Problem: If a field which can be assigned separately (independent of other fields) is missing in the equals method, then changing the field in one object has no effect on the equality with another object.
            However, if a field of one of two equal objects is changed, the expectation is that they are no longer equal.&#13;
            Solution: include the missing field in the equals and hashCode method. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]//VariableDeclaratorId[
    (: names used as left hand side in simple assignments in methods or constructor matching fields:)
     (@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/(MethodDeclaration|ConstructorDeclaration)
    /..//BlockStatement//StatementExpression
    (: simple assignment :)
    [exists(AssignmentOperator) and not(exists(Expression/PrimaryExpression/PrimarySuffix))
    and exists(Expression/PrimaryExpression/PrimaryPrefix/Name) and not(contains(Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,".")) ]
    /PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)/@Image)
     and (
    (: with an equals method defined at that level with 1 argument and not having a throw statement :)
    ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and not (Block/BlockStatement/Statement/ThrowStatement)]
    (: where names used in equals method matching fields are non-equal to :)
    and not(@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
    [@Name='equals' and MethodDeclarator/FormalParameters/@Size=1]/Block//
    (: name or this.name and name before dot if present :)
    (Name|PrimarySuffix)/(substring-before(concat(@Image, '.'), '.'))) )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; // bad, missing in equals

    public Bad1(String arg2) {
        field2 = arg2;
    }
    public void setField1(String arg1) {
        field1 = arg1;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals uses a field which is missing in hashCode." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah03">
        <description>Problem: Two unequal objects can have the same hashCode and end up in the same bucket of a Map. This may result in bad performance, O(n) lookup instead of O(1).&#13;
            Solution: Use the same fields in hashCode as are used in equals. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) >
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad - missing in hashCode

   public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="NonComparableMapKeys"
          language="java"
          message="Map keys and Set elements should implement Comparable in order to make access fast."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc08">
        <description>Problem: If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access will be slow.
            Solution: Implement Comparable for your Map keys and Set elements. Do not use classes for those which don't implement Comparable, like Thread, Class and Object.
            Note that also equals and hashCode must be implemented properly for the keys/elements, and compareTo must be compatible with equals.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: check key/elem type in declaration :)
//Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.util.Map') or pmd-java:typeIs('java.util.Set')]
(: first type argument does not implement Comparable :)
[TypeArguments/TypeArgument[1]/ReferenceType[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]]
,
(: for when key/elem type ise missing in declaration, check Map.put and Set.add :)
//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.put') and pmd-java:typeIs('java.util.Map')] or
PrimaryPrefix/Name[ends-with(@Image, '.add') and pmd-java:typeIs('java.util.Set')]]
/PrimarySuffix/Arguments/ArgumentList/Expression[1]
(: first arg does not implement Comparable :)
[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]
               ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
    Map<Object, String> oMap; // bad, Object does not implement Comparable
    Map<Thread, String> tMap; // bad, Thread does not implement Comparable
    Set<Thread> clSet; // bad, same reason since Set elements are implemented as Map keys

    Map oldStyleMap = new HashMap(); // cannot check here
    Set oldStyleSet = new HashSet(); // cannot check here

    void putInOldStyleBad() {
        oldStyleMap.put(new Thread(), "value"); // bad
        oldStyleSet.add(new Thread()); // bad
    }

    Map<Comparable, String> cMap; // good

    void putInOldStyleGood() {
        oldStyleMap.put("key", "value");
        oldStyleSet.add("good");
    }
            ]]>
        </example>
    </rule>

    <rule name="OptimizeMapOrSetForEnum"
          language="java"
          message="Map has enum keys or Set has enum elemens, use EnumMap or EnumSet for more efficiency."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc03">
        <description>Problem: A HashMap and HashSet are rather greedy in memory usage.&#13;
            Solution: Use an EnumMap or EnumSet. It is represented internally with arrays which is extremely compact and efficient.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :) (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//LocalVariableDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//Initializer//StatementExpression[Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
[PrimaryExpression//Name/@Image =
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName]]/VariableDeclarator/VariableDeclaratorId/@Name]
]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
Map<YourEnumType, String> map = new EnumMap<>(YourEnumType.class);
Set<YourEnumType> set = EnumSet.allOf(YourEnumType.class);
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalConcatInLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String concatenation (+) is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name[ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or
    ends-with(@Image,'.info')]/../../PrimarySuffix/Arguments/ArgumentList/Expression/AdditiveExpression[pmd-java:typeIs('java.lang.String')]
    [PrimaryExpression/PrimaryPrefix/Name]
    [not(ancestor::IfStatement/Expression/PrimaryExpression/PrimaryPrefix/Name[
        ends-with(@Image,'.isTraceEnabled')
        or ends-with(@Image,'.isDebugEnabled')
        or ends-with(@Image,'.isInfoEnabled')
        or ends-with(@Image,'.isLoggable')
    ])]
]]></value>
            </property>
        </properties>
        <example>
        <![CDATA[
@slf4j
class Foo {
    void bad(String a, String b) {
        log.debug("message: {}", a + b); // bad
    }
    void good(String a, String b) {
        log.debug("message: {}{}", a, b); // good
    }
}
            ]]>
    </example>
    </rule>

    <rule name="UnconditionalCreatedLogArguments"
          language="java"
          message="Avoid unconditional creation of a log argument, it may not be needed."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il06">
        <description>Problem: Creation of a log argument with a toString or other operation(s) may be expensive, while depending on the log level, the result may not be used.&#13;
            Solution: Create the log argument conditionally on the log level, within an if statement. For just 'obj.toString()', just pass 'obj' to the log method and leave it to SLF4J to call toString() only if needed.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name
    (: log levels typically/often not enabled :)
    [ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or ends-with(@Image,'.info')]
    (: no violation if conditionally: only executed if level enabled is okay :)
    [not(ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: no violation if return conditionally before :)
    [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: an argument in the log method :)
    /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
    [
    (: equals a declared var :)
    (PrimaryPrefix/Name[@Image = ancestor::MethodDeclaration//VariableDeclarator
        (: with initializer not like obj.get[Xxx], we assume a simple getter is quick, unless this is in a loop :)
        [not(contains(string-join(./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image, '-'), '.get')
             (: this.field.get[Xxx] case #209 :)
             or ./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix[@Image = '']/../PrimarySuffix[starts-with(@Image, 'get')])
         or ancestor::WhileStatement or ancestor::ForStatement or ancestor::DoStatement]/VariableDeclaratorId/@Name
    (: and it is not used in a return :)
    and (not(@Image = ancestor::Block//ReturnStatement//Name/@Image))
    (: and it is not used in a constructor of a local var :)
    and (not(@Image = ancestor::Block//AllocationExpression//Name/@Image))
    (: and it is not used as an argument in another method call than log :)
    and (not(@Image = ancestor::Block//PrimaryExpression[PrimaryPrefix/Name
        [not(ends-with(@Image, 'trace') or ends-with(@Image, 'debug') or ends-with(@Image, 'info'))]]/PrimarySuffix/Arguments//Name/@Image))
    (: and it is not used in the method in a blockstatement before a '.', like logObj.toString() other than method call argument.
       It is a contains, so a violation is missed when the log arg/declared var e.g. is 'log' and a 'obj.log()' is used :)
    and (not(contains(string-join(ancestor::MethodDeclaration//Name[ancestor::BlockStatement/(Statement|LocalVariableDeclaration)[count(./StatementExpression//PrimarySuffix//ArgumentList//Name/@Image) = 0]]/@Image, '.'), concat(@Image, '.')) ))
    (: method name starts with log, we assume it is called conditionally :)
    and (not(ancestor::MethodDeclaration[starts-with(@Name, 'log')]))
    ])
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    void bad(Object obj) {
      String logObj = obj.toString();
      log.debug("object to String: {}", logObj); //bad
    }

    void good(Object obj) {
      log.debug("object to String: {}", obj); //good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Operation is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.getXXX(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
          //PrimaryPrefix/Name
            (: log levels typically/often not enabled :)
            [
            	ends-with(@Image,'.trace')
            	or ends-with(@Image,'.debug')
            	or ends-with(@Image,'.info')
            ]
            (: no violation if conditionally: only executed if level enabled is okay :)
            [not(ancestor::IfStatement//Name
            	[
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
	        ]
            (: no violation if return conditionally before :)
            [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
                [
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
            ]
	        (: in the log method :)
            /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
            [
                (: toString on argument :)
                PrimaryPrefix/Name[ends-with(@Image,'.toString')]
                or
                (: a method call with an argument list :)
                (PrimarySuffix/Arguments/ArgumentList)
                (: exclude a simple getXXX(i), like list.get(0) or env.getProperty(key), assumed to be fast :)
                and not (PrimaryPrefix/Name[contains(@Image,'.get')])
            ]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
            LOG.debug("customer = {}", customer.toString()); // bad
            LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

            LOG.debug("customer = {}", customer); // good
            if (LOG.isDebugEnabled()) { // good
                LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
            }
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarnings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>(Informative) Problem: This rule detects problems, suppressing them without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so these can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings for a rule that is meant to prevent high risk problems." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>(Informative) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so these can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="ruleIdMatches" type="String" value="AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
        </properties>
    </rule>

<!-- END Included file 'common.xml' -->
<!-- BEGIN Included file 'common_std.xml' -->
    <rule name="AvoidApacheCommonsFileItemNonStreaming"
          language="java"
          message="Avoid memory intensive FileItem.get and FileItem.getString"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio03">
        <description>
            Problem: Use of FileItem.get and FileItem.getString could exhaust memory since they load the entire file into memory&#13;
            Solution: Use streaming methods and buffering.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name
[ends-with(@Image, '.get') or ends-with(@Image, '.getString')]
[
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
)
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class FileStuff {
   private String bad(FileItem fileItem) {
        return fileItem.getString();
   }

   private InputStream good(FileItem fileItem) {
        return fileItem.getInputStream();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendarDateCreation"
          language="java"
          message="A Calendar is used to create a Date or DateTime, this is expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ue01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use 'new Date()', Java 8+ java.time.[Local/Zoned]DateTime.now() or joda time '[Local]DateTime.now()'.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix[Name[ends-with(@Image, 'Calendar.getInstance')]] [count(../PrimarySuffix) > 2 and ../PrimarySuffix[last()-1][@Image = 'getTime' or @Image='getTimeInMillis']]
|
//Block/BlockStatement//Expression/PrimaryExpression/
PrimaryPrefix/Name[pmd-java:typeIs('java.util.Calendar') and (ends-with(@Image,'.getTime') or ends-with(@Image,'.getTimeInMillis'))]
|
//ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.DateTime') or pmd-java:typeIs('org.joda.time.LocalDateTime')][../Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'Calendar.getInstance')]]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class DateStuff {
    private Date bad1() {
        return Calendar.getInstance().getTime(); // now
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
    private long bad2() {
        return Calendar.getInstance().getTimeInMillis();
    }
    private long good2() {
        return System.currentTimeMillis();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConcatInAppend"
          language="java"
          message="Concatenation inside append. Use extra append."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu04">
        <description>Concatenation of Strings is used inside an StringBuilder.append argument. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use an extra fluent append instead of concatenation.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement[
(.//PrimaryExpression/PrimaryPrefix/Name[substring-after(@Image, '.') = 'append']
or
.//PrimaryExpression/PrimarySuffix/@Image = 'append')
and
.//PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression[1]/AdditiveExpression[pmd-java:typeIs('java.lang.String')
and (count(PrimaryExpression/PrimaryPrefix/Name) > 0)
and not(PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=true()]//VariableDeclaratorId/@Name)
and not(PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::Block//LocalVariableDeclaration[@Final=true()]//VariableDeclaratorId/@Name)
]]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class StringStuff {
   private String bad(String arg) {
        StringBuilder sb = new StringBuilder();
        sb.append("arg='" + arg + "'");
        return sb.toString();
   }

   private String good(String arg) {
        StringBuilder sb = new StringBuilder();
        sb.append("arg='").append(arg).append("'");
        return sb.toString();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConcatInLoop"
          language="java"
          message="A String is concatenated in a loop. Use StringBuilder.append."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu02">
        <description>A String is built in a loop by concatenation. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected. &#13;
            Solution: Use the StringBuilder append method.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator[
    (: a += ...;  -- a being a string :)
    @Image='+=' and preceding-sibling::*[1]/PrimaryPrefix/Name[pmd-java:typeIs('java.lang.String')]
    (: a = ... + a + ...; -- a being a string :)
    or @Image='=' and following-sibling::*[1]/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name[
        pmd-java:typeIs('java.lang.String')
        and @Image = ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
    ]
]/.. (: Go up to report on the StatementExpression :)
	]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class StringStuff {
   private String bad(String arg) {
        String log = "";
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            log += val;
        }
        return log;
    }

   private String good(String arg) {
        StringBuilder sb = new StringBuilder();
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            sb.append(val);
        }
        return sb.toString();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidForEachInStreams"
          language="java"
          message="Prefer side-effect-free functions in streams, use forEach only for logging."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr04">
        <description>Problem: Streams is a paradigm based on functional programming: the result should depend only on its input and not update any state.
            Use of forEach is actually iterative code masquerading as streams code. It is typically harder to read and less maintainable than the iterative form.
            Solution: Use the for-each (enhanced-for) loop, or the pure functional form. The forEach operation should only be used to report (i.e. log) the result of a stream computation.
        (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression[(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'forEach')]]
[not (./PrimarySuffix//MethodReference[starts-with(@Image, 'log')] or
./PrimarySuffix//PrimaryPrefix/Name[starts-with(@Image, 'Log')] or
./PrimarySuffix//LambdaExpression//PrimaryPrefix/Name[starts-with(@Image, 'log.')]
)]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
        // forEach in stream
        map = new HashMap<>();
        letters.forEach(l -> map.put(l, 0)); // bad, side effect, modifies map

        // reporting result by logging, good
        letters.forEach(Log::info);

        // iterative form, meant for modifying state, good
        map = new HashMap<>();
        for (String l : letters) {
            map.put(l, 0);
        }

        // pure functional form, good
        map = letters.stream().collect(toMap(l -> l, v -> 0));
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnusedAssignments"
          language="java"
          message="Avoid assignments for which the assigned value is never used."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr04">
        <description>Problem: Assignments to variables for which the assigned value is not used because a new value is assigned before actual use, is unnecessary work and may indicate a bug.
            Solution: remove the first assignment and make sure that is as intended.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: for each local variable declaration or assignment node :)
(for $node in (//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name
| //LocalVariableDeclaration/VariableDeclarator[VariableInitializer]//VariableDeclaratorId)
(: match if for that node the next occurrence of ((assignment without use in same statement) union with (use) is an assignment to the var) :)
return ($node[
(: assignment without use, Name is result :)
((ancestor::BlockStatement/following-sibling::BlockStatement//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name[@Image=$node/@Image]
[not(ancestor::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='=']) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])]
)[1]
|
(: use, PrimaryPrefix is result, so @Image is empty string :)
(ancestor::BlockStatement/following-sibling::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='='] and not(PrimarySuffix/Expression)) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])[1])
(: first is the var name :)
[1]/@Image = $node/@Image])
)
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[

            ]]>
        </example>
    </rule>

    <rule name="LetFieldsMeetSerializable"
          language="java"
          message="Fields in a Serializable class should be serializable or transient."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr02">
        <description>Problem: Field in a Serializable class is not serializable nor transient. When (de)serialization happens, a RuntimeException will be thrown and (de)serialization fails.
            Solution: make the field either transient, make its class implement Serializable or interface extend Serializable.
            Note: Classes extending Throwable do, by inheritance, implement Serializable, yet are excluded in this rule, since they are typically never actually serialized.
            An exception to this exception is when extending RemoteException, then fields should be transient or serializable.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[ImplementsList/ClassOrInterfaceType[@Image='Serializable']
or pmd-java:typeIs('java.io.Serializable')
(: Throwable is the exception, except RemoteException :)
and not(pmd-java:typeIs('java.lang.Throwable') and not(pmd-java:typeIs('java.rmi.RemoteException')))]
(: non-transient, non-static, non-primitive fields :)
//FieldDeclaration[@Transient=false() and @Static=false()][not(.//PrimitiveType)]
[not(pmd-java:typeIs('java.io.Serializable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
(: if has type args, type args which are not serializable like List<String, Thread>):)
and (not(exists(.//TypeArgument/ReferenceType))
or exists(.//TypeArgument/ReferenceType[not(pmd-java:typeIs('java.io.Serializable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))]))
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo implements Serializable {
    String meets;
    Exception exMeets;
    Serializable ser;
    Thread t1NotMeets; // bad, Thread is not serializable
    transient Thread t2meets;
    List<String> listOfStrings = new ArrayList();
    List<Thread> listOfThreads = new ArrayList(); // bad
    Map<String,String> mapToString = new HashMap();
    Map<String,Thread> mapToThread = new HashMap(); //bad
}

class Bar extends Exception {
    Thread t1NotMeets;
    transient Thread t2meets;
}

class Baz extends RemoteException {
    Thread t1NotMeets; // bad
    transient Thread t2meets;
}
            ]]>
        </example>
    </rule>

    <rule name="LimitNestingInLambdas"
          language="java"
          message="Avoid deep nesting of lambdas in lambda expressions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr05">
        <description>Problem: lambda expressions with deep nesting (lambda's in lambda's) are hard to understand and maintain.
            Solution: extract the lambda expression code block(s) into one or more well-named separate method(s).
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="param-max" value="1" type="String" description="Maximum allowed depth of lambda nesting"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//LambdaExpression[count(ancestor::LambdaExpression) > number($param-max)]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private void bar(List<Map<String, BigDecimal>> lines) {
        lines.forEach(line -> line.forEach((key, value) -> values.computeIfPresent(key, (k, v) -> v.add(value)))); // bad, nesting levels 2, > 1
    }
}
            ]]>
        </example>
    </rule>

    <rule name="LimitStatementsInLambdas"
          language="java"
          message="Avoid many statements in lambda expressions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr03">
        <description>Problem: lambda expressions with many statements are hard to understand and maintain.
            Solution: extract the lambda expression code block into one or more well-named separate method(s).
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="param-max" value="5" type="String" description="Maximum number of allowed non-setter statements"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//LambdaExpression
(: number of statements should be limited, setters are ignored. Chained methods are one statement  :)
[(count(.//Statement) - count(.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, '.set')]) > number($param-max))
]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
       void bar(List additionals) {
            additionals.forEach(entity -> {
                if (entity.getKNr() != null) {
                    action.withActions(
                            new Action().withFoId(actionFoId.incrementAndGet())
                                    .withEntityPlanFoId(1)
                                    .withEntity(mapLogicType(true))
                    );
                }
            });
       }

       void baz(List additionals) {
            additionals.forEach(entity -> {         // bad, too many statements (5)
                if (entity.getKNr() != null) {
                    action.withActions(
                            new Action().withFoId(actionFoId.incrementAndGet())
                                    .withEntityPlanFoId(1)
                                    .withEntity(mapLogicType(true))
                    );
                }
                else { action.withActions(new Action().withFoId(0)); }
            });
        }
}
            ]]>
        </example>
    </rule>

    <rule name="LimitWildcardStaticImports"
          language="java"
          message="The number of static imports with a wildcard should be limited"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr01">
        <description>Importing a class statically allows you to use its public static members easily: without qualifying them with the class name. Problem: if you import too many classes statically, your code can become confusing and difficult to maintain. The default maximum = 3.
            Solution: Import class members individually.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="param-max" value="3" type="String" description="Maximum number of allowed static imports with wildcard"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration[@Static=true() and @ImportOnDemand=true()][position() > number($param-max)]
	]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
// With the default threshold value: 3

import static java.lang.Math.*;
import static java.util.Collections.*;
import static com.co.division.Constants.*;
import static com.co.department.Constants.*;  // bad

import static com.co.corporate.Constants.NUTS;
import static com.co.corporate.Constants.CRAZY;
import static com.co.corporate.Constants.FOOLISH;
import static com.co.corporate.Constants.AWESOME; // good
import static com.co.corporate.Constants.GREAT; // good

            ]]>
        </example>
    </rule>

<!-- END Included file 'common_std.xml' -->
<!-- BEGIN Included file 'concurrent.xml' -->
    <rule name="AvoidCommonPoolForBlockingCalls" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the ForkJoinPool::commonPool used in parallelStream for blocking calls."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia09">
        <description>Problem: Blocking calls for instance remote calls, may exhaust the common pool for some time thereby blocking all other use of the common pool.
            In addition, nested use of the common pool can lead to deadlock. Do not use the common pool for blocking calls. The parallelStream() call uses the common pool.&#13;
            Solution: Use a dedicated thread pool with enough threads to get proper parallelism. The number of threads in the common pool is equal to the number of CPUs - 1 and meant to utilize all of them.
            It assumes CPU intensive non-blocking processing of in-memory data.  (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: assumption: if import of web client / http client is present, parallelStreaming is for remote calls :)
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.web.client') or starts-with(@Image, 'org.apache.commons.httpclient')]/
ancestor::CompilationUnit//PrimaryExpression
[(PrimarySuffix/@Image='parallelStream' or ends-with(PrimaryPrefix/Name/@Image, 'parallelStream')
and exists(PrimarySuffix/pmd-java:typeIs('java.util.stream.Stream'))
and not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')]))
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.concurrent.*;
import java.util.stream.*;
import java.util.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    final List<String> list = new ArrayList();
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> storeDataRemoteCall(elem));
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> storeDataRemoteCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(10, TimeUnit.MILLISECONDS));
    }

    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> storeDataRemoteCall(elem))
        ).get();
    }

    String storeDataRemoteCall(String elem) {
        // do remote call, blocking. We don't use the returned value.
        RestTemplate tmpl;
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCommonPoolForFutureAsync"
          message="Avoid using the common thread pool for future.supplyAsync, use a separate pool."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia08">
        <description>
            Problem: Future.supplyAsync is typically used for remote calls. By default, it uses the common pool.
            The number of threads in the common pool is equal to the number of CPU's, which is suitable for in-memory processing.
            For I/O, however, this number is typically not suitable because most time is spent waiting for the response and not in CPU.
            The common pool must not be used for blocking calls. &#13;
            Solution: A separate, properly sized, pool of threads (an Executor) should be used for the async calls.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name[@Image='CompletableFuture.supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
,
//PrimaryPrefix/Name[@Image='supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
[/CompilationUnit/ImportDeclaration/Name[@Image = 'java.util.concurrent.CompletableFuture.supplyAsync']]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private final ExecutorService asyncPool = Executors.newFixedThreadPool(8);

    void bad() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account))) // bad
         .toArray(CompletableFuture[]::new);
    }

    void good() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account), asyncPool)) // good
         .toArray(CompletableFuture[]::new);
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
  //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.take')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.')))
]    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get')]
    (: future.get or variant called on formal param :)
    [(exists(index-of((ancestor::MethodDeclaration//FormalParameter[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on local var :)
    exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on field :)
    exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    )
    (: .get without arguments :)
    and not(../../PrimarySuffix/Arguments/ArgumentList)
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public static String bad(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(); // bad
    }

    public static String good(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(10, TimeUnit.SECONDS); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidFutureJoinWithoutTimeout"
          message="Avoid future.join without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia07">
        <description>
            Problem: Stalls indefinitely in case of hanging thread(s) and consumes a thread.&#13;
            Solution: Provide a timeout before the join and handle the timeout. For example a future.get(timeout, unit), a orTimeout() or a completeOnTimeout(). You may want to use CompletableFuture.allOf() too.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: future.join method reference without timeout in method :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')
and not(ancestor::MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')][../../PrimarySuffix//ArgumentList])
]
/../PrimarySuffix//MethodReference[@Image='join']
,
(: future.join in lambda without timeout in method :)
//PrimaryExpression/PrimaryPrefix/LambdaExpression//Name[ends-with(@Image, '.join')
and not(ancestor::MethodDeclaration//PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')]
[../../PrimarySuffix//ArgumentList])
]
(: join has no arguments, #198 :)
[../../PrimarySuffix/Arguments[@Size=0]]
,
(: CompletableFuture.allOf(futures).join() without timeout :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/../PrimarySuffix[@Image='join'
and not(ancestor::MethodDeclaration//PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')])]
(: join has no arguments, #198 :)
[../PrimarySuffix/Arguments[@Size=0]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    private List<Order> getOrdersBad(List<CompletableFuture<Order>> getOrdersFutures) {

        List<Order> orders = getOrdersFutures.stream()
            .map(CompletableFuture::join) // bad, NO timeout provided above
            .collect(Collectors.toList());
        return orders;
    }

    private List<Order> getOrdersGood(List<CompletableFuture<Order>> getOrdersFutures) {
        // added to deal with timeout
        CompletableFuture<Void> allFuturesResult = CompletableFuture.allOf(getOrdersFutures.toArray(new CompletableFuture[getOrdersFutures.size()]));
        try {
            allFuturesResult.get(5L, TimeUnit.SECONDS); // good
        } catch (Exception e) { // should make explicit Exceptions
            //log error
        }
        List<Order> orders = getOrdersFutures.stream()
                .filter(future -> future.isDone() && !future.isCompletedExceptionally()) // keep only the ones completed -- added to deal with timeout
                .map(CompletableFuture::join) // good, timeout provided above
                .collect(Collectors.toList());
        return orders;
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidIncrementOrDecrementForVolatileField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ++, --, +=, -= for volatile fields" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc09">
        <description>A compound statement like i++, i--, i += 1 or i -= 1 may seem one statement and thread-safe for a volatile field. Problem: The operation is actually two separate statements executed non-atomically and therefore not thread-safe. &#13;
            Solution: Guard the field properly with synchronized or use atomics like AtomicInteger. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/(AssignmentOperator[@Image='+=' or @Image='-=']/..|
(PreIncrementExpression|PostfixExpression[@Image='++' or @Image='--']))/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[@Image =
//FieldDeclaration[@Volatile = true()]/VariableDeclarator/VariableDeclaratorId/@Name]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Foo {
    private volatile int i;
    private volatile String str = "";

    public int bad() {
        i++; // bad
        --i; // bad
        i += 1; // bad
        str += "a"; // bad
    }
    public int good(int v) {
        i = 5; // good
        i = v + 5; // good
        str = "other"; // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and @GuardedBy or use volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: static field, non-final, non-volatile, non-guarded by :)
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[@Static=true() and @Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]
,
(: static field, non-guarded, some often used known mutable types, declaration side :)
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true()]/Type/ReferenceType/ClassOrInterfaceType[
(((pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL')) or pmd-java:typeIs('java.io.File'))
 or (ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0]))
 and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='GuardedBy'])
])
,
(: static field, non-guarded, some often used known collection/array types, allocation side:)
(//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true() and not (../Annotation//Name[@Image='GuardedBy'])]/
VariableDeclarator/VariableInitializer[((ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0)
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[ArrayDimsAndInits and xs:int(ArrayDimsAndInits and (xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0 or ArrayDimsAndInits/Expression//Name))]
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[(pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet'))]
or Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='Arrays.asList']
)])
,
(: static-block allocations of non-empty arrays :)
//Initializer//AllocationExpression[((ArrayDimsAndInits and ((xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0) or exists(ArrayDimsAndInits/Expression//Name) or exists(ArrayDimsAndInits/ArrayInitializer//Expression)))
or
(: static-block allocations of known mutable types :)
ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet') or pmd-java:typeIs('java.util.EnumMap')])
and
(: given the field is not @GuardedBy :)
ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='GuardedBy']) = 0]/FieldDeclaration//VariableDeclaratorId/@Name
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    enum Bad {
        VAL1;
        static final Map<String, Bad> STRING_TO_ENUM = new HashMap<>(); // bad
    }
    enum Good {
        VAL1;
        static final Map<String, Good> STRING_TO_ENUM; // good
        static {
            Map<String, Good> map = new HashMap<>();
            STRING_TO_ENUM = Collections.unmodifiableMap(map);
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidNonPrivateFieldsInSharedObjects"
          message="Avoid non-private objects shared among threads. Make fields private to ensure thread-safety."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc11">
        <description>
            Problem: A singleton, or more general: an object shared among threads, has a field that is not private.
            These field can possibly be modified from other classes.&#13;
            Solution: Make the fields private.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[
    (
      @Image='Component'
      or @Image='Service'
      or @Image='Controller'
      or @Image='RestController'
      or @Image='Repository'
      or (@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN'])
    )
    (: not shared when request or prototype scope :)
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
    (: if @NotThreadSafe no checking :)
    and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
]
(: non-static, non-final and non-private fields :)
/../../../ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Private=false() and @Final=false()]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidParallelStreamWithCommonPool" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Beware: parallelStream with the common pool is rarely a good choice."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia11">
        <description>Problem: Collection.parallelStream uses the common pool, with #threads = #CPUs - 1. It is designed to distribute much CPU work over the cores. It is not for remote calls or other blocking calls.
            In addition, parallelizing has overhead and risks, should only be used for much pure CPU processing.&#13;
            Solution: For remote/blocking calls: Use a dedicated thread pool with enough threads to get proper parallelism independent of the number of cores.
            For pure CPU processing: use ordinary sequential streaming unless the work takes more than about 0,1 ms in sequential form and proves to be faster with parallelization.
            So only for large collections and much processing without having to wait.   (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/(PrimarySuffix[@Image='parallelStream' or @Image='parallel']|PrimaryPrefix/Name[ends-with(@Image, '.parallelStream') or ends-with(@Image, '.parallel')])
(: and exists(PrimarySuffix[pmd-java:typeIs('java.util.stream.Stream')]) - with 'var' type is lost in typeIs :)
(: no arguments :)
[following::PrimarySuffix[1][@ArgumentCount = 0]]
[not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')])]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class Foo {
    final Map<String, String> map = new HashMap();
    final List<String> list = new ArrayList();
    final List<String> hugeList = new ArrayList(); //1000+ elements
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> someCall(elem)); //bad
    }
    void bad2() {
        map.entrySet().parallelStream().forEach(entry -> someCall(entry.getValue())); //bad
    }
    void exceptionalProperUse() {
       hugeList.parallelStream().forEach(elem -> heavyCalculations(elem)); //flagged but may be good, should suppress when proven to be faster than sequential form
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> someCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(3, TimeUnit.SECONDS);
    }
    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> someCall(elem))
        ).get();
    }

    String someCall(String elem) {
        // do some call, don't know if remote or blocking. We don't use the returned value.
        return "";
    }

    String heavyCalculations(String elem) {
        // calculate a lot
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidStaticXmlFactories" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid static XML Factories" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOXAR09">
        <description>An XML Factory like DocumentBuilderFactory, TransformerFactory, MessageFactory is used as static field. Problem: These factory objects are typically not thread-safe and rather expensive to create because of class loading. &#13;
            Solution: Create the Factories as local variables and use command line arguments to specify the implementation class. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBodyDeclaration//FieldDeclaration[@Static=true() and (
    pmd-java:typeIs('javax.xml.parsers.DocumentBuilderFactory') or
    pmd-java:typeIs('javax.xml.parsers.SAXParserFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLInputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLOutputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLEventFactory') or
    pmd-java:typeIs('javax.xml.transform.TransformerFactory') or
    pmd-java:typeIs('javax.xml.validation.SchemaFactory') or
    pmd-java:typeIs('javax.xml.datatype.DatatypeFactory') or
    pmd-java:typeIs('javax.xml.soap.MessageFactory')
    )]
			]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
 public class Bad {
    private static final DocumentBuilderFactory DB_FACTORY = DocumentBuilderFactory.newInstance(); // shared, bad
 }

 public class Good {
    public build() {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); // local var, good
        // use dbFactory
    }
 }
            ]]>
        </example>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[pmd-java:typeIs('javax.xml.bind.Marshaller')
 or pmd-java:typeIs('javax.xml.bind.Unmarshaller')
 or pmd-java:typeIs('javax.xml.bind.Validator')
 or pmd-java:typeIs('javax.xml.validation.Validator')]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded assignments to non-final fields in objects using synchronized. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. In case you are sure the class is used in single threaded context only, remove current use of synchronized and annotate the class with @NotThreadSafe to make this explicit. &#13;
            2. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: assignment to a field :)
/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            4. Use synchronized for accessors to inherited fields, or better: make field private and use proper accessors on base class level using @GuardedBy.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: assignment to a field :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[(@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
or
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), @Image))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), @Image))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()])
or ancestor::MethodDeclaration[@Name='afterPropertiesSet']
)]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded non-final or mutable fields in objects using synchronized. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the class is used in single threaded context only, annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: non-final and non-volatile fields :)
/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: mutable types not annotated with GuardedBy :)
) and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInSharedObjects"
          message="Avoid unguarded non-final or mutable fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
(: not shared when request or prototype scope :)
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
    or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: ConfigurationProperties assumed executed only once, no violation, except if Lombok Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: non-final and non-volatile fields :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment level annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: not annotated GuardedBy :)
)
and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableInheritedFieldsInSharedObjects"
          message="Mutator method called on inherited field. Avoid unguarded mutable inherited fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a (inherited) field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mixup session data. &#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: primary expression used :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//../PrimaryExpression//PrimaryPrefix/Name[(
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(:  has arguments (a method call), and  a compound like date.setTime, map.put, list.set :)
(contains(@Image, '.set') or contains(@Image, '.put') or contains(@Image, '.clear') or contains(@Image, '.add') or contains(@Image, '.remove') or contains(@Image, '.replace')) and
(: not starting with a capital, a Class :)
not (starts-with(@Image, upper-case(substring(@Image, 1, 1)))) and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: expression not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not used in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUserDataInSharedObjects" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do *not* use user data in shared objects, it causes user data mix-up."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ssc03">
        <description>The name of the field indicates user data. Problem: the field will be shared among users. If it is different data for each user, it can mix-up: a user may access data of another user, this is really bad.&#13;
            Solution: Do *not* put the user related data in a shared object e.g. by Spring @Component annotation. Use a POJO. Or, if it is not user data, rename the field. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/ancestor::TypeDeclaration//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Static=false()][Type/ReferenceType][ancestor::ClassOrInterfaceDeclaration[1][@Static=false()]]/VariableDeclarator/VariableDeclaratorId[matches(@Name,
'User[Id|Ref|Reference]*$|Customer[Id|Ref|Reference]*$|Session[Id|Ref|Reference]*$|Order[Id|Ref|Reference|List]*$|Account[Id|Ref|Reference|List]*$|Transaction[Id|Ref|Reference|List]*$|Contract[Id|Ref|Reference|List]*$', 'i')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Component
@Data
public class VMRData {
    private String channel;
    private String vmrId;
    private List<OrderDetails> orderList; // bad
    private Headers headers;
    private List<OrderReference> ordersRequiringAdditionalSignature;
    private String authUser; // bad
    private String executionDate;
    private String minimumLevel;
    private String sessionId; // bad
    private String payloadData;
    private String vmrUserId; // bad
    private String userref; // bad
    private String customerReference; // bad
    private String contract; // bad
}

@Component
@Setter
@Getter
 class VMROrderDetails {
    private static final String DESC_OF_ORDER = "order details"; // ok
    private final VMROrderDetails finalOrder = new VMROrderDetails(); // ok
    private OrderReference orderReference; // bad
    private Account originatorAccount; // bad
    private Amount amount;
    private String action;
    private List<CancellationHistory> cancellationHistories;
    private String modifyType;
    private String order; // bad
    private String transactionRef; // bad
}

]]>
        </example>
    </rule>

    <rule name="AvoidVolatileInPrototypeScope" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="No need for volatile in prototype scope" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc10">
        <description>A field is defined as volatile while the class has prototype scope. Problem: volatile has some overhead, especially for writes. When getting the bean from the Spring applicationContext, prototype scope means that each invocation creates a new object so the field is not shared. &#13;
            Solution: Since only one thread can access the field, there is no need for violatile and it can be removed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //FieldDeclaration[@Volatile = true() and
    ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix/
    (Name[ends-with(@Image,'SCOPE_PROTOTYPE')]|Literal[contains(@Image, 'prototype')])]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Bad {
    private volatile String id;
}

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Good {
    private String id;
}
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnFieldWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy(field)"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which the GuardedBy annotation is applied is not accessed thread-safely as described by GuardedBy.&#13;
            Solution: Make access thread-safe: synchronize access by a synchronized(LOCK) block with LOCK being a final field.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded-by literal *IS* a field (should be private final) :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[substring(@Image, 2, (string-length(@Image) - 2))=
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS NOT* in a synchronized block with the GuardedBy literal:)
    and (not(concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
    ,
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded by literal *IS NOT* a field :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[not (substring(@Image, 2, (string-length(@Image) - 2)) =
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name)
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS* in a synchronized block with the GuardedBy literal:)
    and (
    (concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() { return txt; } // bad
        public synchronized void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() {
            synchronized(LOCK) { return txt; }
        }
        public void setText(String t) {
            synchronized(LOCK) { txt = t; }
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnThisWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy('this')"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which this annotation is applied should only be accessed when holding the built-in 'this' lock by using synchronized.&#13;
            Solution: Make access thread-safe: synchronize access by method modifier or a synchronized(this) block.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[(@Synchronized=false() or @Static=true())
and not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
//PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
(ancestor::ClassOrInterfaceBody|ancestor::EnumBody)//Annotation//Name[@Image='GuardedBy']/..//Literal[@Image='"this"']/
ancestor::ClassOrInterfaceBodyDeclaration/FieldDeclaration//VariableDeclaratorId/@Name
and (
not (ancestor::SynchronizedStatement)
or ancestor::SynchronizedStatement/Expression//Name)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        @GuardedBy("this")
        private String txt;

        public String getText() { return txt; } // bad
        public void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        @GuardedBy("this")
        private String txt;

        public synchronized String getText() { return txt; }
        public synchronized void setText(String t) { txt = t; }
    }
            ]]>
        </example>
    </rule>

    <rule name="SynchronizingForLocalVars" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Local variables don't need synchronization" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc12">
        <description>In the synchronized block, only local variables seem to be accessed. Problem: synchronization has overhead and may introduce lock contention. &#13;
            Solution: Remove synchronized because local variables are only accessible by the owning thread and are not shared. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: var.x() in synchronized block, var in list of local vars and all var.x in synchronized block are local vars:)
//SynchronizedStatement[count(./Block//PrimaryPrefix/Name[
    index-of(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name, substring-before(@Image, '.')) >= 0]) =
count(./Block//(PrimaryPrefix/Name|PrimarySuffix)[substring-before(@Image, '.')])
and
(: vars used in synchronized block are all local vars :)
count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name |
     ./Block//(PrimaryPrefix/Name|PrimarySuffix)[@Image != '' and not(contains(@Image, '.'))]/@Image))
 = count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name ))]
                        ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private Map<String, String> mapField;

    protected Map<String, String> bad() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) { // bad
          if (addHeaders == null) {
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }

  protected Map<String, String> good() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) {
          if (mapField == null) {
              mapField = new HashMap<>();
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'concurrent.xml' -->
<!-- BEGIN Included file 'enterprise.xml' -->
    <rule name="DefineConcurrencyForJavaEESingleton"
      message="For JavaEE @Singleton, make @ConcurrencyManagement explicit and define @Lock on class level or for all public methods."
      class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
      typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
    <description>
        Problem: A JavaEE @Singleton has default @ConcurrencyManagement CONTAINER and write locks. Using defaults is unclear and write locks typically cause much more contention than read locks. &#13;
        Solution: Make @ConcurrencyManagement and @Lock-s explicit, @Lock on class level or on all public methods.&#13;
        (jpinpoint-rules)</description>
    <priority>3</priority>
    <properties>
        <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
        <property name="version" value="2.0"/>
        <property name="xpath">
            <value>
                <![CDATA[
//TypeDeclaration/Annotation//Name[@Image='Singleton' and (not (ancestor::TypeDeclaration/Annotation//Name[@Image='ConcurrencyManagement'])
or (ancestor::TypeDeclaration/Annotation//Name[@Image='ConcurrencyManagement' and ../MemberValue//Name[@Image='ConcurrencyManagementType.CONTAINER']] and
((not (ancestor::TypeDeclaration/Annotation//Name[@Image='Lock']))
and (count(ancestor::TypeDeclaration//MethodDeclaration[@Public=true() and not(exists(../Annotation//Name[@Image='Lock'])) ]) > 0))
))]
                ]]>
            </value>
        </property>
    </properties>
    <example>
        <![CDATA[
@Singleton // bad - 1. @ConcurrencyManagement missing 2. @Lock missing on public method
class SingletonBad {
    private String state;
    public String getState() {
        return state;
    }
    @Lock(LockType.WRITE)
    public void setState(String newState) {
        state = newState;
    }
}
@Singleton
@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)
class SingletonGood {
    private String state;
    @Lock(LockType.READ)
    public String getState() {
        return state;
    }
    @Lock(LockType.WRITE)
    public void setState(String newState) {
        state = newState;
    }
}
]]>
    </example>
</rule>

<!-- END Included file 'enterprise.xml' -->
<!-- BEGIN Included file 'remoting.xml' -->
    <rule name="AvoidClientHttpRequestFactorySupplier" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid use of ClientHttpRequestFactorySupplier."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi17">
        <description>Problem: The org.springframework.boot.web.client.ClientHttpRequestFactorySupplier may return a HttpComponentsClientHttpRequestFactory which you supply as @Bean, however,
            this can silently go wrong and e.g. an unconfigured SimpleClientHttpRequestFactory can be returned.
            Default pool size and timeouts will be used, possibly resulting in very slow connection use.&#13;
            Solution: Provide your own supplier with explicit pool sizing and timeouts by a class implementing Supplier. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[@Image='ClientHttpRequestFactorySupplier']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.boot.web.client')]]]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.boot.web.client.ClientHttpRequestFactorySupplier;
import org.springframework.web.client.RestTemplate;

class Bad {
    void bad() {
        RestTemplate restTemplate = new RestTemplateBuilder(rt -> rt.getInterceptors()
               .add((request, body, execution) -> {
                   request.getHeaders().add("SomeKey", someKey);
                   return execution.execute(request, body);
               }))
               .requestFactory(new ClientHttpRequestFactorySupplier()) // bad
               .uriTemplateHandler(defaultUriBuilderFactory)
               .build();
       return restTemplate;
    }
}

class MyClientHttpRequestFactorySupplier implements Supplier<ClientHttpRequestFactory> {

    public ClientHttpRequestFactory get() {
           PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();
           poolingHttpClientConnectionManager.setDefaultMaxPerRoute(MAX_CONN_PER_ROUTE);
           poolingHttpClientConnectionManager.setMaxTotal(MAX_CONN_TOTAL);

           CloseableHttpClient httpClient = HttpClients.custom()
                 .setConnectionManager(poolingHttpClientConnectionManager)
                 .disableConnectionState()
                 .build();
           return new HttpComponentsClientHttpRequestFactory(httpClient);
    }
}
and use it to replace the bad line in Bad example:
            .requestFactory(new MyClientHttpRequestFactorySupplier()) // good
]]>
        </example>
    </rule>

    <rule name="AvoidDeprecatedHttpConnectors" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid the use of deprecated/thread-unsafe HTTP connectors" typeResolution="true"
      externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi06" >
    <description>Problem: Several HTTP client connection managers are thread-unsafe which may cause session data mix-up or have other issues for which they were made deprecated.&#13;
        Solutions: Upgrade to httpclient-4.5+ and use org.apache.http.impl.conn.PoolingHttpClientConnectionManager and e.g. org.apache.http.impl.client.HttpClientBuilder. (jpinpoint-rules)</description>
    <priority>2</priority>
    <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
        <property name="version" value="2.0"/>
        <property name="xpath">
            <value><![CDATA[
//ImportDeclaration/Name[@Image='org.apache.commons.httpclient.SimpleHttpConnectionManager'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.http.impl.conn.PoolingClientConnectionManager'
or @Image='org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager'
or @Image='org.apache.http.impl.conn.SingleClientConnManager'
or @Image='org.apache.http.impl.client.DefaultHttpClient'
or @Image='org.apache.http.impl.client.SystemDefaultHttpClient'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.commons.httpclient.MultiThreadedHttpConnectionManager'
]
|
//ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.client.DefaultHttpClient')
or pmd-java:typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.commons.httpclient.MultiThreadedHttpConnectionManager')
]
|
//AllocationExpression[pmd-java:typeIs('org.apache.commons.httpclient.HttpClient')
]
		     ]]></value>
        </property>
    </properties>
        <example>
            <![CDATA[
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager; // bad
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;

public class Bad {
    private MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager(); // bad
}
class Good {
    private PoolingHttpClientConnectionManager mgr = new PoolingHttpClientConnectionManager();
}
            ]]>
        </example>
</rule>

    <rule name="AvoidDeprecatedHystrix" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Netflix Hystrix is deprecated. Use an alternative like resilience4j"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi11">
        <description>Problem: Hystrix is not actively maintained anymore.&#13;
            Solution: Netflix recommends to use open source alternatives like resilience4j. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[starts-with(@Image, "com.netflix.hystrix")]
]]>
                </value>
            </property>
        </properties>
        <example>
        </example>
    </rule>

    <rule name="AvoidDiscardingHttpClientConfig" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not replace the configured httpClient provided in the constructor of the factory."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi15">
        <description>Problem: Apache HttpComponentsClientHttpRequestFactory has a constructor which takes a HttpClient and also a setter: setHttpClient.
            If you use both on the same factory, you discard all configuration done on the one provided in the constructor because it is replaced by the one provided to the setter.  &#13;
            Solution: Don't use both on the same factory, provide the HttpClient only once to the factory. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Statement[StatementExpression[//ArgumentList]/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableDeclarator[.//AllocationExpression/ClassOrInterfaceType[@Image='HttpComponentsClientHttpRequestFactory'][..//ArgumentList]]
    /VariableDeclaratorId/concat(@Name, '.setHttpClient')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create()
                .setMaxConnTotal(config.getMaxTotalConnections())
                .setMaxConnPerRoute(config.getMaxConnPerRoute())
                .build());

        factory.setHttpClient(createHttpClient(config)); //bad
        return factory;
    }
}

class Good {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory =
            new HttpComponentsClientHttpRequestFactory(createFullyConfiguredHttpClient(config));
        return factory;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidHttpHostOneArgumentConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the HttpHost constructor with only hostname, provide port number and protocol as well."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi16">
        <description>Problem: the HttpHost constructor with one argument must only be provided with a host name, the default port 80 and protocol http are implied.
            The mistake of providing a URL and assuming it will be parsed into hostname, port and protocol is easily made.
            When this HttpHost is then used for a route and stored socketConfig for, port 80 is added for the host and the socketConfig is stored with the wrong key and will not be used.
            It is typically difficult to find out if the config is actually used. Note that http://github.com/jborgers/http-client-monitor helps here.&#13;
            Solution: Use the HttpHost constructor with 2 (including port) or preferably 3 arguments (including port and protocol). (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression[pmd-java:typeIs("org.apache.http.HttpHost")]/Arguments/ArgumentList[count(./Expression) = 1]/../..
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.HttpHost;

class Foo {
    private static final String URL = "localhost:8080";
    private static final HttpHost hostBad1 = new HttpHost("localhost:8080"); // bad

    void bar() {
        HttpHost hostBad2 = new HttpHost(URL);//bad
        HttpHost hostGood1 = new HttpHost("localhost", 8080, "http"); //good
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidJAXBUtil"
          language="java"
          message="The JAXB utility class is not optimized for performance."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXB utility methods do not reuse JAXBContext when more that one context is used. &#13;
            Solution: use JAXB API directly for marshalling and unmarshalling to gain all the performance benefits as described in IUOXAR04 and IUOXAR06.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('javax.xml.bind.JAXB')]
	         ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class XMLConversion {
    public <T> T myUnmarshal(final Source response, final Class<T> clazz) {
        return JAXB.unmarshal(response, clazz); // bad
    }
    public void myMarshal(final Object response, StringWriter stringWriter) {
        JAXB.marshal(response, stringWriter); // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLeakingRetryEventConsumers"
          message="Avoid leaking of retry event consumers."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml06">
        <description>Problem: A resilience4j retry event consumer is added to a retry event publisher for every method call. Likely a lambda retaining one or more objects.
            This will result in a growing list of consumers: a memory leak. Besides, the event will be sent to the growing number of consumers, taking more and more CPU time.&#13;
            Solution: Only call EventPublisher.onRetry (that is, add a consumer) in the same scope as the Retry instance lives. Note there is no way to unregister a consumer.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[pmd-java:typeIs('io.github.resilience4j.retry.Retry') and ends-with(@Image, '.getEventPublisher')]
(: any on-method: onRetry, onError, .. :)
[../../PrimarySuffix[starts-with(@Image, 'on')]]
(: it is a field :)
[exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('io.github.resilience4j.retry.Retry')]
/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.Retry;

public class Foo {
    Retry retryField;
    RetryRegistry reg;
    final AtomicInteger retryCountField = new AtomicInteger();

    Foo() {
        retryField = reg.retry("one per service");
        retryField.getEventPublisher().onRetry(event -> retryCountField.getAndIncrement()); // good
    }

    void callService() {
        AtomicInteger retryCountLocal = new AtomicInteger();
        retryField.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // bad, lambda and AtomicInt leak

        Retry retryLocal = reg.retry("one per method call");
        retryLocal.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // good, no leak

        // same for onSuccess, onError, onIgnoredError
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidModifyingObjectMapper" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="ObjectMapper is configured/modified, only initialize it right after construction."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuojar02">
        <description>Problem: ObjectMapper is thread-safe only after configuration. Configuring an ObjectMapper is not thread-safe.  &#13;
            Solution: Avoid configuring objectMappers except when initializing: right after construction. It is recommended to create ObjectReaders and ObjectWriters from ObjectMapper and pass those around since they are immutable and therefore thread-safe. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: exclude method annotated with PostConstruct :)
//ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='PostConstruct']) = 0]
(: exclude factory where config is in method returning 'this' and one method, typically build(), returning objectMapper :)
/MethodDeclaration[count(Block//ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix[@ThisModifier=true()])=0
or ancestor::ClassOrInterfaceBody[count(.//MethodDeclaration/ResultType/Type[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]) != 1]]
(: modify operations on objectMapper in a method where objectMapper is a formal parameter or field :)
//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::MethodDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration)[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
,
(: modify operations on objectMapper in a constructor where objectMapper is a formal parameter or static field :)
//ConstructorDeclaration//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::ConstructorDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration[@Static=true()])[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public class OldStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper();
        private final ObjectMapper mapperField = new ObjectMapper();

        static {
            staticObjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        public OldStyle() {
            mapperField.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        ObjectMapper bad(ObjectMapper mapper) {
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // bad
            return mapper;
        }
    }

    public class NewStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidObjectMapperAsField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ObjectMapper as field, use ObjectReader or ObjectWriter instead."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuojar02">
        <description>Problem: Configuring an ObjectMapper is thread-unsafe.  &#13;
            Solution: Create ObjectReaders and ObjectWriters from ObjectMapper and only share those as field, since they are immutable and therefore thread-safe.
            Exceptions: A convertValue method is not provided by ObjectReader nor ObjectWriter, therefore in those cases this rule is not applied.
            Also when used like jaxMsgConverter.setObjectMapper(objectMapper) it is not considered a violation. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(for $node in (//FieldDeclaration[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
(: if class not in classpath, can use following line :)
(:or (Type//ClassOrInterfaceType[@Image='ObjectMapper'] and //ImportDeclaration/Name[starts-with(@Image, 'com.fasterxml.jackson.databind.')]):)
]//VariableDeclaratorId)
(: exception: do not match if that field name is used in its class with a convertValue method :)
return ($node[not(ancestor::ClassOrInterfaceDeclaration//PrimaryPrefix/Name[@Image = concat($node/@Name, '.convertValue')])
(: exception: do not match if used with jaxMsgConverter.setObjectMapper(objectMapper) :)
and not($node/@Name = ancestor::ClassOrInterfaceDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, 'setObjectMapper')]]
(:[pmd-java:typeIs('org.springframework.http.converter.json.MappingJackson2HttpMessageConverter')] - somehow class resolution fails :)
/PrimarySuffix//PrimaryPrefix/Name/@Image)
]))
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public class BadStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper(); // bad
        private final ObjectMapper mapperField = new ObjectMapper(); //bad
    }

    class GoodStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidReactorDebugOverhead" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not use Reactor debugging in production, it has much overhead."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi14">
        <description>Problem: For troubleshooting Reactor, Blockhound can be used. It needs proper stack traces which can be achieved by Hooks.onOperatorDebug(). This can have much CPU overhead. &#13;
            Solution: Remove Hooks.onOperatorDebug() when not debugging. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('reactor.core.publisher.Hooks')]//Name[ends-with(@Image, 'Hooks.onOperatorDebug')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.Hooks;

public class Foo {
    public void bar() {
        Hooks.onOperatorDebug(); //bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="An HttpClient is created and combined with request-response."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi12">
        <description>Problem: Apache HttpClient with its connection pool and timeouts should be setup once and then used for many requests. It is quite expensive to create and can only provide the benefits of pooling when reused in all requests for that connection.&#13;
            Solution: Create/build HttpClient with proper connection pooling and timeouts once, and then use it for requests. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration[count(.//Annotation//Name[@Image='Configuration']) = 0]
    //MethodDeclaration//VariableInitializer//Name[
    @Image='HttpClientBuilder.create' or @Image='HttpClients.custom' or @Image='HttpAsyncClientBuilder.create']
    [ancestor::MethodDeclaration//ClassOrInterfaceType[@Image='HttpEntity' or @Image='ResponseEntity']]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {
    ResponseEntity<Object> connectBad(Object req) {
        HttpEntity<Object> requestEntity = new HttpEntity<>(req);

        HttpClient httpClient = HttpClientBuilder.create().setMaxConnPerRoute(10).build(); // bad
        return remoteCall(httpClient, requestEntity);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidXMLGregorianCalendar" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XMLGregorianCalendar is used. It is slow in JAXB." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar05">
        <description>Problem: XMLGregorianCalendar is a large object, involving substantial processing. It is created with the poorly performing DatatypeFactory.
            Solution: Add a converter for alternative date handling with joda-time or Java 8 java.time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>

            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AxualProducerCreatedForEachMethodCall"
          message="An Axual (Kafka) producer is created for each method call, which is expensive and takes resources."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia10">
        <description>Problem: each Producer takes threads and memory. If you create it in each method call, and call this frequently, it will result in an explosion of threads and memory used and lead to Out Of Memory Error.  &#13;
            Solution: Since the Axual Producer is thread-safe, it should be shared e.g. from a static field.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//VariableDeclarator[pmd-java:typeIs('io.axual.client.producer.Producer')]
[ancestor::TypeDeclaration[count(./Annotation//Name[@Image='Configuration'])=0]]
			]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.axual.client.producer.Producer;

public class AxualProducerBad {
    public void publishToEventStream() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig); // bad
        producer.produce(msg);
    }
}

class AxualProducerGood1{
    private static final Producer<String, String> producer = AxualClient.buildProducer(producerConfig);
}

@Configuration
class AxualProducerGood2{
    public Producer<String, String> axualProducer() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig);
        return producer;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferingClientHttpRequestFactoryIsMemoryGreedy" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="BufferingClientHttpRequestFactory is memory greedy. Only use when multiple reads of the response body cannot be avoided."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi18">
        <description>org.springframework.http.client.BufferingClientHttpRequestFactory is used.
            Problem: It buffers all incoming and outgoing streams fully in memory which may result in high memory usage. &#13;
            Solution: Avoid multiple reads of the response body so it is not needed. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: somehow typeIs does not work with spring-web-6.0, do it old school way :)
//AllocationExpression/ClassOrInterfaceType[@Image='BufferingClientHttpRequestFactory']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.http.client')]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.http.client.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    public RestTemplate createMemoryGreedyRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(new BufferingClientHttpRequestFactory(factory)); // bad
    }

    public RestTemplate createStreamTroughRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(factory); // good
    }
}
]]>
        </example>
    </rule>

    <rule name="DefaultFeignClientWithoutTLSConnectionReuse" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Default Feign client is used with (mutual) TLS. This is HttpURLConnection that creates a new connection for each call with TLS overhead." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi21">
        <description>Problem: the default http client of Feign is java.net.HttpURLConnection that does not pool connections when using mutual TLS. This causes connection handshake overhead: extra CPU usage and higher latency.&#13;
            Solution: switch to a Feign client that supports HTTP connection pooling with mTLS, for instance Apache HttpClient 4 with disableConnectionState and proper connection pool size and timeouts. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: default client constructor with sslSocketFactory :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('feign.Client.Default')
and not(ancestor::Expression//Arguments[ArgumentList/@Size=2]//Expression[1]//NullLiteral)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import feign.Client;

public class MyFeignClient {

    public Client createClient(SSLSocketFactory sslSocketFactory){
        return new Client.Default(sslSocketFactory, null); // bad
    }

    public Client createClient(){
        return new Client.Default(null, null); // good
    }

    public Feign.Builder feignBuilder() {
        Client feignClient =
            new Client.Default(setupSSLContextForMutualTLS().getSocketFactory(), new DefaultHostnameVerifier()); // bad
        return Feign.builder().client(feignClient);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="GsonCreatedForEachMethodCall" message="A Gson object is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOJAR03">
        <description>Problem: Gson creation is relatively expensive. A JMH benchmark shows a 24x improvement reusing one instance. &#13;
            Solution: Since Gson objects are thread-safe after creation, they can be between threads. So, reuse created instances, from a static field. Pay attention
            to use thread-safe (custom) adapters and serializers.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	pmd-java:typeIs('com.google.gson.Gson')
	and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
    pmd-java:typeIs('com.google.gson.GsonBuilder')
    and ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'create')]
    and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="HttpClientBuilderPoolSettingsIgnored" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used with a ConnectionManager and MaxConn settings on the client are ignored. Remove them." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi09">
        <description>Problem: If you use setConnectionManager, the connection pool must be configured on that Connection Manager. Pool settings on the client are ignored and lost. &#13;
            Solution: HttpClients should either 1. use setConnectionManager and *only* call setMaxTotal and setDefaultMaxPerRoute on that ConnectionManager or
            2. not use a ConnectionManager and call setMaxConnTotal and setMaxConnPerRoute on the client directly (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder with setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
,
(: method param http client builder setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClient')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')])
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create()
                .setConnectionManager(conMgr)
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL) // bad, ignored
                .build();

        return HttpClientBuilder.create() // good
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutDisableConnectionState" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A HttpClient builder is used and disableConnectionState is not called. HTTP client tracks connection state while using TLS" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi07">
        <description>Problem: NTLM authenticated connections and SSL/TLS connections with client certificate authentication are stateful: they have a specific user identity/security context per session. If HttpClients have enabled connection state tracking which is the default, established TLS connections will not be reused because it is assumed that the user identity or security context may differ.
            Then performance will suffer due to a full TLS handshake for each request.&#13;
            Solution: HttpClients should disable connection state tracking in order to reuse TLS connections, since service calls for one pool have the same user identity/security context for all sessions. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(:locally created http client builder without disableConnectionState :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
(@Image="HttpClientBuilder.create" or @Image="HttpAsyncClientBuilder.create" or @Image="HttpClients.custom") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
,
(: method param http client builder without disableConnectionState :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
(@Image="HttpClientBuilder" or @Image="HttpAsyncClientBuilder" or @Image="HttpClients") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="HttpClientBuilderWithoutPoolSize" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used and the connection pool is not configured. HttpClient defaults of 2 per route and 20 max total are probably not right." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi03">
        <description>Problem: by default only 2 connections are available per route. When two external calls are being made, a third thread requesting a connection must wait for a free connection.&#13;
            Solution: HttpClients should explicitly define the number of connections per route. If only one route is used, make the max number of connections equal to conn per route.
            Either use 1. setConnectionManager and call setMaxTotal and setDefaultMaxPerRoute on that connection manager, or 2. no ConnectionManager: call setMaxConnTotal and setMaxConnPerRoute on the client directly. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
    and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
       and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration (: only when returning a connection manager :)
    [ResultType/Type[pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')]]
   //FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
,
(: new PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration//PrimaryExpression//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create() // bad, missing setMaxConnPerRoute/setMaxConnTotal or setConnectionManager
                .disableConnectionState()
                .build();

        return HttpClientBuilder.create() // good, both setMaxConnPerRoute and setMaxConnTotal called on client
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good, setConnectionManager called, pool config delegated
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used and not all three timeouts are configured. The defaults are probably not optimal (e.g. infinite). " typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI10">
        <description>Problem: For connectionRequestTimeout, connectTimeout, socketTimeout (for HttpComponentsClientHttpRequestFactory) or readTimeout (for RequestConfig) the default timeout settings are not optimal in most cases. &#13;
            Solution: Set the timeouts explicitly to proper reasoned values. See best practice values via the link. Use the setDefaultRequestConfig with a method with a RequestConfig object on HttpClient builders to set the timeouts.(jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setDefaultRequestConfig to set timeouts :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
]
,
(: method param http client builder without setDefaultRequestConfig or by RequestConfigCallback to set timeouts :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
  and not(ancestor::ClassOrInterfaceBody//PrimarySuffix[@Image='setRequestConfigCallback']
    and ancestor::ClassOrInterfaceBody//MethodDeclaration[ResultType//ClassOrInterfaceType[@Image='RequestConfig.Builder']]
    /Block[count(.//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')]) = 3] )
]
,
(: RequestConfig creation without setConnectionRequestTimeout/setConnectTimeout/setSocketTimeout :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
   (pmd-java:typeIs('org.apache.http.client.config.RequestConfig') and @Image='RequestConfig.custom')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
]
,
(: HttpComponentsClientHttpRequestFactory without httpClient and without setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   (: not if setHttpClient called on it :)
   and not(ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        (: not if one argument provided (HttpClient) as ctor arg :)
        or ancestor::Expression//Arguments[@Size = 1])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
]
,
(: HttpComponentsClientHttpRequestFactory with local httpClient and with not all three of setConnectionRequestTimeout/setConnectTimeout/[setReadTimeout or setSocketTimeout] :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   and (ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        or ancestor::Expression//Arguments//PrimaryPrefix[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])>0
]
,
(: HttpComponentsClientHttpRequestFactory as param and with not all three of setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])>0
]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
        RequestConfig requestConfig = RequestConfig.custom()
            .setSocketTimeout(4000)
            .build(); // bad, not all timeouts set

        return HttpClientBuilder.create()
            .setDefaultRequestConfig(requestConfig) // good
            .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientImproperConnectionTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="ApacheHttpClient RequestConfig connectionRequestTimeout and connectTimeout have values which are typically too high."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi20">
        <description>org.apache.http.client.config.RequestConfig is used with connectionRequestTimeout and connectTimeout values above 500 milli seconds.
            Problem: 1. connectTimeout is for establishing a connection which should be quick, say below 200 ms.
            2. connectionRequestTimeout is for requesting a connection from the connection manager, which should be almost as quick, say below 250 ms.
            If timeouts are long, requests will wait long for an unavailable service and cause high thread usage and possibly overload.  &#13;
            Solution: Set connectTimeout and connectionRequestTimeout to values based om tests, for instance 200 ms and 250 ms. respectively (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: use of field, local var and return statement :)
//FieldDeclaration[Type/PrimitiveType[@Image='int' or @Image='long']]//VariableDeclaratorId[@Name =
ancestor::ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type
[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory']/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Name/@Image]
/(../VariableInitializer//Literal[number(@Image) > 500]|
  ancestor::ClassOrInterfaceBodyDeclaration//SingleMemberAnnotation[Name/@Image='Value']//Literal[number(substring-before(substring-after(@Image, ':'), '}')) > 500])
,
(: use of literal, local var and return statement : :)
//ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory'
]/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Literal[number(@Image) > 500]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.client.config.RequestConfig;

public class HttpClientStuff {
    private static final int CONNECTION_TIMEOUTMILLIS = 1000; // bad // timeout until a connection is established
    private static final int CONNECTIONREQUEST_TIMEOUTMILLIS = 5000; // bad // timeout when requesting a connection from the connection manager
    private static final int SOCKET_TIMEOUTMILLIS = 5000; // timeout of waiting for data

    public RequestConfig requestConfigWithTimeouts() {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectionRequestTimeout(CONNECTIONREQUEST_TIMEOUTMILLIS)
                .setConnectTimeout(CONNECTION_TIMEOUTMILLIS)
                .setSocketTimeout(SOCKET_TIMEOUTMILLIS)
                .build();
        return requestConfig;
    }
}
]]>
        </example>
    </rule>

    <rule name="JAXBContextCreatedForEachMethodCall" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="JAXBContext is created for each method call, which is expensive."  typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXBContext creation is expensive because it does much class loading.  &#13;
            Solution: Since JAXBContext objects are thread safe, they can be shared between requests and reused. So, reuse created instances, e.g. as singletons.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration[not (Annotation//Name[@Image='PostConstruct'])]
 /MethodDeclaration//Expression[pmd-java:typeIs('javax.xml.bind.JAXBContext')]
 /PrimaryExpression/PrimaryPrefix/Name[@Image = 'JAXBContext.newInstance']
                ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="ObjectMapperCreatedForEachMethodCall" message="An ObjectMapper or JsonMapper is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOJAR01">
        <description>Problem: Jackson ObjectMapper/JsonMapper creation is expensive because it does much class loading.  &#13;
            Solution: Since ObjectMapper/JsonMapper objects are thread-safe after configuration in one thread, they can be shared afterwards between requests and reused. So, reuse created instances, from a static field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.json.JsonMapper') and
         ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'build')]) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//VariableDeclarator[
    pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
]/VariableInitializer//PrimaryPrefix/Name[ends-with(@Image, 'build')]
			]]></value>
            </property>
         </properties>
        <example>
            <![CDATA[
public static ObjectMapper createMapper() {
    return new ObjectMapper(); // violation
}

public static JsonMapper createMapper() {
    return JsonMapper.builder().build(); // violation
}
            ]]>
        </example>
    </rule>

    <rule name="RetryCanCauseOverload" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Be careful with retrying: multiple retry locations in a call chain can cause overload."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi13">
        <description>Problem: Multiple Retry locations in a call chain multiply the number of calls. For 2x retry on 3 locations (service calls) in a chain calling a system which is just recovering,
            results in 3 x 3 x 3 = 27 calls instead of 1. This may cause it not being able to restart.&#13;
            Solution: Have the retry mechanism in one location in the chain only, recommended only the one closest to the user. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image='Retry']
,
//Annotation//Name[@Image='Retryable']
,
//FieldDeclaration//ClassOrInterfaceType[@Image='Retry']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.annotation.Retry;

@Retry(name = "some-service") // inform
public class Foo {
    public Response callSomeService() {
        //...and someService does a Retry for a call to the next service
    }
}
            ]]>
        </example>
    </rule>

    <rule name="SetQueueCapacityForTaskExecutor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Configure the queue capacity for the ThreadPoolTaskExecutor."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia05">
        <description>The org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor queue capacity is not configured.
            Problem: It has a default queue capacity which is unlimited which can lead to an out of memory situation. &#13;
            Solution: Call setQueueCapacity, for instance with a value equal to CorePoolSize.
            Note that the pool will only grow beyond CorePoolSize up to MaxPoolSize when the queue is full. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//LocalVariableDeclaration//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
/ancestor::MethodDeclaration[.//Name[ends-with(@Image,'setCorePoolSize') or ends-with(@Image,'setMaxPoolSize')] and not(.//Name[ends-with(@Image,'.setQueueCapacity')])]
//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
   private ThreadPoolTaskExecutor bad() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // bad
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }

   private ThreadPoolTaskExecutor good() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setQueueCapacity(10); // good
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }
]]>
        </example>
    </rule>

    <rule name="UseCloseableForHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="HttpClient is used instead of ClosableHttpClient. "
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi08">
        <description>Problem: if HttpClient connections are not closed properly when needed, resources are not released and connections may not (or not quick enough) become available from the pool.&#13;
            Solution: Use ClosableHttpClient to allow for invoking close on it to properly close the connection. Or use HttpComponentsClientHttpRequestFactory(httpClient) to let it manage closing. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(: bad: HttpClient without HttpComponentsClientHttpRequestFactory :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')
   and not(ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')])]
,
(: bad: HttpClient with HttpComponentsClientHttpRequestFactory, yet if passed a param of constructor it is good :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')]
   [ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory') and
   not(../Arguments//Expression[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and not(ancestor::MethodDeclaration//Name[ends-with(@Image, '.setHttpClient')])]]
]]>
                </value>
            </property>
        </properties>
        <example>
        <![CDATA[
   void bad() {
        HttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }

    void good() {
        CloseableHttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }
    void good2() {
        HttpClient httpClient = HttpClientBuilder.create().disableConnectionState().build();
        ClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'remoting.xml' -->
<!-- BEGIN Included file 'spring.xml' -->
    <rule name="AvoidExpressionsInCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid SpEL-expression for computing Cacheable key" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#improper-caching">
        <description>Spring Expression Language (SpEL) expression is used for computing the key dynamically. Problem: evaluating the expression language is expensive, on every call.&#13;
            Solution: use a custom KeyGenerator: keyGenerator=... instead of key=...
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration//Annotation/NormalAnnotation[Name/@Image='Cacheable']/MemberValuePairs/MemberValuePair[@MemberName='key']
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    @Cacheable(value = "Cache1", key = "#key1") // bad
    public String bad1(final String key1) {
        return getRemote(key1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidIdentityCacheKeys" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid identity cache keys by casting the generate method parameters" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic13">
        <description>A non-overridden Object.toString may be called on a spring KeyGenerator.generate method parameter. Problem: The non-overridden Object.toString returns a String representing the identity of the object.
            Because this is different for two objects with the same value, cache keys will be different and the cache will only have misses and no hits.&#13;
            Solution: Cast the parameters each to the type used at call site and also check the expected number of params. Or better: return a SimpleKey composed typically of class and method name and the params.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImplementsList/ClassOrInterfaceType[pmd-java:typeIs("org.springframework.cache.interceptor.KeyGenerator")]
/../..//MethodDeclaration[@Name='generate']
/Block//BlockStatement//(
(ReturnStatement|LocalVariableDeclaration//VariableInitializer)
(:-- exclude if in an if-block checking params.length to do error logging or so --:)
[count(ancestor::IfStatement//Name[ends-with(@Image, '.length')]) = 0]
/Expression[count(.//CastExpression)=0 and count(.//AllocationExpression/ClassOrInterfaceType[@Image='SimpleKey'])=0]
//PrimaryExpression[PrimaryPrefix/Name/@Image
= ancestor::MethodDeclaration//FormalParameter[3]/VariableDeclaratorId/@Name]
|
ForStatement[./Expression//Name[@Image = ancestor::MethodDeclaration//FormalParameter[3]/VariableDeclaratorId/@Name]]
//Arguments//Name[@Image = concat(ancestor::ForStatement/LocalVariableDeclaration//VariableDeclaratorId/@Name, '.toString')]
)
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.util.StringUtils;

public class Bad implements KeyGenerator {
    public Object generate(Object target, Method method, Object... params) {
        List<Object> objArray = Arrays.asList(params);
        return target.getClass().getName() + "_" + method.getName() + "_"
                + StringUtils.arrayToDelimitedString(params, "_");  // bad, do not concatenate without casting
    }
}

public class Good implements KeyGenerator {
    public Object generate(Object target, Method method, Object... params) {
        if (params.length != 1) {
            throw new IllegalArgumentException("KeyGenerator for GetProfileCache assumes 1 parameter 'profileId', found: " + params);
        }
        String profileId = (String)params[0];
        return profileId;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidImproperAnnotationCombinations"
          language="java"
          message="Don't combine these annotations"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ssc02"
          class="net.sourceforge.pmd.lang.rule.XPathRule">
        <description>
            Improper combination of annotations. Problem: these annotations are not meant to be combined and may cause unexpected and unwanted behavior, e.g. data mix-up.&#13;
            Solution: remove the inappropriate annotation. &#13;
            Don't combine 2+ of [@Component, @Service, @Configuration, @Controller, @RestController, @Repository, @Entity] (Spring/JPA)
            Don't combine @Aspect with one of [@Service, @Configuration, @Controller, @RestController, @Repository, @Entity] (Spring/AspectJ)
            Don't combine [@Data with @Value] and [@Data or @Value] with any of [@ToString, @EqualsHashCode, @Getter, @Setter, @RequiredArgsConstructor] (Lombok)
            Don't combine @Data with any of [@Component, @Service, @Configuration, @Controller, @RestController, @Repository], it may cause user data mix-up.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[count(./Annotation//Name[@Image='Component' or @Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='RestController' or @Image='Repository' or @Image='Entity']) > 1]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Aspect'] and count(./Annotation//Name[@Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='RestController' or @Image='Repository' or @Image='Entity']) > 0]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[count(./Annotation//Name[@Image='Data' or @Image='Value']) > 1]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Data' or @Image='Value'] and ./Annotation/MarkerAnnotation/Name[@Image='ToString' or @Image='EqualsAndHashCode' or @Image='Getter' or @Image='Setter' or @Image='RequiredArgsConstructor']]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Data'] and
exists(./Annotation//Name[@Image='Component' or @Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='RestController' or @Image='Repository'])]/Annotation[not(.//Name/@Image='Data')][1]
                    ]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
@Component
@Entity // bad
class Bad {
}

@Component
class Good {
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidModelMapAsRenderParameter" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A ModelMap or @ModelAttribute is used as parameter of a portlet render method and implicitly put in the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu11">
        <description>Problem: ModelMaps are rather large objects containing explicitly added data and administrative data from Spring. They are added to the Portlet session implicitly. They stay in the session for some time: during session activity and 30 minutes (HTTP timeout) after it, in case the user does not exit explicitly. They occupy heap space during that time, for every user.&#13;
            Solution: Remove the ModelMap from the render method parameter list and create a new local ModelMap to use in the render request scope.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public=true()] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.ui.ModelMap')] or
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Annotation/MarkerAnnotation/Name[@Image='ModelAttribute']) and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.portlet.RenderRequest') or pmd-java:typeIs('javax.portlet.PortletRequest')] or
Annotation//Name[@Image='RenderMapping'])]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSimpleCaches" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid simple caching in production" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic08">
        <description>Simple caches are used. Problem: Simple caching is meant for testing and prototyping and it lacks manageability and monitorability.&#13;
            Solution: Use a proper cache implementation like ehcache or a cloud cache.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
    //AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.support.SimpleCacheManager') or pmd-java:typeIs('org.springframework.cache.concurrent.ConcurrentMapCache')]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
@EnableCaching
@Configuration
class Bad {
    @Bean public CacheManager cacheManager() {
        return new SimpleCacheManager().setCaches(Arrays.asList(new ConcurrentMapCache("ourCache")));
    }
}

@EnableCaching
@Configuration
class Good {
    @Bean public CacheManager cacheManager() {
		return new EhCacheCacheManager(ehCacheCacheManagerFactory().getObject());
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSimpleKeyCollisions" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Generate a unique SimpleKey by using both method and parameters as composites." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic15">
        <description>
            Problem: Spring's SimpleKey creation lacks either the method or the method parameters, which may cause cache data mix-up.&#13;
            Solution: Create a SimpleKey composed of both the method object and the params Object[]. Make sure the params properly implement equals and hashCode.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[ImplementsList/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.interceptor.KeyGenerator')]]
//MethodDeclaration[@Name='generate']//ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.interceptor.SimpleKey')]
[not
  ( (: a method object as 1 arg (preferred) :)
    exists(..//Expression[pmd-java:typeIs('java.lang.reflect.Method')])
    (: or (method.getName and target.getClass) :)
    or(
      exists(..//PrimaryExpression[PrimaryPrefix[pmd-java:typeIs('java.lang.Object')]][PrimarySuffix[pmd-java:typeIs('java.lang.Class')]])
      and
      exists(..//PrimaryExpression[PrimaryPrefix[pmd-java:typeIs('java.lang.reflect.Method')]])
    )
  )
  (: params included :)
  or not(exists(..//Expression[pmd-java:typeIs('java.lang.Object[]')]))
]/../Arguments
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.cache.interceptor.SimpleKey;
import java.lang.reflect.Method;

class BadCacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return new SimpleKey(params); // bad
    }
}

class GoodCacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return new SimpleKey(method, params); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSpringApplicationContextRecreation"
          message="Avoid re-creation of Spring application context"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#euocs01">
        <description>
            Problem: When a XXXApplicationContext is created, all Spring beans are initialized, wired and component scanning may take place. Component scanning involves extensive class path scanning which is expensive.&#13;
            Solution: Create the ApplicationContext only once in the application deployed/live time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[ends-with(@Image, 'ApplicationContext')
and (
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.context')]
)]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSpringMVCMemoryLeaks" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Spring Controller returns an additive expression or a ModelAndView object which may cause a MemoryLeak" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>Avoid to return an additive expression for a Spring Controller because it may cause a MemoryLeak.
            Each new value returned will create a new entry in the View Cache.
            Also avoid to return a ModelAndView object created using non-static and non-final methods because it may
            cause a MemoryLeak.
            Solution: Although multiple solutions exist you can make use of model attributes icw a redirectUrl like
            redirect:/redirectUrl?someAttribute={someAttribute}.(jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(
    //Statement/ReturnStatement
    [Expression/AdditiveExpression]
    [ancestor::ClassOrInterfaceBodyDeclaration/Annotation/NormalAnnotation/Name[starts-with(@Image,'RequestMapping')]]
    [ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image,'org.springframework')]]
) | (
    //Block//PrimaryExpression
    [
        PrimaryPrefix/Name[ends-with(@Image,'.setViewName')]
        or (PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.web.servlet.ModelAndView')])
    ]
    [
        PrimarySuffix/Arguments/ArgumentList//PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression//Arguments//PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    ]
)
            ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="EnsureProperCacheableParams" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Info: Make sure that the parameters that make up the cache key implement the required methods properly." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic16">
        <description>
            Problem: When (1) concatenating or joining parameters in a KeyGenerator: they need to properly implement toString().
            (2) using SimpleKey (recommended): the parameters need to properly implement equals() and hashCode(). Failing to do so may lead to caching data mix-up.&#13;
            Solution: Create a SimpleKey composed of both the method object and the params Object[] and make sure the params properly implement equals and hashCode.
            Note: This rule is just informational, because it cannot actually check if it is implemented correctly or not.
            (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration[.//NormalAnnotation/Name[@Image='Cacheable']]
/MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType
  [(: common safe reference types:)
    not (pmd-java:typeIs('java.lang.String')
        or pmd-java:typeIs('java.lang.Integer')
        or pmd-java:typeIs('java.time.LocalDate')
        or pmd-java:typeIs('org.joda.time.LocalDate')
    )
  ]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.annotation.Cacheable;
import java.time.*;
import java.lang.*;

class Foo {
    @Cacheable(value = "myCache", keyGenerator = "myGenerator")
    public String getDataGood(String str, LocalDate date) {
        return service.getData(input);
    }
    @Cacheable(value = "myCache", keyGenerator = "myGenerator")
    public String getDataInform(MyObject input, String str, LocalDate date) { // inform
        return service.getData(input);
    }
}
class MyObject {
    String field;
    // equals, hashCode, toString missing
}
            ]]>
        </example>
    </rule>

    <rule name="MakeAutoWiredConstructedFieldFinal"
          message="Make autowired, constructed field final in objects shared among threads."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, non-autowired access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable to defend against mutation. If they really need to be mutable (which is strange for autowired fields), make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile.&#13;
            Notes&#13;
            1. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
	//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
and not ((ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
and  (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired']
/../../../ConstructorDeclaration//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="MinimizeActionModelMapInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="ModelMap in action method is not cleared. This may bloat the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu12">
        <description>A ModelMap is used in an action method typically for form validation and not cleared. Problem: the ModelMap is put in the session by Spring. This is typically a large object which may bloat the session.&#13;
            Solution: clear the ModelMap right after the validation in the happy flow.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public=true()] and
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.ui.ModelMap')] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.portlet.ActionRequest')] or
Annotation//Name[@Image='ActionMapping']) and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.clear')])=0]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="SynchronizeForKeyInCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Synchronize access for each key in @Cacheable" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#improper-caching">
        <description>The cache by default allows multiple threads accessing by the same key. Problem: if the value of the key is not available from the cache, it will be fetched/computed by multiple threads while only one time is needed.&#13;
            Solution: Let only the first accessing thread fetch/compute the value and block others until the value is in the cache. Add attribute sync = "true" to achieve this. (Assuming the cache implementation supports it.)
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
(//ClassOrInterfaceBodyDeclaration//Annotation/NormalAnnotation[Name/@Image='Cacheable']
,
//ClassOrInterfaceBodyDeclaration//Annotation/MarkerAnnotation[Name/@Image='Cacheable'])[count(MemberValuePairs/MemberValuePair[@MemberName='sync']) = 0]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class Bad1 {
    @Cacheable(value = "Cache1") // bad
    public String bad1() {
    }
}
class Good1 {
    @Cacheable(value = "Cache1", sync = "true")
    public String good1() {
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UseClearKeyGeneratorName" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Use a specific name for this KeyGenerator class which makes clear where to use it." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic17">
        <description>This class implementing Spring's KeyGenerator uses a generic name, CacheKeyGenerator.
            Problem: It is unclear where this KeyGenerator should be used, for which cache and/or for which methods.
            If used on the wrong caches or methods, it may lead to cache key mix-up and user data mix-up.
            Solution: Make the name specific so that it is clear where to apply this KeyGenerator in @Cacheable.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[@SimpleName = 'CacheKeyGenerator' and @Interface = false() and @Abstract = false()]
/ImplementsList/ClassOrInterfaceType[@Image='KeyGenerator']
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;

public class CacheKeyGenerator implements KeyGenerator { // bad, unclear name
   public Object generate(Object target, Method method, Object... params) {
        // build key and return it
   }
}
            ]]>
        </example>
    </rule>

    <rule name="UseExplicitKeyGeneratorForCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Use a KeyGenerator to generate a correct and unique key per cached value, do not rely on the implicit default key generation." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic14">
        <description>
            Problem: With default key generation, an object of Spring's SimpleKey class is used and its value is composed of just the method parameter(s). It does not include the method, which is unclear and risky.&#13;
            Solution: Create a KeyGenerator and make it generate a unique key for the cache per cached value, by use of SimpleKey composed of method object and the parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image='Cacheable']
/../MemberValuePairs[count(MemberValuePair[@Image='keyGenerator']) = 0]
	]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.annotation.Cacheable;
class Foo {

    @Cacheable(cacheNames = {"DATA"}, sync = true, keyGenerator = "cacheKeyGenerator")
    public Object getDataGood(String id) {
        return fetchFromBackend(id);
    }

    @Cacheable(value="DATA", sync = true) // bad, keyGenerator missing
    public Object getDataBad(String id) {
        return fetchFromBackend(id);
    }
}
            ]]>
        </example>
    </rule>

<!-- END Included file 'spring.xml' -->
<!-- BEGIN Included file 'sql.xml' -->
    <rule name="AvoidFetchingWholeList"
          message="Avoid fetching the whole list of entities for the query, while only one entity is used"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trr04">
        <description>
            Problem: Unused rows are fetched and transported, and unused jdbc buffer is allocated.&#13;
            Solution: Use query.getSingleResult() in stead of query.getResultList().
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if getResultList is used to fetsch entities and entities(0) is returned :)
//ReturnStatement//PrimaryExpression[./PrimarySuffix/Arguments//Literal[@Image='0']][./PrimaryPrefix/Name/@Image=
concat(ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name,'.get')
(: not when also the whole list of entities is returnd :)
and not(ancestor::MethodDeclaration//ReturnStatement//PrimaryExpression[./PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name])
(: not when also another elem of entities is returned :)
and not (ancestor::MethodDeclaration//ReturnStatement//PrimaryExpression[./PrimarySuffix/Arguments//Literal[@Image!='0']][./PrimaryPrefix/Name/@Image=
concat(ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name,'.get')])
]/ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    public SomeEntity findByQueryBad(TypedQuery<Object> query) {
        final List<SomeEntity> entities = query.getResultList();
        return !entities.isEmpty() ? entities.get(0) : null;
    }
    public SomeEntity findByQueryGood(TypedQuery<Object> query) throws NoResultException {
        return query.getSingleResult();
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidHugeQueryFetchSize"
          message="Avoid a huge query fetch size, it consumes much memory."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trm03">
        <description>
            Problem: if huge numbers of result rows are fetched these are all stored in memory and this may introduce long gc times and out of memory risk.&#13;
            Solution: Set fetch size to 100 maximally. Only set it higher than 100 yet still max 500, if you are sure there is only little data returned per row, like 3 rather short columns.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]
[../..//ArgumentList//Literal[number(@Image) > 500]]]
|
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]]
[PrimarySuffix//ArgumentList//Name[@Image =
ancestor::ClassOrInterfaceBody//VariableDeclarator/VariableDeclaratorId/@Name
[../../VariableInitializer//Literal[number(@Image) > 500]]]]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidMultipleRoundtripsForQuery"
          message="Avoid multiple roundtrips for the same query"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trr05">
        <description>
            Problem: Time is taken by the unnecessary roundtrip(s). Unnecessary work is performed.&#13;
            Solution: Execute the query only once.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')]
[ancestor::MethodDeclaration[count(.//VariableInitializer/Expression/PrimaryExpression/PrimarySuffix[@Image='createQuery']) = 1
and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getResultList')]) +
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')])
> 1]]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSqlInExpression"
          message="Avoid a SQL IN-Expression, it fails for > 1000 arguments and pollutes the query plan cache / statement cache"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-ino01">
        <description>
            Problem: The number of values for the IN-argument list is limited, in Oracle to 1000. An error occurs when exceeding this limit. Additionally, a large IN list takes much time to transport to the database and be parsed. Moreover, each number of IN values used in a query results in a separate cache entry in e.g. the Prepared Statement Cache of the application server and in the Hibernate Query Plan Cache, resulting in higher memory usage and/or low cache hit ratio.&#13;
            Solution: Rewrite the query by replacing the IN-argument list by a sub query using the criteria used to fetch the IN arguments. Or often even better performing, an inner join using these criteria (depending on indexes etc. - recommended to test to be sure.) This way, the select and update are combined into one, which will also save one roundtrip.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="tag" value="jpinpoint-rule" type="String" description="for-sonar"/>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='InExpression.in']
|
//TypeDeclaration/Annotation/SingleMemberAnnotation/Name[@Image='NamedQueries']
/../MemberValue//PrimaryExpression/PrimaryPrefix/Literal[contains(@Image, 'WHERE') and
(contains(@Image, ' IN(:') or contains(@Image, ' IN (:') or contains(@Image, ' IN :') or contains(@Image, ' IN ( :')) ]
|
//LocalVariableDeclaration/VariableDeclarator/VariableInitializer//PrimaryPrefix[Literal[contains(@Image, ' IN') and contains(@Image, ':')]
and starts-with(Literal[(contains(@Image, ' IN') and contains(@Image, ':'))]/
substring-after(substring-after(@Image, ' IN'), ':')
,
ancestor::MethodDeclaration//BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.setParameter')]
/../../PrimarySuffix/Arguments/ArgumentList[Expression/PrimaryExpression/PrimaryPrefix/Name[@Image != 'Arrays.asList']]/Expression/PrimaryExpression/PrimaryPrefix/Literal/substring-before(substring-after(@Image, '"'),'"'))
and
ancestor::MethodDeclaration//BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.setParameter')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image != 'Arrays.asList']
]
,
(: Criteria API: cust.get("postalCode").in(codes) :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('javax.persistence.criteria.Root')]/..//PrimarySuffix//ArgumentList/ancestor::Expression//PrimarySuffix[@Image='in']
,
(: criteria API: builder.in(cust.get("postalCode") :)
//Expression//PrimarySuffix//Expression//PrimaryPrefix[pmd-java:typeIs('javax.persistence.criteria.Root')]/..//PrimarySuffix//ArgumentList/
ancestor::BlockStatement//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.in') and
(: good: builder.in(cust.get("postalCode")).value(subquery) :)
(not(exists(ancestor::PrimaryExpression/PrimarySuffix/Arguments//Expression[pmd-java:typeIs('javax.persistence.criteria.Subquery')])))]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
    private void bad(CriteriaQuery cq, Root<Customer> cust) {
        cq.select(cust).where(cust.get("postalCode").in(codes)); // bad
    }
    private void good(CriteriaBuilder builder, CriteriaQuery cq, Root<Customer> cust, SubQuery<PostalCode> subquery) {
        cq.select(cust).where(builder.in(cust.get("postalCode")).value(subquery));
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'sql.xml' -->
</ruleset>
