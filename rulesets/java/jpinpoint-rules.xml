<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-rules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" xmlns:fn="http://www.w3.org/TR/xpath-functions/">
<description>jPinpoint specific rules for performance aware Java coding, sponsored by Rabobank.</description>

<!-- IMPORTANT NOTICE: The content of this file is generated. Do not edit this file directly since changes may be lost when this file is regenerated! -->

<!-- BEGIN Included file 'concurrent.xml' -->
    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    typeIs('java.util.concurrent.Future')
    or typeIs('java.util.concurrent.CompletableFuture')
    or typeIs('java.util.concurrent.Response')
    or typeIs('java.util.concurrent.RunnableFuture')
    or typeIs('java.util.concurrent.RunnableScheduledFuture')
    or typeIs('java.util.concurrent.ScheduledFuture')
    ]/../../../VariableDeclaratorId/@Image, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
    typeIs('java.util.concurrent.Future')
    or typeIs('java.util.concurrent.CompletableFuture')
    or typeIs('java.util.concurrent.Response')
    or typeIs('java.util.concurrent.RunnableFuture')
    or typeIs('java.util.concurrent.RunnableScheduledFuture')
    or typeIs('java.util.concurrent.ScheduledFuture')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Image, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
    typeIs('java.util.concurrent.Future')
    or typeIs('java.util.concurrent.CompletableFuture')
    or typeIs('java.util.concurrent.Response')
    or typeIs('java.util.concurrent.RunnableFuture')
    or typeIs('java.util.concurrent.RunnableScheduledFuture')
    or typeIs('java.util.concurrent.ScheduledFuture')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Image, '.')))
    and not(../../PrimarySuffix/Arguments/ArgumentList)
    and ancestor::CompilationUnit/ImportDeclaration/Name[@Image = 'java.util.concurrent.Future' or @Image = 'java.util.concurrent']
    ]
    ]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
  //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.take')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclaratorId/@Image, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Image, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     typeIs('java.util.concurrent.CompletionService')
    or typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Image, '.')))
]    ]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TUTC08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[@Static='true' and @Final='false' and @Volatile='false' and not (../Annotation//Name[@Image='GuardedBy'])]
|
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='true']/Type/ReferenceType/ClassOrInterfaceType[
(((typeIs('java.util.Date') or typeIs('java.lang.StringBuilder') or typeIs('java.lang.StringBuffer') or typeIs('java.net.URL')) or typeIs('java.io.File'))
 or (ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0]))
 and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='GuardedBy'])
])
|
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='true' and not (../Annotation//Name[@Image='GuardedBy'])]/
VariableDeclarator/VariableInitializer[((ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0)
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[ArrayDimsAndInits and ArrayDimsAndInits//PrimaryPrefix/Literal/@Image>0]
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
(typeIs('java.util.ArrayList') or typeIs('java.util.HashMap') or typeIs('java.util.HashSet'))
])])
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TUTC07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile.&#13;
            Notes&#13;
            1. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])]
/../../..//ClassOrInterfaceDeclaration[@Static='false']/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[@Image=
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final='false' and @Volatile='false' and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Image
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value']
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public='false']))]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInSharedObjects"
          message="Avoid unguarded non-final or mutable fields in objects shared among threads."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TUTC07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
and not ((ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/../../..//ClassOrInterfaceDeclaration[@Static='false']/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final='false' and @Volatile='false'
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Image)
or ((Type/ReferenceType/ClassOrInterfaceType[(typeIs('java.util.Date') or typeIs('java.lang.StringBuilder') or typeIs('java.lang.StringBuffer') or typeIs('java.net.URL') or typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[typeIs('java.lang.ArrayList') or typeIs('java.lang.HashMap') or typeIs('java.lang.HashSet')] )
     and not (../Annotation//Name[@Image='GuardedBy']))
]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.bind.Marshaller')]
|
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.bind.Unmarshaller')]
|
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.bind.Validator')]
|
//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.validation.Validator')]
			]]></value>
            </property>
        </properties>
    </rule>

<!-- END Included file 'concurrent.xml' -->
<!-- BEGIN Included file 'sql.xml' -->
    <rule name="AvoidSqlInExpression"
          message="Avoid a SQL IN-Expression, it fails for > 1000 arguments and pollutes the query plan cache / statement cache"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Data+Access+Performance#JavaDataAccessPerformance-IDA-INO01">
        <description>
            Problem: The number of values for the IN-argument list is limited, in Oracle to 1000. An error occurs when exceeding this limit. Additionally, a large IN list takes much time to transport to the database and be parsed. Moreover, each number of IN values used in a query results in a separate cache entry in e.g. the Prepared Statement Cache of the application server and in the Hibernate Query Plan Cache, resulting in higher memory usage and/or low cache hit ratio.&#13;
            Solution: Rewrite the query by replacing the IN-argument list by a sub query using the criteria used to fetch the IN arguments. Or often even better performing, an inner join using these criteria (depending on indexes etc. - recommended to test to be sure.) This way, the select and update are combined into one, which will also save one roundtrip.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[


//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='InExpression.in']
|
//TypeDeclaration/Annotation/SingleMemberAnnotation/Name[@Image='NamedQueries']
/../MemberValue//PrimaryExpression/PrimaryPrefix/Literal[contains(@Image, 'WHERE') and
(contains(@Image, ' IN(:') or contains(@Image, ' IN (:') or contains(@Image, ' IN :') or contains(@Image, ' IN ( :')) ]
|
//LocalVariableDeclaration/VariableDeclarator/VariableInitializer//PrimaryPrefix[Literal[contains(@Image, ' IN') and contains(@Image, ':')]
and starts-with(Literal[(contains(@Image, ' IN') and contains(@Image, ':'))]/
substring-after(substring-after(@Image, ' IN'), ':')
,
ancestor::MethodDeclaration//BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.setParameter')]
/../../PrimarySuffix/Arguments/ArgumentList[Expression/PrimaryExpression/PrimaryPrefix/Name[@Image != 'Arrays.asList']]/Expression/PrimaryExpression/PrimaryPrefix/Literal/substring-before(substring-after(@Image, '"'),'"'))
and
ancestor::MethodDeclaration//BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.setParameter')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image != 'Arrays.asList']
]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidHugeQueryFetchSize"
          message="Avoid a huge query fetch size, it consumes much memory."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Data+Access+Performance#JavaDataAccessPerformance-IDA-TRM03">
        <description>
            Problem: if huge numbers of result rows are fetched these are all stored in memory and this may introduce long gc times and out of memory risk.&#13;
            Solution: Set fetch size to 100 maximally. Only set it higher than 100 yet still max 500, if you are sure there is only little data returned per row, like 3 rather short columns.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]
[ancestor::PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image > 500]]]
|
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]
[ancestor::PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image =
ancestor::ClassOrInterfaceBody//VariableDeclarator/VariableDeclaratorId/@Image
[ancestor::VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image > 500]]]]]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidMultipleRoundtripsForQuery"
          message="Avoid multiple roundtrips for the same query"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Data+Access+Performance#JavaDataAccessPerformance-IDA-TRR05">
        <description>
            Problem: Time is taken by the unnecessary roundtrip(s). Unnecessary work is performed.&#13;
            Solution: Execute the query only once.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')]
[ancestor::MethodDeclaration[count(.//VariableInitializer/Expression/PrimaryExpression/PrimarySuffix[@Image='createQuery']) = 1
and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getResultList')]) +
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')])
> 1]]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

<!-- END Included file 'sql.xml' -->
<!-- BEGIN Included file 'spring.xml' -->
    <rule name="MakeAutoWiredConstructedFieldFinal"
          message="Make autowired, constructed field final in objects shared among threads."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TUTC07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, non-autowired access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable to defend against mutation. If they really need to be mutable (which is strange for autowired fields), make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile.&#13;
            Notes&#13;
            1. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
	//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
and not ((ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/../../..//ClassOrInterfaceDeclaration[@Static='false']/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final='false' and @Volatile='false'
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
and  (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired']
/../../../ConstructorDeclaration//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Image)
]
]]>
                </value>
            </property>
        </properties>
        <priority>4</priority>
    </rule>

    <rule name="AvoidModelMapAsRenderParameter" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="A ModelMap or @ModelAttribute is used as parameter of a portlet render method and implicitely put in the session." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TMSU11">
        <description>Problem: ModelMaps are rather large objects containing explicitly added data and administrative data from Spring. They are added to the Portlet session implicitly. They stay in the session for some time: during session activity and 30 minutes (HTTP timeout) after it, in case the user does not exit explicitly. They occupy heap space during that time, for every user.&#13;
            Solution: Remove the ModelMap from the render method parameter list and create a new local ModelMap to use in the render request scope.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public='true'] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('org.springframework.ui.ModelMap')] or
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Annotation/MarkerAnnotation/Name[@Image='ModelAttribute']) and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.portlet.RenderRequest') or typeIs('javax.portlet.PortletRequest')] or
Annotation//Name[@Image='RenderMapping'])]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="MinimizeActionModelMapInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="ModelMap in action method is not cleared. This may bloat the session." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TMSU12">
        <description>A ModelMap is used in an action method typically for form validation and not cleared. Problem: the ModelMap is put in the session by Spring. This is typically a large object which may bloat the session.&#13;
            Solution: clear the ModelMap right after the validation in the happy flow.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public='true'] and
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('org.springframework.ui.ModelMap')] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.portlet.ActionRequest')] or
Annotation//Name[@Image='ActionMapping']) and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.clear')])=0]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSpringApplicationContextRecreation"
          message="Avoid re-creation of Spring application context"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-EUOCS01">
        <description>
            Problem: When a XXXApplicationContext is created, all Spring beans are initialized, wired and component scanning may take place. Component scanning involves extensive class path scanning which is expensive.&#13;
            Solution: Create the ApplicationContext only once in the application deployed/live time.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="2.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[ends-with(@Image, 'ApplicationContext')
and (
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.context')]
)]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidImproperAnnotationCombinations"
          language="java"
          message="Don't combine these annotations"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-Annotations"
          class="net.sourceforge.pmd.lang.rule.XPathRule">
        <description>
            Improper combination of annotations. Problem: these annotations are not meant to be combined and may cause unexpected and unwanted behavior.&#13;
            Solution: remove the inappropriate annotation. &#13;
            Don't combine 2+ of [@Component, @Service, @Configuration, @Controller, @Repository, @Entity] (Spring/JPA)
            Don't combine [@Data with @Value] and [@Data or @Value] with any of [@ToString, @EqualsHashCode, @Getter, @Setter, @RequiredArgsConstructor] (Lombok)
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration[count(./Annotation/MarkerAnnotation/Name[@Image='Component' or @Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='Repository' or @Image='Entity']) > 1]
|
//ClassOrInterfaceBodyDeclaration[count(./Annotation/MarkerAnnotation/Name[@Image='Component' or @Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='Repository' or @Image='Entity']) > 1]
|
//TypeDeclaration[count(./Annotation/MarkerAnnotation/Name[@Image='Data' or @Image='Value']) > 1]
|
//ClassOrInterfaceBodyDeclaration[count(./Annotation/MarkerAnnotation/Name[@Image='Data' or @Image='Value']) > 1]
|
//TypeDeclaration[./Annotation/MarkerAnnotation/Name[@Image='Data' or @Image='Value'] and ./Annotation/MarkerAnnotation/Name[@Image='ToString' or @Image='EqualsAndHashCode' or @Image='Getter' or @Image='Setter' or @Image='RequiredArgsConstructor']]
|
//ClassOrInterfaceBodyDeclaration[./Annotation/MarkerAnnotation/Name[@Image='Data' or @Image='Value'] and ./Annotation/MarkerAnnotation/Name[@Image='ToString' or @Image='EqualsAndHashCode' or @Image='Getter' or @Image='Setter' or @Image='RequiredArgsConstructor']]
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSpringMVCMemoryLeaks" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          message="Spring Controller returns an additive expression or a ModelAndView object which may cause a MemoryLeak" typeResolution="true"
          externalInfoUrl="https://confluence.dev.rabobank.nl/display/PCC/Java+Code+Performance">
        <description>Avoid to return an additive expression for a Spring Controller because it may cause a MemoryLeak.
            Each new value returned will create a new entry in the View Cache.
            Also avoid to return a ModelAndView object created using non-static and non-final methods because it may
            cause a MemoryLeak.
            Solution: Although multiple solutions exist you can make use of model attributes icw a redirectUrl like
            redirect:/redirectUrl?someAttribute={someAttribute}.</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
(
    //Statement/ReturnStatement
    [Expression/AdditiveExpression]
    [ancestor::ClassOrInterfaceBodyDeclaration/Annotation/NormalAnnotation/Name[starts-with(@Image,'RequestMapping')]]
    [ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image,'org.springframework')]]
) | (
    //Block//PrimaryExpression
    [
        PrimaryPrefix/Name[ends-with(@Image,'.setViewName')]
        or (PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[typeIs('org.springframework.web.servlet.ModelAndView')])
    ]
    [
        PrimarySuffix/Arguments/ArgumentList//PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final='false']//VariableDeclaratorId/@Image)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final='false']//VariableDeclaratorId/@Image)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression//Arguments//PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final='false']//VariableDeclaratorId/@Image)]
    ]
)
            ]]></value>
            </property>
        </properties>
    </rule>

<!-- END Included file 'spring.xml' -->
<!-- BEGIN Included file 'common.xml' -->
    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="StringBuffer is used. It introduces locking overhead, use StringBuilder." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-ISU01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
                    //VariableDeclarator[../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.StringBuffer')]]
                    ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="UnconditionalStringOperationOnLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="String operation is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IL03">
        <description>Problem: A String operation like toString() or String.format is executed regardless of log level. This may include formatting, reflection and other wasteful processing.&#13;
            Solution: Remove the operation and utilize SLF4J formatting with {}-placeholders, or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
            //PrimaryPrefix/Name
            [
            	ends-with(@Image,'.trace')
            	or ends-with(@Image,'.debug')
            	or ends-with(@Image,'.info')
            ]
            /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression/PrimaryPrefix/Name
            [
            	ends-with(@Image,'.toString')
            	or starts-with(@Image,'String.')
            ]
            [not(ancestor::IfStatement/Expression//PrimaryPrefix/Name
            	[
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
				])
			]
			]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="UnconditionalConcatInLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="String concatenation (+) is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IL01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
			//PrimaryPrefix/Name[ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or ends-with(@Image,'.info')]/../../PrimarySuffix/Arguments/ArgumentList/Expression/AdditiveExpression
			[PrimaryExpression/PrimaryPrefix/Name]
			[not(ancestor::IfStatement/Expression/PrimaryExpression/PrimaryPrefix/Name[
			ends-with(@Image,'.isTraceEnabled')
			or ends-with(@Image,'.isDebugEnabled')
			or ends-with(@Image,'.isInfoEnabled')
			or ends-with(@Image,'.isLoggable')
			])]
]]></value>
            </property>
        </properties>
    </rule>

    <rule name="JAXBContextCreatedForEachMethodCall" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="JAXBContext is created for each method call, which is expensive."  typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IUOXAR04">
        <description>Problem: JAXBContext creation is expensive because it does much class loading.  &#13;
            Solution: Since JAXBContext objects are thread safe, they can be shared between requests and reused. So, reuse created instances, e.g. as singletons.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'JAXBContext.newInstance']
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Reflection is used in toString or hashCode, which is expensive." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UUOR01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, preferably using Guava.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/AllocationExpression/ClassOrInterfaceType
	[
		typeIs('org.apache.commons.lang.builder.EqualsBuilder')
		or typeIs('org.apache.commons.lang.builder.HashCodeBuilder')
	]
[../../../PrimarySuffix[1]
	[
		@Image='reflectionEquals'
		or @Image='reflectionHashCode'
	]
] |
//PrimaryPrefix/Name
	[
		@Image='EqualsBuilder.reflectionEquals'
		or @Image='HashCodeBuilder.reflectionHashCode'
	]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidCalendarDateCreation" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="A Calendar is used to create a Date or DateTime, this is expensive." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UE01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use 'new Date()', joda time '(Local)DateTime.now()' or Java 8 java.time.(Local/Zoned)DateTime.now().
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix[Name[ends-with(@Image, 'Calendar.getInstance')]] [count(../PrimarySuffix) > 2 and ../PrimarySuffix[last()-1][@Image = 'getTime' or @Image='getTimeInMillis']]
|
//Block/BlockStatement/LocalVariableDeclaration/VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'Calendar.getInstance')]/
../../../../../../../../
BlockStatement/LocalVariableDeclaration/VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.getTime') or ends-with(@Image,'.getTimeInMillis')]
|
//ClassOrInterfaceType[typeIs('org.joda.time.DateTime') or typeIs('org.joda.time.LocalDateTime')][../Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'Calendar.getInstance')]]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-VOEDOS04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
 //ClassOrInterfaceDeclaration[@Interface='true']
    [
      count(.//FieldDeclaration)>0
    ]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidSimpleDateFormat" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."  typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IDTF01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use a Joda-Time DateTimeFormat to create a specific DateTimeFormatter or Java 8 java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
 //AllocationExpression/ClassOrInterfaceType[typeIs('java.text.SimpleDateFormat')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IDTF01">
        <description>Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe. The usual solution
            is to create a new local one when needed in a method. (jpinpoint-rules)
        </description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator/VariableInitializer/Expression[typeIs('java.text.DecimalFormat') or typeIs('java.text.ChoiceFormat')]
        ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecompilingPatterns" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IREU02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.compile') and
count(../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression) = 1
and not (
../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Image)]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitely compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IREU01">
        <description>A regular expression is compiled implicitely on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.replaceAll') or ends-with(@Image, '.replaceFirst') or ends-with(@Image, 'Pattern.matches')]/../../PrimarySuffix/Arguments[@ArgumentCount=2]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(contains(@Image, '.') or contains(@Image, '$') or contains(@Image, '|') or contains(@Image, '(') or contains(@Image, ')') or contains(@Image, '[')
or contains(@Image, ']') or contains(@Image, '{') or contains(@Image, '}') or contains(@Image, '^') or contains(@Image, '?') or contains(@Image, '*')
or contains(@Image, '+') or contains(@Image, '\'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(contains(@Image, '.') or contains(@Image, '$') or contains(@Image, '|') or contains(@Image, '(') or contains(@Image, ')') or contains(@Image, '[')
or contains(@Image, ']') or contains(@Image, '{') or contains(@Image, '}') or contains(@Image, '^') or contains(@Image, '?') or contains(@Image, '*')
or contains(@Image, '+') or contains(@Image, '\'))]
]/VariableDeclaratorId/@Image])
]
|
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.split') or ends-with(@Image, 'getPathMatcher')]/../../PrimarySuffix/Arguments[@ArgumentCount=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(contains(@Image, '.') or contains(@Image, '$') or contains(@Image, '|') or contains(@Image, '(') or contains(@Image, ')') or contains(@Image, '[')
or contains(@Image, ']') or contains(@Image, '{') or contains(@Image, '}') or contains(@Image, '^') or contains(@Image, '?') or contains(@Image, '*')
or contains(@Image, '+') or contains(@Image, '\'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(contains(@Image, '.') or contains(@Image, '$') or contains(@Image, '|') or contains(@Image, '(') or contains(@Image, ')') or contains(@Image, '[')
or contains(@Image, ']') or contains(@Image, '{') or contains(@Image, '}') or contains(@Image, '^') or contains(@Image, '?') or contains(@Image, '*')
or contains(@Image, '+') or contains(@Image, '\'))]
]/VariableDeclaratorId/@Image])
] |
//MethodDeclaration//PrimarySuffix[@Image='getPathMatcher']/../PrimarySuffix/Arguments[@ArgumentCount=1]/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]]/VariableDeclaratorId/@Image])
] |
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.matches')]
[(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]/../../../VariableDeclaratorId/@Image, '.'))
or
starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/@Image, '.')))
and
../../PrimarySuffix/Arguments[@ArgumentCount=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Image)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]
]/VariableDeclaratorId/@Image])
]]
]]></value>
            </property>
        </properties>
    </rule>

    <rule name="MinimizeAttributesInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Attribute is set in the session, yet not removed. This may bloat the session." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-TMSU01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/PrimarySuffix[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBodyDeclaration//ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimarySuffix[ends-with(@Image, 'removeAttribute')]
or
ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'removeAttribute')]
)]]
|
//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBodyDeclaration//ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimarySuffix[ends-with(@Image, 'removeAttribute')]
or
ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'removeAttribute')]
)]]
|
//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBodyDeclaration//ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration/MethodDeclaration//Block/BlockStatement//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPath is used. XPath implementation has bad performance." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UX03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[@Image='XPathFactory.newInstance']
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UX02">
        <description>XPathExpression is created and compiled on every method call. Problem: Creation XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching in Thread locals may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.newXPath')]
/ancestor::ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.compile')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidWideScopeXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathExpression targets a wide scope, this is potentially slow." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UX01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimarySuffix[
Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/
Literal[starts-with(@Image, '"//')]
and
../PrimaryPrefix/Name[ends-with(@Image, '.compile')]
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Log String is built irrespective of log level." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IL02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') = 'append')
and count(ancestor::IfStatement) = 0
and
count(ancestor::MethodDeclaration/Block/BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList//PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') != 'append')]) = 0
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidConcatInLoop" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="A String is concatenated in a loop. Use StringBuilder.append." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-ISU02">
        <description>A String is built in a loop by concatenation. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected. &#13;
            Solution: Use the StringBuilder append method.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//ForStatement//AssignmentOperator[@Image='+='][
ancestor::MethodDeclaration//VariableDeclaratorId[@Image =
ancestor::MethodDeclaration//ForStatement//AssignmentOperator[@Image='+=']/
../PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
./../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]
]]
|
//MethodDeclaration//ForStatement//StatementExpression[AssignmentOperator/../Expression/AdditiveExpression[
PrimaryExpression/PrimaryPrefix/Name/attribute::Image = ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
ancestor::MethodDeclaration//VariableDeclaratorId[@Image =
ancestor::MethodDeclaration//ForStatement//AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
@Image =
ancestor::MethodDeclaration//ForStatement//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
./../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]
]]]
|
//MethodDeclaration//WhileStatement//AssignmentOperator[@Image='+='][
ancestor::MethodDeclaration//VariableDeclaratorId[@Image =
ancestor::MethodDeclaration//ForStatement//AssignmentOperator[@Image='+=']/
../PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
./../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]
]]
|
//MethodDeclaration//WhileStatement//StatementExpression[AssignmentOperator/../Expression/AdditiveExpression[
PrimaryExpression/PrimaryPrefix/Name/attribute::Image = ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
ancestor::MethodDeclaration//VariableDeclaratorId[@Image =
ancestor::MethodDeclaration//ForStatement//AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
@Image =
ancestor::MethodDeclaration//ForStatement//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image and
./../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]
]]]
	]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidMultipleConcatStatements" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Multiple statements concatenate to the same String. Use StringBuilder append." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-ISU02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBulder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name
[@Image=./../../../../../../../../../../../..//VariableDeclaratorId/attribute::Image
and
./../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]
]
/../../../AssignmentOperator[@Image='+=']/
../Expression//PrimaryExpression/PrimaryPrefix/Name) > 1]/BlockStatement[position()=last()]
|
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[
@Image = ../../../Expression/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
@Image = ./../../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/attribute::Image
]
]) > 1 ]//BlockStatement[position()=last()]//StatementExpression/Expression/AdditiveExpression[@Image = '+']
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidConcatInAppend" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Concatenation inside append. Use extra append." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-ISU02">
        <description>Concatenation of Strings is used inside an StringBuilder.append argument. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use an extra fluent append instead of concatenation.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[substring-after(@Image, '.') = 'append']
and
./PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression[1]/AdditiveExpression[@Image='+']
]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXMLGregorianCalendar" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XMLGregorianCalendar is used. It is slow in JAXB." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IUOXAR05">
        <description>Problem: XMLGregorianCalendar is a large object, involving substantial processing. It is created with the poorly performing DatatypeFactory.
            Solution: Add a converter for alternative date handling with joda-time or Java 8 java.time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>

            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.datatype.XMLGregorianCalendar')]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('javax.xml.datatype.XMLGregorianCalendar')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="MDCPutWithoutRemove" message="MDC put is used without finally remove." class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration/Block//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Literal[not(@Image=
ancestor::ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block//TryStatement//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Literal/@Image)
]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration/Block//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Name[not(@Image=
ancestor::ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block//TryStatement//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Name/@Image)
]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="ObjectMapperCreatedForEachMethodCall" message="An ObjectMapper is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"   typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IUOJAR01">
        <description>Problem: Jackson ObjectMapper creation is expensive because it does much class loading.  &#13;
            Solution: Since ObjectMapper objects are thread-safe after configuration in one thread, they can be shared afterwards between requests and reused. So, reuse created instances, from a static field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	(typeIs('com.fasterxml.jackson.databind.ObjectMapper')) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
]
			]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidXPathAPIUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="XPathAPI is used. XPathAPI implementation has bad performance." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-UX03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'XPathAPI.')]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Default capacity constructor of ByteArrayOutputStream or StringWriter is used, it usually needs expensive expansions." typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-ISIO01">
        <description>Default constructor of ByteArrayOutputStream or StringWriter is used. Problem: It allocates a small buffer as capacity which usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
	//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[typeIs('java.io.ByteArrayOutputStream') or typeIs('java.io.StringWriter')]
[not(../Arguments/ArgumentList)]
	]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IDTF02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: org.joda.time.format.DateTimeFormatter or Java 8 java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
    //FieldDeclaration[@Final='false' or @Static='false']//ReferenceType/ClassOrInterfaceType[typeIs('org.joda.time.format.DateTimeFormatter') or typeIs('org.threeten.bp.format.DateTimeFormatter') or typeIs('java.time.format.DateTimeFormatter')] |
    //MethodDeclaration/Block//ReferenceType/ClassOrInterfaceType[typeIs('org.joda.time.format.DateTimeFormatter') or typeIs('org.threeten.bp.format.DateTimeFormatter') or typeIs('java.time.format.DateTimeFormatter')]
[ancestor::LocalVariableDeclaration/VariableDeclarator/VariableInitializer/Expression//PrimaryPrefix/Literal] |
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[typeIs('org.joda.time.format.DateTimeFormatter') or typeIs('org.threeten.bp.format.DateTimeFormatter') or typeIs('java.time.format.DateTimeFormatter')] |
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'ISODateTimeFormat.')] |
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'DateTimeFormat.')
       and not (ends-with(@Image, 'forPattern'))] |
   //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'DateTimeFormat.forPattern')]
[ancestor::Expression//PrimaryPrefix/Literal] |
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimarySuffix[@Image='toFormatter']
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IncorrectequalsandhashCode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... and @Entity objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface='false' and @Abstract='false']
[not(./ExtendsList/ClassOrInterfaceType[ends-with(@Image, 'Exception') or ends-with(@Image, 'Throwable')])]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='false']
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public='true' and @Static='false']/MethodDeclarator[starts-with(@Image, 'get') and string-length(@Image) > 3 or starts-with(@Image, 'is') and string-length(@Image) > 2]
[../ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='false']/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public='true' and @Static='false']/MethodDeclarator[@Image='equals' or @Image='hashCode'])
)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public='true' and @Static='false']/MethodDeclarator/@Image='toString'
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='false']) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public='true' and @Static='false']/MethodDeclarator[starts-with(@Image, 'get') and string-length(@Image) > 3 or starts-with(@Image, 'is') and string-length(@Image) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@Image, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static='false']) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public='true' and @Static='false']/MethodDeclarator[starts-with(@Image, 'get') and string-length(@Image) > 3 or starts-with(@Image, 'is') and string-length(@Image) > 2])
)]
]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
    </rule>

    <rule name="AvoidDeprecatedHttpConnectors" class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java" message="Avoid the use of deprecated/thread-unsafe HTTP connectors" typeResolution="true"
          externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Performance#JavaCodePerformance-IBI06" >
        <description>Problem: Several HTTP client connection managers are thread-unsafe which may cause session data mix-up or have other issues for which they were made deprecated.&#13;
            Solutions: Use org.apache.http.impl.conn.PoolingHttpClientConnectionManager and org.apache.http.impl.client.HttpClientBuilder. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[@Image='org.apache.commons.httpclient.SimpleHttpConnectionManager'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.http.impl.conn.PoolingClientConnectionManager'
or @Image='org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager'
or @Image='org.apache.http.impl.conn.SingleClientConnManager'
or @Image='org.apache.http.impl.client.DefaultHttpClient'
or @Image='org.apache.http.impl.client.SystemDefaultHttpClient'
or @Image='org.apache.http.conn.ClientConnectionManager'
]
|
//TypeDeclaration//ClassOrInterfaceDeclaration//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/
Type/ReferenceType/ClassOrInterfaceType[typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')
or typeIs('org.apache.http.conn.ClientConnectionManager')
or typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or typeIs('org.apache.http.impl.client.DefaultHttpClient')
or typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or typeIs('org.apache.http.conn.ClientConnectionManager')
]
|
//TypeDeclaration//ClassOrInterfaceDeclaration//ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/
VariableDeclarator/VariableInitializer/Expression//AllocationExpression/ClassOrInterfaceType[
typeIs('org.apache.http.conn.ClientConnectionManager')
or typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or typeIs('org.apache.http.impl.client.DefaultHttpClient')
or typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or typeIs('org.apache.http.conn.ClientConnectionManager')
]
|
//AllocationExpression/ClassOrInterfaceType[typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')]
		     ]]></value>
            </property>
        </properties>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.XPathRule" deprecated="false" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="http://www.jpinpoint.com/doc/Java+Code+Quality#JavaCodeQuality-CSC01">
        <description>
            Problem: Potential bug: expected are different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <properties>
            <property name="version" value="1.0"/>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement/BlockStatement[
(.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
or
.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image)
and
.//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
not(.//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimarySuffix/Arguments/@ArgumentCount > 0
or preceding-sibling::SwitchLabel[@Default='true'])
]
]]>
                </value>
            </property>
        </properties>
        <priority>2</priority>
    </rule>

    <rule name="AvoidApacheCommonsFileItemNonStreaming"
          language="java"
          message="FileItem.get or FileItem.getString should be avoided"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_performance.html#AvoidApacheCommonsFileItemNonStreaming">
        <description>
            Problem: Use of FileItem.get and FileItem.getString could exhaust memory since they load the entire file into memory&#13;
            Solution: Use streaming methods and buffering.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name
[ends-with(@Image, '.get') or ends-with(@Image, '.getString')]
[
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Image,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Image,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Image,
		'.')
)
]
]]>
                </value>
            </property>
        </properties>
    </rule>

<!-- END Included file 'common.xml' -->
</ruleset>
