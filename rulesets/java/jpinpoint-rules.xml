<?xml version="1.0" encoding="UTF-8"?>
<ruleset name="jpinpoint-rules" 
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd"> 

<description>
         jPinpoint specific rules for performance aware Java coding, sponsored by Rabobank.
</description>

<!-- IMPORTANT NOTICE: The content of this file is generated. Do not edit this file directly since changes may be lost when this file is regenerated! -->

<!-- BEGIN Included file 'common.xml' -->
    <rule name="AvoidCDIReferenceLeak"
          language="java"
          message="Explicit CDI references need to be destroyed otherwise they leak."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml05">
        <description>Problem: A proxy object is created by Contexts and Dependency Injection (CDI) for explicit references, they are not de-referenced implicitly and become a memory leak. &#13;
            Solution: Destroy the reference explicitly.
        (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select'
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
])
and not
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//PrimaryExpression[
PrimaryPrefix/Name/@Image='CDI.current'][PrimarySuffix/@Image = 'destroy']
[PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='CDI.current']/../../
PrimarySuffix[@Image = 'select']/ancestor::VariableDeclarator/VariableDeclaratorId/@Name
])]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class CDIStuff {

	private void bad() {
		MyClass o = CDI.current().select(MyClass.class).get();
		o.doStuff();
	    // bad - missing destroy in finally
	}

	private void good() {
		MyClass o = CDI.current().select(MyClass.class).get();
		try {
			o.doStuff();
		} finally {
			CDI.current().destroy(o); // good - destroy properly
		}
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendar"
          language="java"
          message="A Calendar is inefficient in memory usage."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#imu01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use Date, Java 8+ java.time.[Local/Zoned]DateTime.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//(Type)[pmd-java:typeIs('java.util.Calendar')]
,
//Name[starts-with(@Image, 'Calendar.')]
	         ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class CalendarStuff {
    Calendar field1; // bad

    private Calendar bad1() {
        return Calendar.getInstance();
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConstantsInInterface" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Interface defines constants. It may expose implementation details." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#voedos04">
        <description>Interface defines constants. Problem: Possibly exposes implementation details.  &#13;
            Solution: Make it a Class which cannot be instantiated, or an Enum. Use static imports.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
 //ClassOrInterfaceDeclaration[@Interface=true()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public interface Foo {
    static final Object CONST = new Object(); //bad
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidDecimalAndChoiceFormatAsField" class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false" language="java"
          message="Avoid using DecimalFormat or ChoiceFormat as field since it is thread-unsafe."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf01">
        <description>Problem: java.text.DecimalFormat and java.text.ChoiceFormat are thread-unsafe.&#13;
            Solution: usual solution is to create a new local one when needed in a method.
            (jpinpoint-rules)
        (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/VariableDeclarator/VariableInitializer/Expression[pmd-java:typeIs('java.text.DecimalFormat') or pmd-java:typeIs('java.text.ChoiceFormat')]
        ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidDuplicateAssignmentsInCases"
          message="Avoid duplicate assignments in different switch cases"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#SSC01">
        <description>
            Problem: Potential bug: expected are different assignments in different cases.&#13;
            Solution: assign different values in different cases, common assignments should be taken out of the switch.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//SwitchStatement/BlockStatement[
(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image
or
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/Expression/PrimaryExpression/PrimaryPrefix//Literal/@Image)
and
.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/PrimaryExpression/PrimaryPrefix/Name/@Image
=preceding-sibling::SwitchLabel/preceding-sibling::BlockStatement//AssignmentOperator/../../..//StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
not(.//AssignmentOperator/../../..//StatementExpression[not(pmd-java:typeIs('boolean'))]/Expression/PrimaryExpression/PrimarySuffix/Arguments/@Size > 0
or preceding-sibling::SwitchLabel[@Default=true()])
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidExposingMutableRecordState"
          language="java"
          message="Avoid exposing mutable state of the record. Use copyOf in the compact constructor."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#voedos06">
        <description>Problem: Internal state can be modified from outside of the record, through the implicit accessor method or by the caller of the constructor. Risk of thread-unsafety.
            Solution: Use the record compact constructor to defensively copy the (possibly) mutable object such as a List, Set or Map, e.g. with List.copyOf().
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//RecordDeclaration//RecordComponent/Type[(pmd-java:typeIs('java.util.Collection') or pmd-java:typeIs('java.util.Map'))
and
not(../VariableDeclaratorId/@Name = ancestor::RecordDeclaration/RecordBody/CompactConstructorDeclaration//StatementExpression
[Expression//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'copyOf')]]/PrimaryExpression/PrimaryPrefix/Name/@Image)]                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
record BadRecord(String name, List<String> list) {
}

record GoodRecord(String name, List<String> list) {
    public GoodRecord {
        list = List.copyOf(list);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidImplicitlyRecompilingRegex" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String regex method, Pattern.matches or FileSystem.getPathMatcher is used.
	   Implicitly compiles a regex pattern, can be expensive." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ireu01">
        <description>A regular expression is compiled implicitly on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Compile the regex pattern only once and assign it to a private static final Pattern field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(//MethodDeclaration//(PrimaryPrefix/Name[ends-with(@Image, '.replaceAll') or ends-with(@Image, '.replaceFirst') or @Image='Pattern.matches']
|PrimarySuffix[@Image = 'replaceAll' or ends-with(@Image, '.replaceFirst')])
/following::PrimarySuffix[1]/Arguments[ArgumentList/@Size=2]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.split') or ends-with(@Image, 'getPathMatcher')]/../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5 and
matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+')] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
(:--- not (if foreign field (with .), or field with short String or without regex char) ---:)
Name[contains(@Image, '.') or @Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6 or not
(matches(@Image, '[\.\$\|\(\)\[\]\{\}\^\?\*\+\\]+'))]
]/VariableDeclaratorId/@Name])
]
,
//MethodDeclaration//PrimarySuffix[@Image='getPathMatcher']/../PrimarySuffix/Arguments[ArgumentList/@Size=1]/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
and not(../PrimarySuffix)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]]/VariableDeclaratorId/@Name])
]
,
(: --- String.matches called on formalparams, locals and fields --- :)
//MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.matches')]
[
(exists(index-of((ancestor::MethodDeclaration//FormalParameter[pmd-java:typeIs('java.lang.String')]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[pmd-java:typeIs('java.lang.String')]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
or
exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('java.lang.String')]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.'))))
and
(: for matches param is >5 literal or something named :)
../../PrimarySuffix/Arguments[ArgumentList/@Size=1]//Expression[1]//PrimaryPrefix[
Literal[string-length(@Image) > 5] or Name
(: exclude method calls :)
and not(../PrimarySuffix)
(: exclude for param is method arg or local :)
and not (
Name/@Image=ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
(: exclude for param is short fields :)
and not (
Name[@Image=ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator[
VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) < 6]
]/VariableDeclaratorId/@Name])
]])
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
//bad
String bad_replaceInnerLineBreakBySpace() {
    return text.replaceAll("([^\\.\\n])\\n", "$1 "); // bad
}

// good
private static final Pattern INNER_LINE_BREAK_PATTERN = Pattern.compile("([^\\.\\n])\\n");

String good_replaceInnerLineBreakBySpace() {
    return INNER_LINE_BREAK_PATTERN.matcher(text).replaceAll("$1 "); // good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidInMemoryStreamingDefaultConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="The default capacity or smaller is used for ByteArrayOutputStream or StringWriter, it usually needs expensive expansions." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio01">
        <description>Problem: The default constructor of ByteArrayOutputStream creates a 32 bytes initial capacity and for StringWriter 16 chars. Problem: Such a small buffer as capacity usually needs several expensive expansions.&#13;
            Solution: Presize the ByteArrayOutputStream or StringWriter with an initial capacity such that an expansion is not needed in most cases, typically much larger than 32, for instance 4096.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.ByteArrayOutputStream') or pmd-java:typeIs('java.io.StringWriter')]
[not(../Arguments/ArgumentList)
or
(pmd-java:typeIs('java.io.ByteArrayOutputStream') and (../Arguments//Literal[number(@Image) <= 32] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Name) <= 32]/@Image]))
or
(pmd-java:typeIs('java.io.StringWriter') and (../Arguments//Literal[number(@Image) <= 16] or ../Arguments//Name[@Image = ancestor::ClassOrInterfaceDeclaration//FieldDeclaration//VariableDeclaratorId[number(..//Literal/@Image) <= 16]/@Name]))
]/..
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static void bad()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(); //bad
        StringWriter sw = new StringWriter(); //bad
        baos = new ByteArrayOutputStream(32); //bad - not larger than default
    }
}
class Good {
    public static void good()  {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(8192); // 8 kiB
        StringWriter sw = new StringWriter(2048);
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidLoadingAllFromFile"
          language="java"
          message="Files.readAll methods load all bytes from a file into memory: a risk of memory problems."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio03">
        <description>Problem: Files.readAllBytes and Files.readAllLines load all bytes from a file into the heap memory.
            This may result in an OutOfMemoryError crash, or long gc pauses and slow responses.
            Solution: Stream-through: use streaming all the way, don't store the whole thing in memory, don't use byte arrays.
            Often, functionality can be achieved in a streaming way.
            Note: not a problem for small files.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[@Image='Files.readAllBytes' or @Image='Files.readAllLines']
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    void bad(Path path) {
        byte[] fileBytes = Files.readAllBytes(path); // bad
        List<String> fileLines = Files.readAllLines(path); // bad
        // process bytes / lines
    }
}

class Good {
    void good(Path in) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(in)) {
            String line = reader.readLine();
            // process line by line
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLombokAnnotationForNonExistentFields"
          language="java"
          message="Avoid Lombok annotations for fields of a class while the class has no fields."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="">
        <description>Problem: Lombok annotations for fields [@Getter, @Setter, @EqualsAndHashCode, @Value, @Data] are of no use and confusing in case the class has no fields.&#13;
            Solution: Remove the Lombok annotation.
        (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)/Annotation
    [MarkerAnnotation/Name[@Image='Getter' or @Image='Setter' or @Image='Value' or @Image='Data' or @Image='EqualsAndHashCode']]
    [count(..//FieldDeclaration) = 0]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule,unused" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
        @Data // bad
        public class BusinessException extends RuntimeException {
            // no fields, no methods
        }
            ]]>
        </example>
    </rule>

    <rule name="AvoidMultipleConcatStatements" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Multiple statements concatenate to the same String. Use StringBuilder append." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu02">
        <description>Multiple statements concatenate to the same String. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use StringBuilder.append.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name
[@Image=./../../../../../../../../../../../..//VariableDeclaratorId/@Name
and
./../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]
]
/../../../AssignmentOperator[@Image='+=']/
../Expression//PrimaryExpression/PrimaryPrefix/Name) > 1]/BlockStatement[position()=last()]
|
//MethodDeclaration/Block[
count(
./BlockStatement/Statement//StatementExpression[
./PrimaryExpression/PrimaryPrefix/Name[
@Image = ../../../Expression/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
and
@Image = ./../../../../../../../..//VariableDeclaratorId/../../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.String')]/../../../VariableDeclarator/VariableDeclaratorId/@Name
]
]) > 1 ]//BlockStatement[position()=last()]//StatementExpression/Expression/AdditiveExpression[@Operator = '+']
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidMutableLists"
          language="java"
          message="List is not modified after object construction, make it immutable or unmodifiable"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml01">
        <description>Problem: A list which is unnecessarily mutable may accidentally be added to and cause a memory leak. &#13;
            Solution: Make it impossible to modify the list after object construction/initialization: use Java 9 List.of, Java 11 List.copyOf, Collections.unmodifiableList or Guava ImmutableList.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    (: a field of type List :)
    //FieldDeclaration[pmd-java:typeIs('java.util.List')]
    (: exclude ConfigurationProperties classes :)
    [count(ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties']) = 0]
    (: exclude when JPA annotated :)
    [count(../Annotation//Name[@Image='OneToMany' or @Image='ManyToMany']) = 0]
    //VariableDeclaratorId[
    (: with a method defined at that level that does not use the field with a modify operation (case field.modOp) :)
    not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
    starts-with(substring-after(@Image, '.'), 'add') or
    starts-with(substring-after(@Image, '.'), 'remove') or
    substring-after(@Image, '.') = 'set' or
    substring-after(@Image, '.') = 'clear' or
    substring-after(@Image, '.') = 'replaceAll' or
    substring-after(@Image, '.') = 'retainAll'
    ]/(substring-before(concat(@Image, '.'), '.')))]
    [ (: and case this.field.modOp() :)
not(@Name = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration//PrimaryExpression
/PrimarySuffix[starts-with(@Image, 'add') or starts-with(@Image, 'remove') or @Image = 'set' or @Image = 'clear' or @Image = 'replaceAll' or @Image = 'retainAll']
/preceding-sibling::PrimarySuffix/@Image)
    ]     (: and :)
    [( (: field is initialized with List allocation :)
    ../VariableInitializer/Expression//AllocationExpression[pmd-java:typeIs('java.util.List')]
    or
    (: or static block / constructor has field initialized with List allocation :)
    ancestor::ClassOrInterfaceBody//(Initializer|ConstructorDeclaration)//AssignmentOperator[exists(../Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.List')])]/..//Name/@Image = @Name
    or
    (: or constructor has a simple assignment to the field, param of literal: no arguments :)
    ancestor::ClassOrInterfaceBody//ConstructorDeclaration//AssignmentOperator[exists(../Expression[pmd-java:typeIs('java.util.List')]) and not(exists(../Expression/PrimaryExpression/PrimarySuffix))]/..//Name/@Image = @Name
    )]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,pitfall" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class Bad {
    List unmutated = new ArrayList(Arrays.asList("one", "two")); // bad
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
public class Good {
    List unmutated1 = Collections.unmodifiableList(Arrays.asList("one", "two")); // Java 8
    List unmutated2 = List.of("one", "two"); // Java 9+
    List mutated = new ArrayList();

    private void mutate() {
        mutated.add("one");
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReStreamingEnumValues"
          language="java"
          message="Avoid re-streaming enum values to find a value by a field."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc07">
        <description>Problem: the time to find element is O(n); n = the number of enum values. This identical processing is executed for every call. Considered problematic when n > 3.
            Solution: use a static field-to-enum-value Map. Access time is O(1), provided the hashCode is well-defined.
            For one String field, usually toString returns that field. Implement a fromString method to provide the reverse conversion by using the map.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //EnumDeclaration/EnumBody[count(EnumConstant) > 3]//MethodDeclaration/Block//PrimaryExpression
    [PrimaryPrefix/Name[@Image='Arrays.stream' or @Image='Stream.of']]
    [//PrimaryExpression/PrimaryPrefix/Name[@Image = 'values' or @Image = concat(ancestor::EnumDeclaration/@SimpleName, '.values')]]
    [PrimarySuffix[starts-with(@Image, 'find')]]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
// BAD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Stream.of(values()).filter(v -> v.toString().equals(name)).findAny(); // bad: iterates for every call, O(n) access time
    }
}

Usage: `Fruit f = Fruit.fromString("banana");`

// GOOD
public enum Fruit {
    APPLE("apple"),
    ORANGE("orange"),
    BANANA("banana"),
    KIWI("kiwi");

    private static final Map<String, Fruit> nameToValue =
            Stream.of(values()).collect(toMap(Object::toString, v -> v));
    private final String name;

    Fruit(String name) { this.name = name; }
    @Override public String toString() { return name; }
    public static Optional<Fruit> fromString(String name) {
        return Optional.ofNullable(nameToValue.get(name)); // good, get from Map, O(1) access time
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecompilingPatterns" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Pattern.compile is used in a method. Compiling a regex pattern can be expensive, make it a static final field." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ireu02">
        <description>A regular expression is compiled on every invocation. Problem: this can be expensive, depending on the length of the regular expression.&#13;
            Solution: Usually a pattern is a literal, not dynamic and can be compiled only once. Assign it to a private static field. java.util.Pattern objects are thread-safe so they can be shared among threads.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.util.regex.Pattern') and ends-with(@Image, '.compile') and
count(../../PrimarySuffix[1]/Arguments/ArgumentList/Expression//PrimaryExpression) = 1
and not (
../../PrimarySuffix[1]/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static final String STR_PAT1 = "[A-Z][a-z]+";

    public static void bad() {
        Pattern p1 = Pattern.compile(STR_PAT1); // bad
        Pattern p2 = Pattern.compile("(?=\\p{Lu})"); // bad
        boolean b = p1.matcher("Start ").matches();
    }
}
class Good {
    public static final Pattern PAT1 = Pattern.compile("[A-Z][a-z]+");
    public static final Pattern PAT2 = Pattern.compile("(?=\\p{Lu})");

    public static void good() {
        boolean b = PAT1.matcher("Start ").matches();
    }
}
            ]]>
        </example>

    </rule>

    <rule name="AvoidRecompilingXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression is created and compiled every time. Beware it is thread-unsafe." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux02">
        <description>XPathExpression is created and compiled on every method call, compiled possibly implicitly by XPath::evaluate.
            Problem: Creation of XPath and compilation of XPathExpression takes time. It may slow down your application. &#13;
            Solution: 1. Avoid XPath usage. 2. Compile the xpath expression as String into a XPathExpression. However, since XPath and XPathExpression classes are thread-unsafe, they are not easily cached. Caching it in a ThreadLocal may be a solution.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration//ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/(PrimarySuffix|PrimaryPrefix/Name)[ends-with(@Image,'newXPath')]
/ancestor::MethodDeclaration
//PrimaryExpression/(PrimarySuffix|PrimaryPrefix/Name)[ends-with(@Image, 'compile')
or (pmd-java:typeIs('javax.xml.xpath.XPath') and ends-with(@Image, 'evaluate'))]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public static NodeList bad1(Document doc) {
        XPath xpath = XPathFactory.newInstance().newXPath();
        XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()"); // bad
        return (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
    }
    public static NodeList bad2(Document doc) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        String xPathQuery = "//book[author='Isaac Asimov']/title/text()";
        return (NodeList) xpath.evaluate(xPathQuery, doc, XPathConstants.NODESET); // bad
    }
}

class Good {
    private static final ThreadLocal<XPathFactory> tlFac = ThreadLocal.withInitial(XPathFactory::newInstance);
    private static final ThreadLocal<XPathExpression> tlExpr;
    static {
        XPath xpath = tlFac.get().newXPath();
        try {
            XPathExpression expr = xpath.compile("//book[author='Isaac Asimov']/title/text()");
            tlExpr = ThreadLocal.withInitial(() -> expr); // good
        } catch (XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }
    public static NodeList good(Document doc) throws XPathExpressionException {
        return (NodeList) tlExpr.get().evaluate(doc, XPathConstants.NODESET); // good
    }
            ]]>
        </example>


    </rule>

    <rule name="AvoidRecreatingDateTimeFormatter"
          message="Avoid recreating DateTimeFormatter, it is relatively expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf02">
        <description>
            Problem: Recreating a DateTimeFormatter is relatively expensive.&#13;
            Solution: Java 8+ java.time.DateTimeFormatter is thread-safe and can be shared among threads. Create the
            formatter from a pattern only once, to initialize a static final field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
    //FieldDeclaration[@Final=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //FieldDeclaration[@Final=true() and @Static=false()]//ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')](: has assignment, otherwise check in constructor :)[ancestor::ClassOrInterfaceBodyDeclaration//VariableInitializer],
    //ConstructorDeclaration/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of constructor call :)[not(ancestor::BlockStatement//Expression/PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=ancestor::ConstructorDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatter') or pmd-java:typeIs('org.threeten.bp.format.DateTimeFormatter') or pmd-java:typeIs('java.time.format.DateTimeFormatter')],
    //MethodDeclaration/Block/BlockStatement//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormatter.ofPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'ISODateTimeFormat.')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, 'DateTimeFormat.fullDateTime')],
    //MethodDeclaration/Block/BlockStatement//Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'DateTimeFormat.forPattern')]
(: check if parameter is argument of method call :)[not(ancestor::LocalVariableDeclaration//PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Name)],
    //MethodDeclaration/Block/BlockStatement//Expression//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.format.DateTimeFormatterBuilder')][ancestor::PrimaryExpression/PrimarySuffix[@Image="toFormatter"]]
                   ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidRecreatingSecurityProviders"
          language="java"
          message="Avoid re-creating security providers, this is expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuosf01">
        <description>Problem: Creating a security provider is expensive because of loading of algorithms and other classes. Additionally, it uses synchronized which leads to lock contention when used with multiple threads.
            Solution: This only needs to happen once in the JVM lifetime, because once loaded, the provider is typically available from the Security class. Create the security provider only once: only in case it is nog available from the Security class, yet.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[not((@Name='main' and @Static=true())or ../Annotation//Name/@Image='PostConstruct'
or .//IfStatement//EqualityExpression[@Operator='=='][
.//PrimaryExpression[pmd-java:typeIs('java.security.Provider')] and .//NullLiteral])]
//AllocationExpression[pmd-java:typeIs('java.security.Provider')]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.security.*;
import javax.crypto.*;
import org.bouncycastle.jce.provider.*;

class Foo {
    public Cipher initBlowfishBad() throws GeneralSecurityException {
        Security.addProvider(new BouncyCastleProvider()); // bad
        // build a Cipher
    }

    public Cipher initBlowfishGood() throws GeneralSecurityException {
        Provider bouncyCastleProvider = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);
        if (bouncyCastleProvider == null) {
            bouncyCastleProvider = new BouncyCastleProvider();
            Security.addProvider(bouncyCastleProvider);
        }
        // build a Cipher
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidReflectionInToStringAndHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Reflection is used in toString or hashCode, which is expensive." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#uuor01">
        <description>Problem: Reflection is relatively expensive. &#13;
            Solution: Avoid to use reflection. Use the non-reflective, explicit way, like generation by IDE or Lombok.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/AllocationExpression/ClassOrInterfaceType
	[
		pmd-java:typeIs('org.apache.commons.lang.builder.EqualsBuilder')
		or pmd-java:typeIs('org.apache.commons.lang.builder.HashCodeBuilder')
	]
[../../../PrimarySuffix[1]
	[
		@Image='reflectionEquals'
		or @Image='reflectionHashCode'
	]
] |
//PrimaryPrefix/Name
	[
		@Image='EqualsBuilder.reflectionEquals'
		or @Image='HashCodeBuilder.reflectionHashCode'
	]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidSimpleDateFormat" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="SimpleDateFormat is used. Since it is thread-unsafe, it needs expensive recreation."  typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#idtf01">
        <description>Problem: java.util.SimpleDateFormat is thread-unsafe. The usual solution is to create a new one when needed in a method. Creating SimpleDateFormat is relatively expensive. &#13;
            Solution: Use java.time.DateTimeFormatter. These classes are immutable, thus thread-safe and can be made static.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[
    pmd-java:typeIs('java.text.SimpleDateFormat')
    and not (ancestor::ClassOrInterfaceBodyDeclaration//PrimaryPrefix/Name[
       ends-with(@Image, 'setDateFormat')
       and (   pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
            or pmd-java:typeIs('com.fasterxml.jackson.dataformat.xml.XmlMapper'))
    ])
]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidStringBuffer" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="StringBuffer is used. It introduces locking overhead, use StringBuilder." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu01" >
        <description>Problem: StringBuffer introduces locking overhead because it is thread safe. Its thread-safety is rarely needed.&#13;
            Solution: Replace StringBuffer by StringBuilder.  (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    //VariableDeclarator[../Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.lang.StringBuffer')]]
                    ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidTimeUnitConfusion" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//Type/PrimitiveType/../..//VariableDeclaratorId[ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl') or ends-with(lower-case(@Name), 'timestamp')]
,
(: @Value :)
//SingleMemberAnnotation/Name[@Image='Value']/..//Literal[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"') or ends-with(lower-case(@Image), 'timestamp}"')]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidTimeUnitConfusionPMD7" since="7.0" class="net.sourceforge.pmd.lang.rule.XPathRule" language="java" message="A primitive variable identifier or @Value member ends with time, timeout, duration or similar: time unit is missing." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI19">
        <description>Problem: Time unit like hours, seconds, milliseconds is not specified and may be assumed differently by readers.
            Different assumptions will lead to errors or hidden problems like ineffective caches.&#13;
            Solution: Specify the time unit in the identifier, like connectTimeoutMillis. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: for fields, formal parameters and local variables :)
//VariableDeclaratorId[preceding-sibling::PrimitiveType|../../PrimitiveType][ends-with(lower-case(@Name), 'timetolive') or ends-with(lower-case(@Name), 'time_to_live') or
ends-with(lower-case(@Name), 'time')
or ends-with(lower-case(@Name), 'timeout') or ends-with(lower-case(@Name), 'time_out')
or ends-with(lower-case(@Name), 'duration') or ends-with(lower-case(@Name), 'durationout') or ends-with(lower-case(@Name), 'duration_out')
or ends-with(lower-case(@Name), 'ttl')]
,
(: @Value :)
//Annotation[@SimpleName='Value']//StringLiteral[ends-with(lower-case(@Image), 'timetolive') or ends-with(lower-case(@Image), 'expirytime}"')
or ends-with(lower-case(@Image), 'timeout}"') or ends-with(lower-case(@Image), 'ttl}"')]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@Autowired
public RetrieveCache(final @Value("${cache.expiryTime}") long timeToLive) { // 2x bad
}
@Autowired
public RetrieveCache(final @Value("${cache.expiryTimeMillis}") long timeToLiveMillis) { // 2x good
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnconditionalBuiltLogStrings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Log String is built irrespective of log level." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il02">
        <description>A String to be logged is built unconditionally. Problem: String building, concatenation and/or other operations happen before the debug, trace or info method executes, so independent of the need to actually log. Concatenation is relatively expensive. &#13;
            Solution: Build the String conditionally on the log level, within an if statement.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement/StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') = 'append')
and count(ancestor::IfStatement) = 0
and
count(ancestor::MethodDeclaration/Block/BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[
(substring-before(@Image, '.') =
ancestor::MethodDeclaration//BlockStatement/Statement//PrimaryExpression/PrimaryPrefix/Name[ends-with
(@Image, '.debug') or ends-with(@Image, '.trace') or ends-with(@Image, '.info')]
/../../PrimarySuffix/Arguments/ArgumentList//PrimaryExpression/PrimaryPrefix/Name/attribute::Image
and
substring-after(@Image, '.') != 'append')]) = 0
]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnnecessaryStringBuilderCreation"
          language="java"
          message="Use concatenation (+) instead of new StringBuilder if only one statement."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu05">
        <description>Problem: Creating a StringBuilder and using append is more verbose, less readable and less maintainable than simply using String concatenation (+).
            For one statement resulting in a String, creating a StringBuilder and using append is not faster than simply using concatenation.&#13;
            Solution: Simply concatenate Strings in one statement, it is more concise, better readable and more maintainable.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: append used in one chained statement on allocated StringBuilder and with chained toString :)
//MethodDeclaration//Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/../../../PrimarySuffix[@Image = "toString"]/../PrimarySuffix[@Image = "append"][1] (: only report first append in chain :)
|
(: or :)
(: append on builder var, where var is allocated as StringBuilder :)
//MethodDeclaration//Block//PrimaryPrefix/Name[ends-with(@Image, '.append') and starts-with(@Image,
ancestor::Block//AllocationExpression/ClassOrInterfaceType[@Image="StringBuilder" or @Image = "StringBuffer"]
/ancestor::VariableDeclarator/VariableDeclaratorId/@Name[0])
and
(
(: and either 1. toString is called in a chain after append :)
../../PrimarySuffix[@Image = 'toString'] or
(: or 2. toString is called on the var in same block :)
concat(substring-before(@Image, '.'), '.toString') = ancestor::Block//PrimaryPrefix/Name[ends-with(@Image, '.toString')]/@Image)
(: and not append on var used in inner block like a ForStatement :)
and not(ancestor::Block//Block//PrimaryPrefix/Name[ends-with(@Image, '.append')])
(: and not append in lambda expression, issue 195 :)
and not(ancestor::LambdaExpression)
(: and var not passed as argument to method :)
and not(substring-before(@Image, '.') = ancestor::Block//Statement//PrimarySuffix/Arguments//Name/@Image)
]
	         ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    String name;
    String value;

    public String bad() {
        return new StringBuilder()
           .append(name) // bad
           .append(" = ")// bad
           .append(value)// bad
           .toString();
    }

    public String good() {
        return name + " = " + value;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidWideScopeXPathExpression" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathExpression targets a wide scope, this is potentially slow." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux01">
        <description>The XPathExpression targets a wide scope since it starts with '//'. Problem: XPath has to search in a wide scope for occurrences, this may take a while. &#13;
            Solution: 1. Avoid XPath usage. 2. Make the scope as narrow as possible, do not start with '//'.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
//PrimaryExpression/PrimarySuffix[
Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/
Literal[starts-with(@Image, '"//')]
and
../PrimaryPrefix/Name[ends-with(@Image, '.compile')]
]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidXPathAPIUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPathAPI is used. XPathAPI implementation has bad performance." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux03">
        <description>XPathAPI is used. Problem: XPathAPI implementation is slow.&#13;
            Solution: 1. try to avoid using XPathAPI. 2. improve performance by using jvm parameters and possibly CachedXPathAPI.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[starts-with(@Image, 'XPathAPI.')]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidXPathUsage" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XPath is used. XPath implementation has bad performance." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ux03">
        <description>XPath is used. Problem: XPath implementation is slow.&#13;
            Solution: 1. avoid using XPath. 2. improve performance by using jvm parameters and possibly Cached XPath API.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/
ClassOrInterfaceBodyDeclaration
//PrimaryExpression/PrimaryPrefix/Name[@Image='XPathFactory.newInstance']
[not (ancestor::FieldDeclaration//ClassOrInterfaceType/@Image = 'ThreadLocal')]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="BufferFileStreaming"
          language="java"
          message="FileInputStream and FileOutputStream are not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio05">
        <description>Problem: With FileInputStream and FileOutputStream, file access is not buffered.
            The stream is read-from/written-to file byte by byte, where each operating system call has its overhead, which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use BufferedOutput/InputStream which has a buffer size of 8 kB by default to write at once. Make sure to close it after use.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Resource//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.FileInputStream') or pmd-java:typeIs('java.io.FileOutputStream')]
[not (ancestor::AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
[not (ancestor::TryStatement//AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.io.BufferedInputStream') or pmd-java:typeIs('BufferedOutputStream')])]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.io.*;

class BufferFileStreaming {
    void bad(String inputFilename, String outputFilename) {
        try (FileInputStream fis = new FileInputStream(inputFilename)) { // bad
            //use fis
        }
    }
    void good(String inputFilename, String outputFilename) {
        try (InputStream bfis = new BufferedInputStream(new FileInputStream(inputFilename))) { // good
            //use bfis
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferFilesNewStream"
          language="java"
          message="Files.newInputStream or Files.newOutputStream is not buffered, add buffering."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio06">
        <description>Problem: Files.newInputStream or Files.newOutputStream is not buffered.
            The stream is read from/written to file byte by byte, where each operating system call has its overhead which makes it slow.
            Solution: Use buffering to read/write a chunk of bytes at once with much lower overhead.
            Use e.g. BufferedInputStream or BufferedOutputStream which has a buffer size of 8 kB to read/write at once. Make sure to close it after use.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newOutputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedOutputStream')]) = 0]]
,
//PrimaryExpression/PrimaryPrefix/Name[pmd-java:typeIs('java.nio.file.Files') and ends-with(@Image,'.newInputStream')]
[ancestor::MethodDeclaration[count(.//AllocationExpression[pmd-java:typeIs('java.io.BufferedInputStream')]) = 0
and (not(.//PrimaryPrefix/Name[pmd-java:typeIs('org.apache.commons.io.IOUtils') and starts-with(@Image, 'IOUtils.read')]))
]]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    OutputStream badO(String path) throws IOException {
        return java.nio.file.Files.newOutputStream(Paths.get(path)); // bad
    }
    OutputStream goodO(String path) throws IOException {
        return new BufferedOutputStream(java.nio.file.Files.newOutputStream(Paths.get(path)));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="EqualsOperationInconsistentWithHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals uses a conversion inconsistent with hashCode." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode and use identical conversions like toUpperCase() in both when needed. Don't use equalsIgnoreCase. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(concat(@Name, '.toLowerCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image ) >
(concat(@Name, '.toLowerCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image)
]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals']/Block//(Name|PrimarySuffix)[ends-with(@Image,'.toLowerCase')]
,
//FieldDeclaration//VariableDeclaratorId[
(concat(@Name, '.toUpperCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image ) >
(concat(@Name, '.toUpperCase') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode'and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image)
]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals']/Block//(Name|PrimarySuffix)[ends-with(@Image,'.toUpperCase')]
,
//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//Name[ends-with(@Image, 'equalsIgnoreCase')]

                ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        if (field1 != null ? !field1.equals(that.field1) : that.field1 != null) return false;
        return field2 != null ? field2.equalsIgnoreCase(that.field2) : that.field2 == null; // ignore case
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad2 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad2 that = (Bad2) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase()); // bad
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad3 {
    String field1;
    String field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad3 that = (Bad3) o;
        return Objects.equals(field1.toUpperCase(), that.field1.toUpperCase()) && // bad
                Objects.equals((field2.toLowerCase()), that.field2.toLowerCase());
    }
    public int hashCode() {
        return Objects.hash(field1.toLowerCase(), field2.toLowerCase());
    }
}

class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good that = (Good) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2.toUpperCase(), that.field2.toUpperCase()); // ignore case
    }
    public int hashCode() {
        return Objects.hash(field1, field2.toUpperCase()); // ignore case
    }
}
            ]]>
        </example>
    </rule>

    <rule name="FieldOfHashCodeMissingInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals does not use all fields used by hashCode." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah03">
        <description>Problem: Equal objects may have different hashCodes and end-up in different buckets of a Map/Set. Strange things can happen like adding an object to a Set and not being able to find it back.&#13;
            Solution: When objects are equal, hashCode needs to be equal, too. Use the same fields in equals and hashCode. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) <
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Good1 {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Good1 that = (Good1) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1); // field2 missing
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

            ]]>
        </example>
    </rule>

    <rule name="HashCodeOnlyCallsSuper"
          language="java"
          message="hashCode only calls super."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio03">
        <description>Problem: when equals is implemented, hashCode needs to be implemented, too; and if objects are equal, hashCode needs to be equal, too. If hashCode only calls super.hashCode, it is effectively not implemented.
            Strange things can happen, for instance, if super.hashCode calls Object.hashCode, it is unique for each object and when used in Set or as key in Map, equal objects can duplicate in Set, and keys not found in Map.
            Solution: implement hashCode properly, consistent with equals. Meet the equals and hashCode contracts. If objects are equal, hashCode needs to be equal, too. See Effective Java.
        (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and @Public=true() and @Static=false()]
/ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and MethodDeclarator/FormalParameters/@Size=0 and @Public=true() and @Static=false()]
/Block[count(./BlockStatement/Statement) = 1][count(.//ArgumentList) = 0]//PrimaryExpression[PrimaryPrefix[@SuperModifier=true()]]/PrimarySuffix[@Image='hashCode']
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad that = (Bad) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return super.hashCode(); // bad
    }
}

class Good {
    String field1;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bad1 that = (Bad1) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="ImplementEqualsHashCodeOnValueObjects"
          message="Equals and/or hashCode is missing for a value object."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#incorrect-equals-and-hashcode">
        <description>
            Problem: If equals and hashCode are not defined, they don't meet the programmer's expectations and the requirements for use with the collections API. It may result in unexpected, undesired behavior.&#13;
            Solution: Add proper equals and hashCode methods that meet the equals-hashCode contract to all objects which might anyhow be put in a Map, Set or other collection. Or use Lombok @EqualsAndHashCode, @Value or @Data. Also holds for inner classes.
            If the object should never be checked for equality or used in a collection, also add those methods and let them throw UnsupportedOperationException to fail fast. @Xml... , @Entity, Throwable and Executor objects are ignored because they are assumed to be not used as value objects.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(:-- top level class - not annotated that would make it a non-value object --:)
//TypeDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'
or @Image='Singleton' or @Image='Component' or @Image='Service' or @Image='Repository' or @Image='Configuration' or @Image='Endpoint' or @Image='RestController' or @Image='ControllerAdvice'
or starts-with(@Image, 'Xml') or @Image='Entity' or @Image='Embeddable' or @Image='MappedSuperclass'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[
(not (../Annotation//Name[@Image = 'XmlElement']))
and
(:-- a getter with result type of a field --:)
(
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)
(:-- and class has no equals or hashCode method --:)
and (not (ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='equals' or @Name='hashCode']))
(:-- and class has a toString and #fields <= 1+#getters --:)
and
((ancestor::ClassOrInterfaceBody//MethodDeclaration[@Public=true() and @Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[ends-with(@SimpleName, 'Dto')]
or
(:-- #fields == #getters --:)
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Public=true() and @Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
or
ancestor::TypeDeclaration/Annotation//Name[@Image='Getter']
)]
]/.. (:--up to class --:)

(:-- inner classes --:)
,
//ClassOrInterfaceBodyDeclaration[not(./Annotation//Name[@Image='Data' or @Image='Value' or @Image='EqualsAndHashCode'])]
/ClassOrInterfaceDeclaration[@Interface=false() and @Abstract=false() and not(pmd-java:typeIs('java.util.concurrent.Executor') or pmd-java:typeIs('java.lang.Throwable'))]
/ClassOrInterfaceBody[ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]
[(
ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]
[ResultType/Type/ReferenceType/ClassOrInterfaceType/@Image =
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]/Type/ReferenceType/ClassOrInterfaceType/@Image]
)
and
(not (
ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='equals'])
)
and
((ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Static=false() and @Name='toString']
and
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) <=
(1 + count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2]))
)
or
ancestor::ClassOrInterfaceDeclaration[1][ends-with(@SimpleName, 'Dto')]
or
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]) =
count(ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
[@Static=false() and starts-with(@Name, 'get') and string-length(@Name) > 3 or starts-with(@Name, 'is') and string-length(@Name) > 2])
)]
or
ancestor::ClassOrInterfaceBodyDeclaration[1]/Annotation//Name[@Image='Getter']
]/.. (:--up to class --:)
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,unpredictable" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Getters { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";

    public String getSomeState1() {
        return someState1;
    }
    public String getSomeState2() {
        return someState2;
    }
}

@Getter
class LombokGetterBad { // bad
    private String someState1 = "some1";
    private String someState2 = "some2";
}

@Getter
@EqualsAndHashCode
class LombokGetterGood {
    private String someState1 = "some1";
    private String someState2 = "some2";
}
            ]]>
        </example>
    </rule>

    <rule name="ImproperVariableName"
          language="java"
          message="Give variables and fields a meaningful name."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#m01">
        <description>Problem: Variables like 'var3' and fields like 'FOUR = 4', do not express what they are used for. This is bad for maintainability.&#13;
            Solution: Let variable names express what they are used for, like 'key' and 'MAX_KEYS = 4'
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//VariableDeclaratorId[matches(@Name, 'VALUE|VAL|INTEGER|INT|LONG|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY', 'i')
(: not allowed only as uppercase :)
and (replace(@Name, 'VALUE|VAL|NUMBER|NUM|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '') = ''
   (: not allowed as lower and uppercase :)
   or replace(@Name, 'INTEGER|INT|LONG|[0-9]+|ZERO|ONE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|TWENTY|_', '', 'i') = '')
or starts-with(@Name, 'var') and number(substring-after(@Name, 'var'))]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,confusing,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    private static final int FOUR_ZERO_NINE_SIX = 4096; // bad
    private static int six = 6; // bad
    private int five = 6; // really bad
    private static final int SIXTIES_START = 1960; // good

    void bar() {
        String var1 = "baz"; // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MDCPutWithoutRemove" message="MDC put is used without finally remove." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IL04">
        <description>
            MDC values are added for logging, but not removed. Problem: MDC values can leak to other user transactions (requests) and log incorrect information. Solution: remove the MDC value in a finally clause.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.put']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)[not(@Image=
(ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']/Block)//Name[@Image='MDC.remove']
/../../PrimarySuffix/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/(Name|Literal)/@Image)
and not((ancestor::MethodDeclaration//TryStatement/FinallyStatement//StatementExpression|ancestor::ClassOrInterfaceBody//MethodDeclaration[@Name='afterCompletion' or @Name='postHandle']/Block)//Name[@Image='MDC.clear'])
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    public void bad() {
        MDC.put("levelKey1", "levelName1"); // bad, not removed in finally
        MDC.put("levelKey2", "levelName2"); // bad, not removed at all
        doStuff();
        MDC.remove("levelKey1");
    }
}

class Good {
    public void good() {
        try {
            MDC.put("levelKey1", "levelName1");
            MDC.put("levelKey2", "levelName2");
            doStuff();
        } finally {
            MDC.remove("levelKey1");
            MDC.remove("levelKey2");
        }
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MinimizeAttributesInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Attribute is set in the session, yet not removed. This may bloat the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu01">
        <description>An attribute is set in the session and not removed. Problem: This may be a large object and data in the sessions takes heap space and stay in the session until time-out. This may take substantial heap space.&#13;
            Solution: remove the attribute if not really needed in the session, remove it from the session as soon as possible. Alternatively, use render parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/MethodDeclaration[../..//(VariableDeclaratorId |ReturnStatement/Expression)[pmd-java:typeIs('javax.portlet.PortletSession') or pmd-java:typeIs('javax.servlet.http.HttpSession')]]
/Block/BlockStatement/Statement[
./StatementExpression/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setAttribute')]
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'removeAttribute')]
)]]
,
//ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement[
.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/ancestor::ClassOrInterfaceBody[not(
ClassOrInterfaceBodyDeclaration//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[@Image = 'PortletUtils.setSessionAttribute']
/../../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral
)]]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    PortletSession session; // same for HttpSession
    public void setAttribute(String name, Object obj) {
	    session.setAttribute(name, obj);                 // bad
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
}

class Good {
    PortletSession session; // same for HttpSession
	public void setAttribute(String name, final Object obj) {
		session.setAttribute(name, obj);
	}
	public Object getAttribute(String name) {
		return session.getAttribute(name);
	}
	public void removeAttribute(String name) {
		session.removeAttribute(name);
	}
}
            ]]>
        </example>
    </rule>

    <rule name="MissingEqualsAndHashCodeWithGetterSetter"
          language="java"
          message="Equals and/or hashCode is missing in a class with lombok @Getter or @Setter."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah01">
        <description>Problem: If only the @Setter and/or @Getter annotation is used, and equals and hashcode are not defined, this is probably a mistake. The object has fields and if used in a collection or with equality, it will not behave as expected.
            Solution: include equals and hashCode e.g. by @EqualsAndHashCode or usually better @Data instead of @Setter/@Getter, however, are setters really needed? Prefer immutability, so @Value, combined with @Builder, with @Singular for collection fields.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration[./Annotation[pmd-java:typeIs('lombok.Getter') or pmd-java:typeIs('lombok.Setter')]
    and not(./Annotation[pmd-java:typeIs('lombok.EqualsAndHashCode')] or EnumDeclaration
        or (.//MethodDeclaration[@Name='equals'][ResultType/Type[@TypeImage='boolean']][MethodDeclarator/FormalParameters[@Size=1]/FormalParameter[pmd-java:typeIs('java.lang.Object')]]
            and .//MethodDeclaration[@Name='hashCode'][ResultType/Type[@TypeImage='int']][MethodDeclarator/FormalParameters[@Size=0]]))
]
/Annotation[pmd-java:typeIs('lombok.Getter') or pmd-java:typeIs('lombok.Setter')]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,correctness" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import lombok.*;

@Getter @Setter
// no equals/hashcode annotation
class MissingEqualsHashCodeWithGetterSetterBad { // bad
    String field1;
    String field2;
    // no equals, no hashCode
}

@Getter @Setter @EqualsAndHashCode
class EqualsHashCodeWithGetterSetterOkay {
    String field1;
    String field2;
}

@Builder @Value
class ValueGood {
    String field1;
    String field2;
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInEquals" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Field simply assigned to is missing in equals method." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah04">
        <description>Problem: If a field which can be assigned separately (independent of other fields) is missing in the equals method, then changing the field in one object has no effect on the equality with another object.
            However, if a field of one of two equal objects is changed, the expectation is that they are no longer equal.&#13;
            Solution: include the missing field in the equals and hashCode method. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=false()]//VariableDeclaratorId[
    (: names used as left hand side in simple assignments in methods or constructor matching fields:)
     (@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/(MethodDeclaration|ConstructorDeclaration)
    /..//BlockStatement//StatementExpression
    (: simple assignment :)
    [exists(AssignmentOperator) and not(exists(Expression/PrimaryExpression/PrimarySuffix))
    and exists(Expression/PrimaryExpression/PrimaryPrefix/Name) and not(contains(Expression/PrimaryExpression/PrimaryPrefix/Name/@Image,".")) ]
    /PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)/@Image)
     and (
    (: with an equals method defined at that level with 1 argument and not having a throw statement :)
    ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Name='equals' and MethodDeclarator/FormalParameters/@Size=1 and not (Block/BlockStatement/Statement/ThrowStatement)]
    (: where names used in equals method matching fields are non-equal to :)
    and not(@Name = ancestor::ClassOrInterfaceBody[1]/ClassOrInterfaceBodyDeclaration/MethodDeclaration
    [@Name='equals' and MethodDeclarator/FormalParameters/@Size=1]/Block//
    (: name or this.name and name before dot if present :)
    (Name|PrimarySuffix)/(substring-before(concat(@Image, '.'), '.'))) )]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    String field1;
    String field2; // bad, missing in equals

    public Bad1(String arg2) {
        field2 = arg2;
    }
    public void setField1(String arg1) {
        field1 = arg1;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1);
    }
    public int hashCode() {
        return Objects.hash(field1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="MissingFieldInHashCode" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Equals uses a field which is missing in hashCode." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ieah03">
        <description>Problem: Two unequal objects can have the same hashCode and end up in the same bucket of a Map. This may result in bad performance, O(n) lookup instead of O(1).&#13;
            Solution: Use the same fields in hashCode as are used in equals. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration//VariableDeclaratorId[
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image or
concat(@Name, '.equals') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='equals' and (MethodDeclarator//FormalParameters/@Size = 1)]/Block//(Name|PrimarySuffix)/@Image) >
(@Name = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//(PrimarySuffix|Name)/@Image or
concat(@Name, '.hashCode') = ancestor::ClassOrInterfaceBody[1]//MethodDeclaration[@Name='hashCode' and (MethodDeclarator//FormalParameters/@Size = 0)]/Block//PrimaryPrefix/Name/@Image)
]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Good {
    String field1, field2;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        return Objects.hash(field1, field2);
    }
}

class Bad {
    String field1;
    String field2; //bad - missing in hashCode

   public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqHashTryout2 that = (EqHashTryout2) o;
        return Objects.equals(field1, that.field1) &&
                Objects.equals(field2, that.field2);
    }
    public int hashCode() {
        int result = field1 != null ? field1.hashCode() : 0;
        return result;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="NonComparableMapKeys"
          language="java"
          message="Map keys should implement Comparable in order to make access fast."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc08">
        <description>Problem: If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access will be slow.
            Solution: Implement Comparable for your Map keys. Do not use classes for the keys which don't implement Comparable, like Thread, Class and Object. At least not for Maps which can grow large.
            Note that equals and hashCode must be implemented properly for the keys, and compareTo must be compatible with equals.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: check key/elem type in declaration :)
//Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('java.util.Map')]
(: first type argument does not implement Comparable :)
[TypeArguments/TypeArgument[1]/ReferenceType[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]]
,
(: for when key/elem type ise missing in declaration, check Map.put and Set.add :)
//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.put') and pmd-java:typeIs('java.util.Map')]]
/PrimarySuffix/Arguments/ArgumentList/Expression[1]
(: first arg does not implement Comparable :)
[not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
]
               ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
 class Foo {
    Map<Object, String> oMap; // bad, Object does not implement Comparable
    Map<Thread, String> tMap; // bad, Thread does not implement Comparable

    Map oldStyleMap = new HashMap(); // cannot check here

    void putInOldStyleBad() {
        oldStyleMap.put(new Thread(), "value"); // bad
    }

    Map<Comparable, String> cMap; // good

    void putInOldStyleGood() {
        oldStyleMap.put("key", "value");
    }
}

            ]]>
        </example>
    </rule>

    <rule name="NonComparableSetElements"
          language="java"
          message="Set elements should implement Comparable in order to make access by element fast."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc09">
        <description>Problem: A Set is implemented with a Map. If multiple entries end up in the same HashMap bucket, they are stored as LinkedList, and with more than 7 as a red-black tree.
            The list access time is O(n) and tree access time is only O(log n) which is much faster for large n. This tree implementation utilizes the compareTo from the Comparable interface.
            If this is not implemented, access by element will be slow. Iterating through the elements does not suffer from this slow access because no lookup by key in the map is involved.
            Access methods by element which are affected: contains[All], retainAll, remove[All].
            Solution: Implement Comparable for your own Set elements. Avoid using large Sets with elements of types which don't implement Comparable, like Thread, Class and Object. At least when using access by element.
            Note that equals and hashCode must be implemented properly for the elements, and compareTo must be compatible with equals.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::ClassOrInterfaceBody//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
,
//(FormalParameter|LocalVariableDeclaration)/Type[pmd-java:typeIs('java.util.Set') and ReferenceType//TypeArgument[1][not(pmd-java:typeIs('java.lang.Comparable'))
(: and can be resolved :)
and pmd-java:typeIs('java.lang.Object')]]/..//VariableDeclaratorId[
ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.contains')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.containsAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.remove')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.removeAll')
or ancestor::MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name/@Image = concat(@Name, '.retainAll')
]/../..
               ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import org.apache.hc.client5.http.HttpRoute; // does implement equals/hashCode yet *not* compareTo

class Foo {
  Set<String> strSet = new HashSet<>();
  List<String> strList = new ArrayList<>();
  Set<HttpRoute> fieldRouteSet = new HashSet<>(); // bad
  List<HttpRoute> routeList = new ArrayList<>();

  void byElemBad(Set<HttpRoute> paramRouteSet) { // bad
    paramRouteSet.retainAll(routeList);

    fieldRouteSet.contains(t);

    Set<HttpRoute> localRouteSet = new HashSet<>(); // bad
    localRouteSet.removeAll(routeList);
  }

  void otherCasesGood(Set<HttpRoute> paramRouteSet) {
    strSet.contains("bla");
    strSet.retainAll(strList);
    strSet.remove("other");
    paramRouteSet.iterator().next();
  }
}
            ]]>
        </example>
    </rule>

    <rule name="OptimizeMapOrSetForEnum"
          language="java"
          message="Map has enum keys or Set has enum elemens, use EnumMap or EnumSet for more efficiency."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoc03">
        <description>Problem: A HashMap and HashSet are rather greedy in memory usage.&#13;
            Solution: Use an EnumMap or EnumSet. It is represented internally with arrays which is extremely compact and efficient.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :) (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//LocalVariableDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName] and
VariableDeclarator/VariableInitializer/Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
,
//Initializer//StatementExpression[Expression
[not ((pmd-java:typeIs('java.util.EnumSet') or pmd-java:typeIs('java.util.EnumMap')
(: Set.of() with 1 or 2 elems doesn't have the HashSet overhead :)
 or (PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of' and PrimarySuffix/Arguments/@Size <= 2])
 (: it is exactly a Map or Set, cannot determine implementation #194 :)
 or ((pmd-java:typeIsExactly('java.util.Set') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Set.of']))
 or (pmd-java:typeIsExactly('java.util.Map') and not(PrimaryExpression[PrimaryPrefix/Name/@Image = 'Map.of'])))
 (: cannot determine type, indirect #194 :)
 or (not(pmd-java:typeIs('java.util.Set') or pmd-java:typeIs('java.util.Map')))
))]]
[PrimaryExpression//Name/@Image =
//FieldDeclaration[Type/ReferenceType/ClassOrInterfaceType
[(pmd-java:typeIs('java.util.Map') and not (pmd-java:typeIs('java.util.EnumMap'))) or (pmd-java:typeIs('java.util.Set') and not(pmd-java:typeIs('java.util.EnumSet')))]
/TypeArguments/TypeArgument[1]/ReferenceType[pmd-java:typeIs('java.lang.Enum') or ClassOrInterfaceType/@Image = //EnumDeclaration/@SimpleName]]/VariableDeclarator/VariableDeclaratorId/@Name]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
Map<YourEnumType, String> map = new EnumMap<>(YourEnumType.class);
Set<YourEnumType> set = EnumSet.allOf(YourEnumType.class);
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalConcatInLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="String concatenation (+) is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il01">
        <description>Problem: String concatenation (+) is executed regardless of log level and can be expensive. &#13;
            Solution: Use SLF4J formatting with {}-placeholders or log and format conditionally.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name[ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or
    ends-with(@Image,'.info')]/../../PrimarySuffix/Arguments/ArgumentList/Expression/AdditiveExpression[pmd-java:typeIs('java.lang.String')]
    [PrimaryExpression/PrimaryPrefix/Name]
    [not(ancestor::IfStatement/Expression/PrimaryExpression/PrimaryPrefix/Name[
        ends-with(@Image,'.isTraceEnabled')
        or ends-with(@Image,'.isDebugEnabled')
        or ends-with(@Image,'.isInfoEnabled')
        or ends-with(@Image,'.isLoggable')
    ])]
]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
        <![CDATA[
@slf4j
class Foo {
    void bad(String a, String b) {
        log.debug("message: {}", a + b); // bad
    }
    void good(String a, String b) {
        log.debug("message: {}{}", a, b); // good
    }
}
            ]]>
    </example>
    </rule>

    <rule name="UnconditionalCreatedLogArguments"
          language="java"
          message="Avoid unconditional creation of a log argument, it may not be needed."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il06">
        <description>Problem: Creation of a log argument with a toString or other operation(s) may be expensive, while depending on the log level, the result may not be used.&#13;
            Solution: Create the log argument conditionally on the log level, within an if statement. For just 'obj.toString()', just pass 'obj' to the log method and leave it to SLF4J to call toString() only if needed.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix/Name
    (: log levels typically/often not enabled :)
    [ends-with(@Image,'.trace') or ends-with(@Image,'.debug') or ends-with(@Image,'.info')]
    (: no violation if conditionally: only executed if level enabled is okay :)
    [not(ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: no violation if return conditionally before :)
    [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
    [ends-with(@Image,'.isTraceEnabled') or ends-with(@Image,'.isDebugEnabled') or ends-with(@Image,'.isInfoEnabled') or ends-with(@Image,'.isLoggable')])
    ]
    (: an argument in the log method :)
    /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
    [
    (: equals a declared var :)
    (PrimaryPrefix/Name[@Image = ancestor::MethodDeclaration//VariableDeclarator
        (: with initializer not like obj.get[Xxx], we assume a simple getter is quick, unless this is in a loop :)
        [not(contains(string-join(./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Name/@Image, '-'), '.get')
             (: this.field.get[Xxx] case #209 :)
             or ./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix[@Image = '']/../PrimarySuffix[starts-with(@Image, 'get')])
         or ancestor::WhileStatement or ancestor::ForStatement or ancestor::DoStatement]/VariableDeclaratorId/@Name
    (: and it is not used in a return :)
    and (not(@Image = ancestor::Block//ReturnStatement//Name/@Image))
    (: and it is not used in a constructor of a local var :)
    and (not(@Image = ancestor::Block//AllocationExpression//Name/@Image))
    (: and it is not used as an argument in another method call than log :)
    and (not(contains(concat(string-join(ancestor::Block//PrimaryExpression[(PrimaryPrefix/Name|PrimarySuffix)
        [@Image > '' and not(ends-with(@Image, 'trace') or ends-with(@Image, 'debug') or ends-with(@Image, 'info'))]]/PrimarySuffix/Arguments//Name/@Image, '.'), '.'), concat(@Image,'.'))))
    (: and it is not used in the method in a blockstatement before a '.', like logObj.toString() other than method call argument.
       It is a contains, so a violation is missed when the log arg/declared var e.g. is 'log' and a 'obj.log()' is used :)
    and (not(contains(string-join(ancestor::MethodDeclaration//Name[ancestor::BlockStatement/(Statement|LocalVariableDeclaration)[count(./StatementExpression//PrimarySuffix//ArgumentList//Name/@Image) = 0]]/@Image, '.'), concat(@Image, '.')) ))
    (: method name starts with log, we assume it is called conditionally :)
    and (not(ancestor::MethodDeclaration[starts-with(@Name, 'log')]))
    ])
]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    void bad(Object obj) {
      String logObj = obj.toString();
      log.debug("object to String: {}", logObj); //bad
    }

    void good(Object obj) {
      log.debug("object to String: {}", obj); //good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UnconditionalOperationOnLogArgument" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Operation is executed regardless of log level and can be expensive" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#il03">
        <description>Problem: An operation is executed regardless of log level. This could be much processing while the result is typically not used. Detected are obj.toString() and operations with one or more arguments except usually cheap obj.getXXX(arg).&#13;
            Solution: Execute the operation only conditionally and utilize SLF4J formatting with {}-placeholders.  (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
          //PrimaryPrefix/Name
            (: log levels typically/often not enabled :)
            [
            	ends-with(@Image,'.trace')
            	or ends-with(@Image,'.debug')
            	or ends-with(@Image,'.info')
            ]
            (: no violation if conditionally: only executed if level enabled is okay :)
            [not(ancestor::IfStatement//Name
            	[
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
	        ]
            (: no violation if return conditionally before :)
            [not(ancestor::BlockStatement/preceding-sibling::BlockStatement//IfStatement//ReturnStatement/ancestor::IfStatement//Name
                [
					ends-with(@Image,'.isTraceEnabled')
					or ends-with(@Image,'.isDebugEnabled')
					or ends-with(@Image,'.isInfoEnabled')
					or ends-with(@Image,'.isLoggable')
		        ])
            ]
	        (: in the log method :)
            /../../PrimarySuffix/Arguments/ArgumentList/Expression//PrimaryExpression
            [
                (: toString on argument :)
                PrimaryPrefix/Name[ends-with(@Image,'.toString')]
                or
                (: a method call with an argument list :)
                (PrimarySuffix/Arguments/ArgumentList)
                (: exclude a simple getXXX(i), like list.get(0) or env.getProperty(key), assumed to be fast :)
                and not (PrimaryPrefix/Name[contains(@Image,'.get')])
            ]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
            LOG.debug("customer = {}", customer.toString()); // bad
            LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage())); // bad

            LOG.debug("customer = {}", customer); // good
            if (LOG.isDebugEnabled()) { // good
                LOG.debug("Complete Soap response: {}", getSoapMsgAsString(context.getMessage()));
            }
            ]]>
        </example>
    </rule>

    <rule name="UsingSuppressWarnings" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>(Informative - be aware) Problem: This rule is suppressed. The rule detects problems and suppressing it without full knowledge can lead to the problems this rule is trying to prevent. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="ruleIdMatches" type="String" value=".*"
                      description="Regex for inclusion of rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="UsingSuppressWarningsHighRisk" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Using SuppressWarnings for a rule that is meant to prevent high risk problems." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>(Informative - are you sure?) Problem: This rule detects high risk problems, suppressing them without full knowledge can lead to incidents like customer data mix-up, corrupt data, server crashes or very bad performance. &#13;
            Solution: Suppress warnings judiciously based on full knowledge and report reasons to suppress (false positives) to the rule maintainers so the rule can be fixed. (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="ruleIdMatches" type="String" value="AvoidUnguardedMutableFieldsInSharedObjects|AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects|AvoidMutableStaticFields|[^\w]ALL[^\w]|[^\w]all[^\w]|PMD[^\.]|pmd[^:]"
                      description="Regex for inclusion of high risk rules"/>
            <property name="ruleIdNotMatches" type="String" value="^$"
                      description="Regex for exclusion of high risk rules"/>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image="SuppressWarnings" or @Image="SuppressFBWarnings"]/..//Literal[(matches(@Image, $ruleIdMatches)) and not (matches(@Image, $ruleIdNotMatches))]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
    </rule>

<!-- END Included file 'common.xml' -->
<!-- BEGIN Included file 'common_std.xml' -->
    <rule name="AvoidApacheCommonsFileItemNonStreaming"
          language="java"
          message="Avoid memory intensive FileItem.get and FileItem.getString"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isio03">
        <description>
            Problem: Use of FileItem.get and FileItem.getString could exhaust memory since they load the entire file into memory&#13;
            Solution: Use streaming methods and buffering.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name
[ends-with(@Image, '.get') or ends-with(@Image, '.getString')]
[
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
	) or
	starts-with(@Image, concat(
		ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.fileupload.FileItem')]/../../..//VariableDeclaratorId/@Name,
		'.')
)
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="io,jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class FileStuff {
   private String bad(FileItem fileItem) {
        return fileItem.getString();
   }

   private InputStream good(FileItem fileItem) {
        return fileItem.getInputStream();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidCalendarDateCreation"
          language="java"
          message="A Calendar is used to create a Date or DateTime, this is expensive."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ue01">
        <description>Problem: A Calendar is a heavyweight object and expensive to create. &#13;
            Solution: Use 'new Date()', Java 8+ java.time.[Local/Zoned]DateTime.now().
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryPrefix[Name[ends-with(@Image, 'Calendar.getInstance')]] [count(../PrimarySuffix) > 2 and ../PrimarySuffix[last()-1][@Image = 'getTime' or @Image='getTimeInMillis']]
|
//Block/BlockStatement//Expression/PrimaryExpression/
PrimaryPrefix/Name[pmd-java:typeIs('java.util.Calendar') and (ends-with(@Image,'.getTime') or ends-with(@Image,'.getTimeInMillis'))]
|
//ClassOrInterfaceType[pmd-java:typeIs('org.joda.time.DateTime') or pmd-java:typeIs('org.joda.time.LocalDateTime')][../Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, 'Calendar.getInstance')]]
	         ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class DateStuff {
    private Date bad1() {
        return Calendar.getInstance().getTime(); // now
    }
    private Date good1a() {
        return new Date(); // now
    }
    private LocalDateTime good1b() {
        return LocalDateTime.now();
    }
    private long bad2() {
        return Calendar.getInstance().getTimeInMillis();
    }
    private long good2() {
        return System.currentTimeMillis();
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConcatInAppend"
          language="java"
          message="Concatenation inside append. Use extra append."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu04">
        <description>Concatenation of Strings is used inside an StringBuilder.append argument. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected.&#13;
            Solution: Use an extra fluent append instead of concatenation.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration/Block/BlockStatement[
(.//PrimaryExpression/PrimaryPrefix/Name[substring-after(@Image, '.') = 'append']
or
.//PrimaryExpression/PrimarySuffix/@Image = 'append')
and
.//PrimaryExpression/PrimarySuffix/Arguments/ArgumentList/Expression[1]/AdditiveExpression[pmd-java:typeIs('java.lang.String')
and (count(PrimaryExpression/PrimaryPrefix/Name) > 0)
and not(PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=true()]//VariableDeclaratorId/@Name)
and not(PrimaryExpression/PrimaryPrefix/Name/@Image=
ancestor::Block//LocalVariableDeclaration[@Final=true()]//VariableDeclaratorId/@Name)
]]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class StringStuff {
   private String bad(String arg) {
        StringBuilder sb = new StringBuilder();
        sb.append("arg='" + arg + "'");
        return sb.toString();
   }

   private String good(String arg) {
        StringBuilder sb = new StringBuilder();
        sb.append("arg='").append(arg).append("'");
        return sb.toString();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidConcatInLoop"
          language="java"
          message="A String is concatenated in a loop. Use StringBuilder.append."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#isu02">
        <description>A String is built in a loop by concatenation. Problem: Each statement with one or more +-operators creates a hidden temporary StringBuilder, a char[] and a new String object, which all have to be garbage collected. &#13;
            Solution: Use the StringBuilder append method.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator[
    (: a += ...;  -- a being a string :)
    @Image='+=' and preceding-sibling::*[1]/PrimaryPrefix/Name[pmd-java:typeIs('java.lang.String')]
    (: a = ... + a + ...; -- a being a string :)
    or @Image='=' and following-sibling::*[1]/AdditiveExpression/PrimaryExpression/PrimaryPrefix/Name[
        pmd-java:typeIs('java.lang.String')
        and @Image = ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
    ]
]/.. (: Go up to report on the StatementExpression :)
	]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class StringStuff {
   private String bad(String arg) {
        String log = "";
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            log += val;
        }
        return log;
    }

   private String good(String arg) {
        StringBuilder sb = new StringBuilder();
        List<String> values = Arrays.asList("tic ", "tac ", "toe ");
        for (String val : values) {
            sb.append(val);
        }
        return sb.toString();
   }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidForEachInStreams"
          language="java"
          message="Prefer side-effect-free functions in streams, use forEach only for logging."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ils01">
        <description>Problem: Streams is a paradigm based on functional programming: the result should depend only on its input and not update any state.
            Use of forEach is actually iterative code masquerading as streams code. It is typically harder to read and less maintainable than the iterative form.
            Solution: Use the for-each (enhanced-for) loop, or the pure functional form. The forEach operation should only be used to report (i.e. log) the result of a stream computation.
        (jpinpoint-rules)</description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression[(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'forEach')]]
[not (./PrimarySuffix//MethodReference[starts-with(@Image, 'log')] or
./PrimarySuffix//PrimaryPrefix/Name[starts-with(lower-case(@Image), 'log')] or
./PrimarySuffix//LambdaExpression//PrimaryPrefix/Name[starts-with(@Image, 'log.')]
)]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
        // forEach in stream
        map = new HashMap<>();
        letters.forEach(l -> map.put(l, 0)); // bad, side effect, modifies map

        // reporting result by logging, good
        letters.forEach(Log::info);

        // iterative form, meant for modifying state, good
        map = new HashMap<>();
        for (String l : letters) {
            map.put(l, 0);
        }

        // pure functional form, good
        map = letters.stream().collect(toMap(l -> l, v -> 0));
            ]]>
        </example>
    </rule>

    <rule name="AvoidUnusedAssignments"
          language="java"
          message="Avoid assignments for which the assigned value is never used."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr04">
        <description>Problem: Assignments to variables for which the assigned value is not used because a new value is assigned before actual use, is unnecessary work and may indicate a bug.
            Solution: remove the first assignment and make sure that is as intended.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: for each assignment node :)
(for $node in //StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name
(: match if for that node the next occurrence of ((assignment without use in same statement) union with (use) is an assignment to the var) :)
return ($node[
(: assignment without use, Name is result :)
((ancestor::BlockStatement/following-sibling::BlockStatement//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name[@Image=$node/@Image]
[not(ancestor::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='=']) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])]
)[1]
|
(: use, PrimaryPrefix is result, so @Image is empty string :)
(ancestor::BlockStatement/following-sibling::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='='] and not(PrimarySuffix/Expression)) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Image])[1])
(: first is the var name :)
[1]/@Image = $node/@Image])
)
,
(: for each local variable declaration :)
(for $node in (//LocalVariableDeclaration/VariableDeclarator[VariableInitializer]//VariableDeclaratorId)
(: match if for that node the next occurrence of ((assignment without use in same statement) union with (use) is an assignment to the var) :)
return ($node[
(: assignment without use, Name is result :)
((ancestor::BlockStatement/following-sibling::BlockStatement//StatementExpression[AssignmentOperator[@Image='=']][not(ancestor::IfStatement or ancestor::TryStatement or ancestor::SwitchStatement)]/PrimaryExpression/PrimaryPrefix/Name[@Image=$node/@Name]
[not(ancestor::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='=']) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Name])]
)[1]
|
(: use, PrimaryPrefix is result, so @Image is empty string :)
(ancestor::BlockStatement/following-sibling::BlockStatement//PrimaryExpression[not(../AssignmentOperator[@Image='='] and not(PrimarySuffix/Expression)) and (not(PrimarySuffix/Arguments) or PrimaryPrefix[contains(Name/@Image, '.')])]
/PrimaryPrefix[substring-before(concat(Name/@Image, '.'), '.')=$node/@Name])[1])
(: first is the var name :)
[1]/@Image = $node/@Name])
)
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,replaces-sonar-rule,suspicious,unused" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[

            ]]>
        </example>
    </rule>

    <rule name="LetFieldsMeetSerializable"
          language="java"
          message="Fields in a Serializable class should be serializable or transient."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr02">
        <description>Problem: Field in a Serializable class is not serializable nor transient. When (de)serialization happens, a RuntimeException will be thrown and (de)serialization fails.
            Solution: make the field either transient, make its class implement Serializable or interface extend Serializable.
            Note: Classes extending Throwable do, by inheritance, implement Serializable, yet are excluded in this rule, since they are typically never actually serialized.
            An exception to this exception is when extending RemoteException, then fields should be transient or serializable.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[ImplementsList/ClassOrInterfaceType[@Image='Serializable']
or pmd-java:typeIs('java.io.Serializable')
(: Throwable is the exception, except RemoteException :)
and not(pmd-java:typeIs('java.lang.Throwable') and not(pmd-java:typeIs('java.rmi.RemoteException')))]
(: non-transient, non-static, non-primitive fields :)
//FieldDeclaration[@Transient=false() and @Static=false()][not(.//PrimitiveType)]
[not(pmd-java:typeIs('java.io.Serializable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))
(: if has type args, type args which are not serializable like List<String, Thread>):)
and (not(exists(.//TypeArgument/ReferenceType))
or exists(.//TypeArgument/ReferenceType[not(pmd-java:typeIs('java.io.Serializable'))
(: and can be resolved :)
and (pmd-java:typeIs('java.lang.Object'))]))
]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,pitfall,replaces-sonar-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo implements Serializable {
    String meets;
    Exception exMeets;
    Serializable ser;
    Thread t1NotMeets; // bad, Thread is not serializable
    transient Thread t2meets;
    List<String> listOfStrings = new ArrayList();
    List<Thread> listOfThreads = new ArrayList(); // bad
    Map<String,String> mapToString = new HashMap();
    Map<String,Thread> mapToThread = new HashMap(); //bad
}

class Bar extends Exception {
    Thread t1NotMeets;
    transient Thread t2meets;
}

class Baz extends RemoteException {
    Thread t1NotMeets; // bad
    transient Thread t2meets;
}
            ]]>
        </example>
    </rule>

    <rule name="LimitNestingInLambdas"
          language="java"
          message="Avoid deep nesting of lambdas in lambda expressions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr05">
        <description>Problem: lambda expressions with deep nesting (lambda's in lambda's) are hard to understand and maintain.
            Solution: extract the lambda expression code block(s) into one or more well-named separate method(s).
            Note: A violation when the depth of lambda-with-code-block nesting exceeds (by default) 1,
            or the depth of lambda-single-expression in lambda nesting exceeds (by default) 4.
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="param-block-max" value="1" type="String" description="Maximum allowed depth of lambda-with-code-block nesting"/>
            <property name="param-single-max" value="4" type="String" description="Maximum allowed depth of lambda-single-expression nesting"/>
            <property name="xpath">
                <value><![CDATA[
//LambdaExpression[Block][count(ancestor::LambdaExpression/Block) > number($param-block-max)]
|
//LambdaExpression[Expression][count(ancestor::LambdaExpression) > number($param-single-max)]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="brain-overload,jpinpoint-rule,replaces-sonar-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    public Object singleExpressionLambdas(String a, String b) {
        return detect(a)
                .orElseGet(() -> single0(b)
                .orElseGet(() -> single1(b) // single nesting level 1
                .orElseGet(() -> single2(b)//   2
                .orElseGet(() -> single3(b)//   3
                .orElseGet(() -> singlet4(b)//  4
                .orElseGet(() -> single5(b)//  5 // bad
                .orElseGet(() -> single6(b))))))));//  6 // bad
    }

   public Object blockLambdas(String a, String b) {
        return detect(a)
                .orElseGet(() -> single0(b)
                .orElseGet(() -> {block0(b) // block nesting level 0
                .orElseGet(() -> {block1(b)//  1
                .orElseGet(() -> {block2(b)//  2 // bad
                .orElseGet(() -> single4(b)//  single nesting level 4 // good
                .orElseGet(() -> single5(b)));});});}));//  single nesting level 5, bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="LimitStatementsInLambdas"
          language="java"
          message="Avoid many statements in lambda expressions."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr03">
        <description>Problem: lambda expressions with many statements are hard to understand and maintain.
            Solution: extract the lambda expression code block into one or more well-named separate method(s).
        (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="param-max" value="5" type="String" description="Maximum number of allowed non-setter statements"/>
            <property name="xpath">
                <value><![CDATA[
//LambdaExpression/Block
(: number of statements should be limited, setters are ignored. Chained methods are one statement  :)
[(count(.//Statement) - count(.//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[contains(@Image, '.set')]) > number($param-max))
]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="brain-overload,jpinpoint-rule,replaces-sonar-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
       void bar(List additionals) {
            additionals.forEach(entity -> {
                if (entity.getKNr() != null) {
                    action.withActions(
                            new Action().withFoId(actionFoId.incrementAndGet())
                                    .withEntityPlanFoId(1)
                                    .withEntity(mapLogicType(true))
                    );
                }
            });
       }

       void baz(List additionals) {
            additionals.forEach(entity -> {         // bad, too many statements (5)
                if (entity.getKNr() != null) {
                    action.withActions(
                            new Action().withFoId(actionFoId.incrementAndGet())
                                    .withEntityPlanFoId(1)
                                    .withEntity(mapLogicType(true))
                    );
                }
                else { action.withActions(new Action().withFoId(0)); }
            });
        }
}
            ]]>
        </example>
    </rule>

    <rule name="LimitWildcardStaticImports"
          language="java"
          message="The number of static imports with a wildcard should be limited"
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#isr01">
        <description>Importing a class statically allows you to use its public static members easily: without qualifying them with the class name. Problem: if you import too many classes statically, your code can become confusing and difficult to maintain. The default maximum = 3.
            Solution: Import class members individually.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="param-max" value="3" type="String" description="Maximum number of allowed static imports with wildcard"/>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration[@Static=true() and @ImportOnDemand=true()][position() > number($param-max)]
	]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule,pitfall,replaces-sonar-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
// With the default threshold value: 3

import static java.lang.Math.*;
import static java.util.Collections.*;
import static com.co.division.Constants.*;
import static com.co.department.Constants.*;  // bad

import static com.co.corporate.Constants.NUTS;
import static com.co.corporate.Constants.CRAZY;
import static com.co.corporate.Constants.FOOLISH;
import static com.co.corporate.Constants.AWESOME; // good
import static com.co.corporate.Constants.GREAT; // good

            ]]>
        </example>
    </rule>

<!-- END Included file 'common_std.xml' -->
<!-- BEGIN Included file 'concurrent.xml' -->
    <rule name="AvoidCommonPoolForBlockingCalls" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the ForkJoinPool::commonPool used in parallelStream for blocking calls."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia09">
        <description>Problem: Blocking calls for instance remote calls, may exhaust the common pool for some time thereby blocking all other use of the common pool.
            In addition, nested use of the common pool can lead to deadlock. Do not use the common pool for blocking calls. The parallelStream() call uses the common pool.&#13;
            Solution: Use a dedicated thread pool with enough threads to get proper parallelism. The number of threads in the common pool is equal to the number of CPUs - 1 and meant to utilize all of them.
            It assumes CPU intensive non-blocking processing of in-memory data.  (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: assumption: if import of web client / http client is present, parallelStreaming is for remote calls :)
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.web.client') or starts-with(@Image, 'org.apache.commons.httpclient')]/
ancestor::CompilationUnit//PrimaryExpression
[(PrimarySuffix/@Image='parallelStream' or ends-with(PrimaryPrefix/Name/@Image, 'parallelStream')
and exists(PrimarySuffix/pmd-java:typeIs('java.util.stream.Stream'))
and not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')]))
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance,unpredictable" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.util.concurrent.*;
import java.util.stream.*;
import java.util.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    final List<String> list = new ArrayList();
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> storeDataRemoteCall(elem));
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> storeDataRemoteCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(10, TimeUnit.MILLISECONDS));
    }

    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> storeDataRemoteCall(elem))
        ).get();
    }

    String storeDataRemoteCall(String elem) {
        // do remote call, blocking. We don't use the returned value.
        RestTemplate tmpl;
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCommonPoolForFutureAsync"
          message="Avoid using the common thread pool for future.supplyAsync, use a separate pool."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia08">
        <description>
            Problem: Future.supplyAsync is typically used for remote calls. By default, it uses the common pool.
            The number of threads in the common pool is equal to the number of CPU's, which is suitable for in-memory processing.
            For I/O, however, this number is typically not suitable because most time is spent waiting for the response and not in CPU.
            The common pool must not be used for blocking calls. &#13;
            Solution: A separate, properly sized, pool of threads (an Executor) should be used for the async calls.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//PrimaryPrefix/Name[@Image='CompletableFuture.supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
,
//PrimaryPrefix/Name[@Image='supplyAsync']/../../PrimarySuffix/Arguments/ArgumentList[count(Expression) = 1]
[/CompilationUnit/ImportDeclaration/Name[@Image = 'java.util.concurrent.CompletableFuture.supplyAsync']]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance,pitfall,unpredictable" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private final ExecutorService asyncPool = Executors.newFixedThreadPool(8);

    void bad() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account))) // bad
         .toArray(CompletableFuture[]::new);
    }

    void good() {
        CompletableFuture<Pair<String, Boolean>>[] futures = accounts.stream()
         .map(account -> CompletableFuture.supplyAsync(() -> isAccountBlocked(account), asyncPool)) // good
         .toArray(CompletableFuture[]::new);
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCompletionServiceTake"
          message="Avoid completionService.take, use poll"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>
            Problem: take() stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: use poll() with a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
  //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.take')]
    [(starts-with(@Image, concat(ancestor::MethodDeclaration//FormalParameter/Type/ReferenceType/ClassOrInterfaceType[
    pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.'))
    or
    starts-with(@Image, concat(ancestor::ClassOrInterfaceBody//FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[
     pmd-java:typeIs('java.util.concurrent.CompletionService')
    or pmd-java:typeIs('java.util.concurrent.ExecutorCompletionService')
    ]/../../../VariableDeclarator/VariableDeclaratorId/@Name, '.')))
]    ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance,pitfall" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidExecutorInvokeWithoutTimeout"
          message="Avoid using ExecutorService::invokeAll or invokeAny without a timeout."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia15">
        <description>Problem: Stalls indefinitely in case of stalled Callable(s) and consumes threads.&#13;
            Solution: Provide a timeout to the invokeAll/invokeAny method and handle the timeout. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix
[pmd-java:typeIs('java.util.concurrent.ExecutorService') and ./Name[ends-with(@Image,'.invokeAll') or ends-with(@Image,'.invokeAny')]]
/../PrimarySuffix[1][@ArgumentCount=1]/Arguments/ArgumentList
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance,pitfall" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.util.concurrent.*;

class Foo {
    private List<Future<ServiceResult>> executeTasksBad(Collection<Callable<ServiceResult>> tasks, ExecutorService executor) throws Exception {
        return executor.invokeAll(tasks); // bad, no timeout
    }
    private List<Future<ServiceResult>> executeTasksGood(Collection<Callable<ServiceResult>> tasks, ExecutorService executor) throws Exception {
        return executor.invokeAll(tasks, OUR_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidFutureGetWithoutTimeout"
          message="Avoid future.get without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>
            Problem: Stalls indefinitely in case of hanging threads and consumes a thread.&#13;
            Solution: Provide a timeout value and handle the timeout.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
   //MethodDeclaration//PrimaryPrefix/Name[ends-with(@Image, '.get')]
    (: future.get or variant called on formal param :)
    [(exists(index-of((ancestor::MethodDeclaration//FormalParameter[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on local var :)
    exists(index-of((ancestor::MethodDeclaration//LocalVariableDeclaration/Type[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/../VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    or
    (: future.get or variant called on field :)
    exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[
    pmd-java:typeIs('java.util.concurrent.Future')
    or pmd-java:typeIs('java.util.concurrent.CompletableFuture')
    or pmd-java:typeIs('java.util.concurrent.Response')
    or pmd-java:typeIs('java.util.concurrent.RunnableFuture')
    or pmd-java:typeIs('java.util.concurrent.RunnableScheduledFuture')
    or pmd-java:typeIs('java.util.concurrent.ScheduledFuture')
    ]/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))
    )
    (: .get without arguments :)
    and not(../../PrimarySuffix/Arguments/ArgumentList)
    ]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    public static String bad(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(); // bad
    }

    public static String good(CompletableFuture<String> complFuture) throws Exception {
            return complFuture.get(10, TimeUnit.SECONDS); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidFutureJoinWithoutTimeout"
          message="Avoid future.join without timeout"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia07">
        <description>
            Problem: Stalls indefinitely in case of hanging thread(s) and consumes a thread.&#13;
            Solution: Provide a timeout before the join and handle the timeout. For example a future.get(timeout, unit), a orTimeout() or a completeOnTimeout(). You may want to use CompletableFuture.allOf() too.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: future.join method reference without timeout in method :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')
and not(ancestor::BlockStatement/preceding-sibling::BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')][../../PrimarySuffix//ArgumentList])
and not (ancestor::BlockStatement/preceding-sibling::BlockStatement//PrimarySuffix[ends-with(@Image, 'Timeout')])
]
/../PrimarySuffix//MethodReference[@Image='join']
,
(: future.join in lambda without timeout in method :)
//PrimaryExpression/PrimaryPrefix/LambdaExpression//Name[ends-with(@Image, '.join')
and not(ancestor::BlockStatement/preceding-sibling::BlockStatement//PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]
/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')][../../PrimarySuffix//ArgumentList])
and not (ancestor::BlockStatement/preceding-sibling::BlockStatement//PrimarySuffix[ends-with(@Image, 'Timeout')])
]
(: join has no arguments, #198 :)
[../../PrimarySuffix/Arguments[@Size=0]]
,
(: CompletableFuture.allOf(futures).join() without timeout :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/../PrimarySuffix[@Image='join'
(: not bad if has a future.get with (timeout) arguments before the future.join, #300 :)
and not(ancestor::BlockStatement/preceding-sibling::BlockStatement//PrimaryExpression[PrimarySuffix/Arguments/ArgumentList]
/PrimaryPrefix[pmd-java:typeIs('java.util.concurrent.Future')]/Name[ends-with(@Image, '.get') or ends-with(@Image, 'Timeout')])
and not (../PrimarySuffix[ends-with(@Image, 'Timeout')])]
(: join has no arguments, #198 :)
[../PrimarySuffix/Arguments[@Size=0]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,performance,pitfall" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    private List<Order> getOrdersBad(List<CompletableFuture<Order>> getOrdersFutures) {

        List<Order> orders = getOrdersFutures.stream()
            .map(CompletableFuture::join) // bad, NO timeout provided above
            .collect(Collectors.toList());
        return orders;
    }

    private List<Order> getOrdersGood(List<CompletableFuture<Order>> getOrdersFutures) {
        // added to deal with timeout
        CompletableFuture<Void> allFuturesResult = CompletableFuture.allOf(getOrdersFutures.toArray(new CompletableFuture[getOrdersFutures.size()]));
        try {
            allFuturesResult.get(5L, TimeUnit.SECONDS); // good
        } catch (Exception e) { // should make explicit Exceptions
            //log error
        }
        List<Order> orders = getOrdersFutures.stream()
                .filter(future -> future.isDone() && !future.isCompletedExceptionally()) // keep only the ones completed -- added to deal with timeout
                .map(CompletableFuture::join) // good, timeout provided above
                .collect(Collectors.toList());
        return orders;
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidIncrementOrDecrementForVolatileField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ++, --, +=, -= for volatile fields" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc09">
        <description>A compound statement like i++, i--, i += 1 or i -= 1 may seem one statement and thread-safe for a volatile field. Problem: The operation is actually two separate statements executed non-atomically and therefore not thread-safe. &#13;
            Solution: Guard the field properly with synchronized or use atomics like AtomicInteger. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/(AssignmentOperator[@Image='+=' or @Image='-=']/..|
(PreIncrementExpression|PostfixExpression[@Image='++' or @Image='--']))/PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[@Image =
//FieldDeclaration[@Volatile = true()]/VariableDeclarator/VariableDeclaratorId/@Name]
                        ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
 public class Foo {
    private volatile int i;
    private volatile String str = "";

    public int bad() {
        i++; // bad
        --i; // bad
        i += 1; // bad
        str += "a"; // bad
    }
    public int good(int v) {
        i = 5; // good
        i = v + 5; // good
        str = "other"; // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMDCInReactor"
          message="Avoid using MDC with Reactor."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia13">
        <description>Problem: Mapped Diagnostic Context (MDC) of logging frameworks uses ThreadLocals to store things like traceIds from headers, userId, correlationId.
            Reactive programming uses multiple threads to handle a request, and one thread can deal with asynchronous steps of many requests.
            Therefore, MDC is tricky to use in reactive context and may take much processing time to propagate, likely so for much data in the MDC.&#13;
            Solution: Propagate by use of deferContextual and use directly from the Context only when and where needed. Avoid MDC propagation mechanisms.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix/Name[@Image='MDC.setContextMap' and
(ancestor::MethodDeclaration/ResultType/Type[@TypeImage='Flux' or TypeImage='Mono']
or ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter[pmd-java:typeIs('reactor.util.context.Context')])]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,multi-threading,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;
import reactor.util.context.Context;
import org.slf4j.MDC;
import net.logstash.logback.argument.StructuredArguments;

class FooBad {
  public Flux<ServerResponse> doIt(Map<String,String> contextMap) {
      return Flux.fromIterable(service.doWork())
          .doOnNext(s -> MDC.setContextMap(contextMap))
          .doOnNext(
              response -> {
                  log.info("your log"); // includes trace ids from MDC, put in a ServletFilter, specified by log configuration
          });
      }
}

class FooGood {
    public Flux<ServerResponse> doIt() {
        // using deferContextual gives access to the read-only ContextView created in the ContextFilter
        return Flux.deferContextual(contextView -> service.doWork()
            .doOnNext(response -> {
                log.info("your log", StructuredArguments.entries((Map)contextView));
            }));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidMutableStaticFields"
          message="Avoid non-final or mutable static fields. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc08">
        <description>
            Problem: Multiple threads typically access static fields. Unguarded assignment to a mutable or non-final static field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and @GuardedBy or use volatile. Consider lock contention.&#13;
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: static field, non-final, non-volatile, non-guarded by :)
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
[@Static=true() and @Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]
,
(: static field, non-guarded, some often used known mutable types, declaration side :)
(//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true()]/Type/ReferenceType/ClassOrInterfaceType[
(((pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL')) or pmd-java:typeIs('java.io.File'))
 or (ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0]))
 and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='GuardedBy'])
])
,
(: static field, non-guarded, some often used known collection/array types, allocation side:)
(//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Static=true() and not (../Annotation//Name[@Image='GuardedBy'])]/
VariableDeclarator/VariableInitializer[((ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0)
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[ArrayDimsAndInits and xs:int(ArrayDimsAndInits and (xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0 or ArrayDimsAndInits/Expression//Name))]
or Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[(pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet'))]
or Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='Arrays.asList']
)])
,
(: static-block allocations of non-empty arrays :)
//Initializer//AllocationExpression[((ArrayDimsAndInits and ((xs:int(ArrayDimsAndInits/Expression//Literal/@Image) > 0) or exists(ArrayDimsAndInits/Expression//Name) or exists(ArrayDimsAndInits/ArrayInitializer//Expression)))
or
(: static-block allocations of known mutable types :)
ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet') or pmd-java:typeIs('java.util.EnumMap')])
and
(: given the field is not @GuardedBy :)
ancestor::StatementExpression/PrimaryExpression/PrimaryPrefix/Name/@Image = ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='GuardedBy']) = 0]/FieldDeclaration//VariableDeclaratorId/@Name
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    enum Bad {
        VAL1;
        static final Map<String, Bad> STRING_TO_ENUM = new HashMap<>(); // bad
    }
    enum Good {
        VAL1;
        static final Map<String, Good> STRING_TO_ENUM; // good
        static {
            Map<String, Good> map = new HashMap<>();
            STRING_TO_ENUM = Collections.unmodifiableMap(map);
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidNonPrivateFieldsInSharedObjects"
          message="Avoid non-private objects shared among threads. Make fields private to ensure thread-safety."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc11">
        <description>
            Problem: A singleton, or more general: an object shared among threads, has a field that is not private.
            These field can possibly be modified from other classes.&#13;
            Solution: Make the fields private.
            Note: fields are excluded when annotated with: @Autowired/@Value/@Inject.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[
    (
      @Image='Component'
      or @Image='Service'
      or @Image='Controller'
      or @Image='RestController'
      or @Image='Repository'
      or (@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN'])
    )
    (: not shared when request or prototype scope :)
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
    and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
    (: if @NotThreadSafe no checking :)
    and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
]
(: non-static, non-final and non-private fields :)
/../../../ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Private=false() and @Final=false()
(: field not injection framework annotated :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='Value' or @Image='Inject'])]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidParallelFlux"
          message="Avoid dividing the data and parallel processing because this is typically slower."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia12">
        <description>Problem: With Reactor Flux.parallel.runOn, the data is divided on a number of 'rails' matching the number of CPU cores.
            This is only useful in case much CPU processing is performed: if the sequential form takes more than 0,1 ms of CPU time.
            With remote calls this is usually not the case. In addition, it introduces more complexity with risk of failures.&#13;
            Solution: Remove parallel().runOn. Unless the CPU work takes more than 0,1 ms in sequential form and proves to be faster with parallelization.
            So only for large collections and much CPU processing.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimarySuffix[@Image='parallel' and ../PrimaryPrefix/Name[@Image = 'Flux.fromIterable']
and //ImportDeclaration/Name[starts-with(@Image, 'reactor.core.publisher')]]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,cpu,jpinpoint-rule,multi-threading,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;

class FooBad {
    public Flux<Account> getResponseAccounts(List<AccountKey> accountKeys, List<FieldName> requestedFields) {
        return Flux.fromIterable(accountKeys)
                .parallel(schedulerProperties.getParallelism()) //bad
                .runOn(scheduler)
                .flatMap(accountKey -> constructAccountDetails(accountKey, requestedFields))
                .sequential();
    }
}

class FooGood {
    public Flux<Account> getResponseAccounts(List<AccountKey> accountKeys, List<FieldName> requestedFields) {
        return Flux.fromIterable(accountKeys)
                .flatMap(accountKey -> constructAccountDetails(accountKey, requestedFields));
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidParallelStreamWithCommonPool" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Beware: parallelStream with the common pool is rarely a good choice."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia11">
        <description>Problem: Collection.parallelStream uses the common pool, with #threads = #CPUs - 1. It is designed to distribute much CPU work over the cores. It is not for remote calls or other blocking calls.
            In addition, parallelizing has overhead and risks, should only be used for much pure CPU processing.&#13;
            Solution: For remote/blocking calls: Use a dedicated thread pool with enough threads to get proper parallelism independent of the number of cores.
            For pure CPU processing: use ordinary sequential streaming unless the work takes more than about 0,1 ms in sequential form and proves to be faster with parallelization.
            So only for large collections and much processing without having to wait.   (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/(PrimarySuffix[@Image='parallelStream' or @Image='parallel']|PrimaryPrefix/Name[ends-with(@Image, '.parallelStream') or ends-with(@Image, '.parallel')])
(: and exists(PrimarySuffix[pmd-java:typeIs('java.util.stream.Stream')]) - with 'var' type is lost in typeIs :)
(: no arguments :)
[following::PrimarySuffix[1][@ArgumentCount = 0]]
[not(ancestor::Block//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.submit') and pmd-java:typeIs('java.util.concurrent.ExecutorService')])]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,multi-threading,performance,sustainability-low,unpredictable" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class Foo {
    final Map<String, String> map = new HashMap();
    final List<String> list = new ArrayList();
    final List<String> hugeList = new ArrayList(); //1000+ elements
    final ForkJoinPool myFjPool = new ForkJoinPool(10);
    final ExecutorService myExePool = Executors.newFixedThreadPool(10);

    void bad1() {
        list.parallelStream().forEach(elem -> someCall(elem)); //bad
    }
    void bad2() {
        map.entrySet().parallelStream().forEach(entry -> someCall(entry.getValue())); //bad
    }
    void exceptionalProperUse() {
       hugeList.parallelStream().forEach(elem -> heavyCalculations(elem)); //flagged but may be good, should suppress when proven to be faster than sequential form
    }

    void good1() {
        CompletableFuture[] futures = list.stream().map(elem -> CompletableFuture.supplyAsync(() -> someCall(elem), myExePool))
                .toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(futures).get(3, TimeUnit.SECONDS);
    }
    void good2() throws ExecutionException, InterruptedException {
        myFjPool.submit(() ->
                list.parallelStream().forEach(elem -> someCall(elem))
        ).get();
    }

    String someCall(String elem) {
        // do some call, don't know if remote or blocking. We don't use the returned value.
        return "";
    }

    String heavyCalculations(String elem) {
        // calculate a lot
        return "";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidReactorOnEachOperator"
          message="Avoid using Reactor Hooks.onEachOperator."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia14">
        <description>Problem: Using Reactor Hooks.onEachOperator means executing the code on every operator in the Reactor flow, for every element. This typically means much processing time.&#13;
            Solution: Just do processing when and where actually needed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression/PrimaryPrefix/Name[@Image='Hooks.onEachOperator']
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.*;

@Configuration
public class FooBad {
    private String MDC_CONTEXT_REACTOR_KEY = "CONTEXT";
    @PostConstruct
    private void contextOperatorHook() {
        Hooks.onEachOperator(MDC_CONTEXT_REACTOR_KEY,
                Operators.lift((scannable, coreSubscriber) -> new MdcContextLifter<>(coreSubscriber))
        );
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidStaticXmlFactories" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid static XML Factories" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOXAR09">
        <description>An XML Factory like DocumentBuilderFactory, TransformerFactory, MessageFactory is used as static field. Problem: These factory objects are typically not thread-safe and rather expensive to create because of class loading. &#13;
            Solution: Use thread locals or create the Factories as local variables and anyway use properties to specify the implementation class. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //ClassOrInterfaceBodyDeclaration//FieldDeclaration[@Static=true() and (
    pmd-java:typeIs('javax.xml.parsers.DocumentBuilderFactory') or
    pmd-java:typeIs('javax.xml.parsers.SAXParserFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLInputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLOutputFactory') or
    pmd-java:typeIs('javax.xml.stream.XMLEventFactory') or
    pmd-java:typeIs('javax.xml.transform.TransformerFactory') or
    pmd-java:typeIs('javax.xml.validation.SchemaFactory') or
    pmd-java:typeIs('javax.xml.datatype.DatatypeFactory') or
    pmd-java:typeIs('javax.xml.soap.MessageFactory')
    )]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading,pitfall" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
 public class Bad {
    private static final DocumentBuilderFactory DB_FACTORY = DocumentBuilderFactory.newInstance(); // shared, bad
 }

 public class Good {
    public build() {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); // local var, good
        // use dbFactory
    }
 }
            ]]>
        </example>
    </rule>

    <rule name="AvoidThreadUnsafeJaxbUsage" message="A JAXB Marshaller, Unmarshaller or Validator is used in a thread-unsafe way." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOXAR07">
        <description>Problem: JAXB Marshaller, Unmarshaller and Validator are not thread-safe.  &#13;
            Solution: Create a new instance every time you need to marshall, unmarshall or validate a document.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[pmd-java:typeIs('javax.xml.bind.Marshaller')
 or pmd-java:typeIs('javax.xml.bind.Unmarshaller')
 or pmd-java:typeIs('javax.xml.bind.Validator')
 or pmd-java:typeIs('javax.xml.validation.Validator')]
			]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded assignments to non-final fields in objects using synchronized. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. In case you are sure the class is used in single threaded context only, remove current use of synchronized and annotate the class with @NotThreadSafe to make this explicit. &#13;
            2. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: assignment to a field :)
/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnguardedAssignmentToNonFinalFieldsInSharedObjects"
          message="Avoid unguarded assignments to non-final fields in objects shared among threads. Access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. Unguarded assignment to a non-final field is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mix-up session data. &#13;
            Solution: Make the fields final and unmodifiable.  If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            4. Use synchronized for accessors to inherited fields, or better: make field private and use proper accessors on base class level using @GuardedBy.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: assignment to a field :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//*[(@Image=
(: non-final, non-volatile, non-GuardedBy fields :)
ancestor::ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false() and not (../Annotation//Name[@Image='GuardedBy'])]/VariableDeclarator/VariableDeclaratorId/@Name
or
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), @Image))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), @Image))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not assigned in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()])
or ancestor::MethodDeclaration[@Name='afterPropertiesSet']
)]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInObjectsUsingSynchronized"
          message="Avoid unguarded non-final or mutable fields in objects using synchronized. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of an object using synchronized. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the class is used in single threaded context only, annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if @NotThreadSafe no checking :)
//TypeDeclaration[count(Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])=0]
(: non-static classes using synchronized :)
//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody[//SynchronizedStatement or //MethodDeclaration[@Synchronized=true()]]
(: non-final and non-volatile fields :)
/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment, annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: mutable types not annotated with GuardedBy :)
) and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableFieldsInSharedObjects"
          message="Avoid unguarded non-final or mutable fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mix-up session data.&#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: known assumed singleton types by annotation :)
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
(: not shared when request or prototype scope :)
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
    or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: ConfigurationProperties assumed executed only once, no violation, except if Lombok Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: non-final and non-volatile fields :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
(: field not annotated with framework annotation or GuardedBy :)
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
(: field not on accessor method with assignment level annotated with framework annotation :)
and not (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
/../../..//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
(: or field of known mutable types including array :)
or ((Type/ReferenceType/ClassOrInterfaceType[(pmd-java:typeIs('java.util.Date') or pmd-java:typeIs('java.lang.StringBuilder') or pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.net.URL') or pmd-java:typeIs('java.io.File')) or
(ancestor::FieldDeclaration/VariableDeclarator/VariableInitializer[ArrayInitializer and count(ArrayInitializer/VariableInitializer) > 0])])
(: or in-line allocation of known mutable collection types :)
or (VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')] )
(: or in-constructor allocation of known mutable collection types :)
or (VariableDeclarator/VariableDeclaratorId/@Name = ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression/Expression[pmd-java:typeIs('java.util.ArrayList') or pmd-java:typeIs('java.util.HashMap') or pmd-java:typeIs('java.util.HashSet')]/../..//Name/@Image)
(: not annotated GuardedBy :)
)
and not (../Annotation//Name[@Image='GuardedBy'])
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUnguardedMutableInheritedFieldsInSharedObjects"
          message="Mutator method called on inherited field. Avoid unguarded mutable inherited fields in objects shared among threads. Make final immutable or access thread-safely AND use @GuardedBy."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a (inherited) field or its reference is mutable, access is thread-unsafe and may cause corruption or visibility problems. It may also unintentionally mix-up session data. &#13;
            Solution: Make the fields final and unmodifiable. If they really need to be mutable, make access thread-safe: use synchronized and jcip @GuardedBy or use volatile.&#13;
            Notes&#13;
            1. Instances of Date, StringBuilder, URL and File are examples of mutable objects and should be avoided (or else guarded) as fields of shared objects. In case mutable fields are final and not modified after initialization (read-only) they are thread safe, however any modification to it is thread-unsafe. Since field modification is easily coded, avoid this situation.
            &#13;2. Instances of classes like ArrayList, HashMap and HashSet are also mutable and should be properly wrapped with e.g. Collections.unmodifiableList after initialization (see TUTC03), or accessed thread-safely with e.g. Collections.synchronizedList or thread-safe implementations like ConcurrentHashMap.
            &#13;3. For autowiring/injection, the assignment of the reference is thread safe, so final is not required. The unmodifiable/thread-safe requirement for that field still holds. Also make sure no other thread-unsafe assignment is made to that field.
            &#13;4. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit.
            &#13;5. Use package private and @VisibleForTesting for methods used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: if @NotThreadSafe no checking :)
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
(: primary expression used :)
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block/BlockStatement/Statement//../PrimaryExpression//PrimaryPrefix/Name[(
(: not 'this' and extends a base class :)
((@Image != '') and ancestor::ClassOrInterfaceDeclaration/ExtendsList and
(:  has arguments (a method call), and  a compound like date.setTime, map.put, list.set :)
(contains(@Image, '.set') or contains(@Image, '.put') or contains(@Image, '.clear') or contains(@Image, '.add') or contains(@Image, '.remove') or contains(@Image, '.replace')) and
(: not starting with a capital, a Class :)
not (starts-with(@Image, upper-case(substring(@Image, 1, 1)))) and
(: not a field of this class :)
not (exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))
(: not a param or local :)
     or exists(index-of((ancestor::ClassOrInterfaceBodyDeclaration//VariableDeclaratorId/@Name), substring-before(concat(@Image, '.'), '.')))))
and not (ancestor::SynchronizedStatement or ancestor::MethodDeclaration[@Synchronized = true()])
)
(: expression not on accessor method with assignment, annotated with framework annotation :)
and not (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject']
(: field not used in non-public accessor method annotated with VisibleForTesting :)
or (ancestor::ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='VisibleForTesting'] and ancestor::MethodDeclaration[@Public=false()]))]
                    ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidUserDataInSharedObjects" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do *not* use user data in shared objects, it causes user data mix-up."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ssc03">
        <description>The name of the field indicates user data. Problem: the field will be shared among users. If it is different data for each user, it can mix-up: a user may access data of another user, this is really bad.&#13;
            Solution: Do *not* put the user related data in a shared object e.g. by Spring @Component annotation. Use a POJO. Or, if it is not user data, rename the field. (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix[Literal[@Image='"request"' or @Image='"prototype"']
or Name[@Image='ConfigurableBeanFactory.SCOPE_REQUEST' or @Image='ConfigurableBeanFactory.SCOPE_PROTOTYPE']])
and not (ancestor::TypeDeclaration/Annotation//Name[@Image='RequestScope'])
(: no checking if @ConfigurationProperties and no @Setter :)
and not ((ancestor::TypeDeclaration/Annotation//Name[@Image='ConfigurationProperties'])
         and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/ancestor::TypeDeclaration//ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Static=false()][Type/ReferenceType][ancestor::ClassOrInterfaceDeclaration[1][@Static=false()]]/VariableDeclarator/VariableDeclaratorId[matches(@Name,
'User[Id|Ref|Reference]*$|Customer[Id|Ref|Reference]*$|Session[Id|Ref|Reference]*$|Order[Id|Ref|Reference|List]*$|Account[Id|Ref|Reference|List]*$|Transaction[Id|Ref|Reference|List]*$|Contract[Id|Ref|Reference|List]*$', 'i')]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,data-mix-up,jpinpoint-rule,multi-threading,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@Component
@Data
public class VMRData {
    private String channel;
    private String vmrId;
    private List<OrderDetails> orderList; // bad
    private Headers headers;
    private List<OrderReference> ordersRequiringAdditionalSignature;
    private String authUser; // bad
    private String executionDate;
    private String minimumLevel;
    private String sessionId; // bad
    private String payloadData;
    private String vmrUserId; // bad
    private String userref; // bad
    private String customerReference; // bad
    private String contract; // bad
}

@Component
@Setter
@Getter
 class VMROrderDetails {
    private static final String DESC_OF_ORDER = "order details"; // ok
    private final VMROrderDetails finalOrder = new VMROrderDetails(); // ok
    private OrderReference orderReference; // bad
    private Account originatorAccount; // bad
    private Amount amount;
    private String action;
    private List<CancellationHistory> cancellationHistories;
    private String modifyType;
    private String order; // bad
    private String transactionRef; // bad
}

]]>
        </example>
    </rule>

    <rule name="AvoidVolatileInPrototypeScope" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="No need for volatile in prototype scope" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc10">
        <description>A field is defined as volatile while the class has prototype scope. Problem: volatile has some overhead, especially for writes. When getting the bean from the Spring applicationContext, prototype scope means that each invocation creates a new object so the field is not shared. &#13;
            Solution: Since only one thread can access the field, there is no need for violatile and it can be removed. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //FieldDeclaration[@Volatile = true() and
    ancestor::TypeDeclaration/Annotation//Name[@Image='Scope']/..//PrimaryPrefix/
    (Name[ends-with(@Image,'SCOPE_PROTOTYPE')]|Literal[contains(@Image, 'prototype')])]
                        ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Bad {
    private volatile String id;
}

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class Good {
    private String id;
}
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnFieldWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy(field)"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which the GuardedBy annotation is applied is not accessed thread-safely as described by GuardedBy.&#13;
            Solution: Make access thread-safe: synchronize access by a synchronized(LOCK) block with LOCK being a final field.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded-by literal *IS* a field (should be private final) :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[substring(@Image, 2, (string-length(@Image) - 2))=
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS NOT* in a synchronized block with the GuardedBy literal:)
    and (not(concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
    ,
    //MethodDeclaration[
    not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
    (: a variable which should (potentially) be guarded :)
    //PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
    (: used in a class with guarded by literal *IS NOT* a field :)
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal[not (substring(@Image, 2, (string-length(@Image) - 2)) =
    ancestor::ClassOrInterfaceBody//FieldDeclaration//VariableDeclaratorId/@Name)
    ]/
    (: is defined as field :)
    ancestor::ClassOrInterfaceBodyDeclaration//FieldDeclaration//VariableDeclaratorId/@Name
    (: and *IS* in a synchronized block with the GuardedBy literal:)
    and (
    (concat('"', ancestor::SynchronizedStatement/Expression//Name/@Image, '"') =
    ancestor::ClassOrInterfaceBody//Annotation//Name[@Image='GuardedBy']/..//Literal/@Image)
    )]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() { return txt; } // bad
        public synchronized void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        private final Object LOCK = new Object();
        @GuardedBy("LOCK")
        private String txt;

        public String getText() {
            synchronized(LOCK) { return txt; }
        }
        public void setText(String t) {
            synchronized(LOCK) { txt = t; }
        }
    }
            ]]>
        </example>
    </rule>

    <rule name="NotProperlySynchronizingOnThisWhileUsingGuardedBy"
          message="Not properly synchronizing access of field while using @GuardedBy('this')"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://jcip.net/annotations/doc/index.html">
        <description>
            Problem: The field to which this annotation is applied should only be accessed when holding the built-in 'this' lock by using synchronized.&#13;
            Solution: Make access thread-safe: synchronize access by method modifier or a synchronized(this) block.&#13;
            Note that methods with annotations @Autowired, @PostConstruct, @BeforeStep, @Value and @Inject are ignored.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[(@Synchronized=false() or @Static=true())
and not (../Annotation//Name[@Image='Autowired' or @Image='PostConstruct' or @Image='BeforeStep' or @Image='Value' or @Image='Inject'])]
//PrimaryPrefix/Name[substring-before(concat(@Image,'.'), '.') =
(ancestor::ClassOrInterfaceBody|ancestor::EnumBody)//Annotation//Name[@Image='GuardedBy']/..//Literal[@Image='"this"']/
ancestor::ClassOrInterfaceBodyDeclaration/FieldDeclaration//VariableDeclaratorId/@Name
and (
not (ancestor::SynchronizedStatement)
or ancestor::SynchronizedStatement/Expression//Name)]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    class Bad1 {
        @GuardedBy("this")
        private String txt;

        public String getText() { return txt; } // bad
        public void setText(String t) { txt = t; } // bad
    }

    class Good1 {
        @GuardedBy("this")
        private String txt;

        public synchronized String getText() { return txt; }
        public synchronized void setText(String t) { txt = t; }
    }
            ]]>
        </example>
    </rule>

    <rule name="SynchronizingForLocalVars" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Local variables don't need synchronization" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc12">
        <description>In the synchronized block, only local variables seem to be accessed. Problem: synchronization has overhead and may introduce lock contention. &#13;
            Solution: Remove synchronized because local variables are only accessible by the owning thread and are not shared. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: var.x() in synchronized block, var in list of local vars and all var.x in synchronized block are local vars:)
//SynchronizedStatement[count(./Block//PrimaryPrefix/Name[
    index-of(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name, substring-before(@Image, '.')) >= 0]) =
count(./Block//(PrimaryPrefix/Name|PrimarySuffix)[substring-before(@Image, '.')])
and
(: vars used in synchronized block are all local vars :)
count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name |
     ./Block//(PrimaryPrefix/Name|PrimarySuffix)[@Image != '' and not(contains(@Image, '.'))]/@Image))
 = count(distinct-values(ancestor::MethodDeclaration//LocalVariableDeclaration//VariableDeclaratorId/@Name ))]
                        ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,cpu,jpinpoint-rule,multi-threading,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class Foo {
    private Map<String, String> mapField;

    protected Map<String, String> bad() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) { // bad
          if (addHeaders == null) {
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }

  protected Map<String, String> good() {
      Map<String, String> addHeaders = MDC.getCopyOfContextMap();

      synchronized (this) {
          if (mapField == null) {
              mapField = new HashMap<>();
              addHeaders = new HashMap<>();
          }
      }
      return addHeaders;
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'concurrent.xml' -->
<!-- BEGIN Included file 'enterprise.xml' -->
    <rule name="DefineConcurrencyForJavaEESingleton"
      message="For JavaEE @Singleton, make @ConcurrencyManagement explicit and define @Lock on class level or for all public methods."
      class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
      typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc13">
    <description>
        Problem: A JavaEE @Singleton has default @ConcurrencyManagement CONTAINER and write locks. Using defaults is unclear and write locks typically cause much more contention than read locks. &#13;
        Solution: Make @ConcurrencyManagement and @Lock-s explicit, @Lock on class level or on all public methods. Or use BEAN managed for full control using e.g. synchronized or volatile.&#13;
        (jpinpoint-rules)</description>
    <priority>3</priority>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//TypeDeclaration/Annotation//Name[@Image='Singleton' and (not (ancestor::TypeDeclaration/Annotation//Name[@Image='ConcurrencyManagement'])
or (ancestor::TypeDeclaration/Annotation//Name[@Image='ConcurrencyManagement' and ../MemberValue//Name[@Image='ConcurrencyManagementType.CONTAINER']] and
((not (ancestor::TypeDeclaration/Annotation//Name[@Image='Lock']))
and (count(ancestor::TypeDeclaration//MethodDeclaration[@Public=true() and not(exists(../Annotation//Name[@Image='Lock'])) ]) > 0))
))]
                ]]>
            </value>
        </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,cpu,jpinpoint-rule,multi-threading,performance,sustainability-low" type="String" description="classification"/>
    </properties>
    <example>
        <![CDATA[
@Singleton // bad - 1. @ConcurrencyManagement missing 2. @Lock missing on public method
class SingletonBad {
    private String state;
    public String getState() {
        return state;
    }
    @Lock(LockType.WRITE)
    public void setState(String newState) {
        state = newState;
    }
}
@Singleton
@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER)
class SingletonGood {
    private String state;
    @Lock(LockType.READ)
    public String getState() {
        return state;
    }
    @Lock(LockType.WRITE)
    public void setState(String newState) {
        state = newState;
    }
}
]]>
    </example>
</rule>

<!-- END Included file 'enterprise.xml' -->
<!-- BEGIN Included file 'remoting.xml' -->
    <rule name="AvoidClientHttpRequestFactorySupplier" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid use of ClientHttpRequestFactorySupplier."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi17">
        <description>Problem: The org.springframework.boot.web.client.ClientHttpRequestFactorySupplier may return a HttpComponentsClientHttpRequestFactory which you supply as @Bean, however,
            this can silently go wrong and e.g. an unconfigured SimpleClientHttpRequestFactory can be returned.
            Default pool size and timeouts will be used, possibly resulting in very slow connection use.&#13;
            Solution: Provide your own supplier with explicit pool sizing and timeouts by a class implementing Supplier. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression/ClassOrInterfaceType[@Image='ClientHttpRequestFactorySupplier']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.boot.web.client')]]]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule,performance,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.boot.web.client.ClientHttpRequestFactorySupplier;
import org.springframework.web.client.RestTemplate;

class Bad {
    void bad() {
        RestTemplate restTemplate = new RestTemplateBuilder(rt -> rt.getInterceptors()
               .add((request, body, execution) -> {
                   request.getHeaders().add("SomeKey", someKey);
                   return execution.execute(request, body);
               }))
               .requestFactory(new ClientHttpRequestFactorySupplier()) // bad
               .uriTemplateHandler(defaultUriBuilderFactory)
               .build();
       return restTemplate;
    }
}

class MyClientHttpRequestFactorySupplier implements Supplier<ClientHttpRequestFactory> {

    public ClientHttpRequestFactory get() {
           PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();
           poolingHttpClientConnectionManager.setDefaultMaxPerRoute(MAX_CONN_PER_ROUTE);
           poolingHttpClientConnectionManager.setMaxTotal(MAX_CONN_TOTAL);

           CloseableHttpClient httpClient = HttpClients.custom()
                 .setConnectionManager(poolingHttpClientConnectionManager)
                 .disableConnectionState()
                 .build();
           return new HttpComponentsClientHttpRequestFactory(httpClient);
    }
}
and use it to replace the bad line in Bad example:
            .requestFactory(new MyClientHttpRequestFactorySupplier()) // good
]]>
        </example>
    </rule>

    <rule name="AvoidDeprecatedHttpConnectors" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid the use of deprecated/thread-unsafe HTTP connectors" typeResolution="true"
      externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi06" >
    <description>Problem: Several HTTP client connection managers are thread-unsafe which may cause session data mix-up or have other issues for which they were made deprecated.&#13;
        Solutions: Upgrade to httpclient-4.5+ and use org.apache.http.impl.conn.PoolingHttpClientConnectionManager and e.g. org.apache.http.impl.client.HttpClientBuilder. (jpinpoint-rules)</description>
    <priority>2</priority>
    <properties>
        <property name="xpath">
            <value><![CDATA[
//ImportDeclaration/Name[@Image='org.apache.commons.httpclient.SimpleHttpConnectionManager'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.http.impl.conn.PoolingClientConnectionManager'
or @Image='org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager'
or @Image='org.apache.http.impl.conn.SingleClientConnManager'
or @Image='org.apache.http.impl.client.DefaultHttpClient'
or @Image='org.apache.http.impl.client.SystemDefaultHttpClient'
or @Image='org.apache.http.conn.ClientConnectionManager'
or @Image='org.apache.commons.httpclient.MultiThreadedHttpConnectionManager'
]
|
//ClassOrInterfaceType[pmd-java:typeIs('org.apache.commons.httpclient.SimpleHttpConnectionManager')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.PoolingClientConnectionManager')
or pmd-java:typeIs('org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.conn.SingleClientConnManager')
or pmd-java:typeIs('org.apache.http.impl.client.DefaultHttpClient')
or pmd-java:typeIs('org.apache.http.impl.client.SystemDefaultHttpClient')
or pmd-java:typeIs('org.apache.http.conn.ClientConnectionManager')
or pmd-java:typeIs('org.apache.commons.httpclient.MultiThreadedHttpConnectionManager')
]
|
//AllocationExpression[pmd-java:typeIs('org.apache.commons.httpclient.HttpClient')
]
		     ]]></value>
        </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,deprecated,jpinpoint-rule,multi-threading" type="String" description="classification"/>
    </properties>
        <example>
            <![CDATA[
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager; // bad
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;

public class Bad {
    private MultiThreadedHttpConnectionManager mgr = new MultiThreadedHttpConnectionManager(); // bad
}
class Good {
    private PoolingHttpClientConnectionManager mgr = new PoolingHttpClientConnectionManager();
}
            ]]>
        </example>
</rule>

    <rule name="AvoidDeprecatedHystrix" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Netflix Hystrix is deprecated. Use an alternative like resilience4j"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi11">
        <description>Problem: Hystrix is not actively maintained anymore.&#13;
            Solution: Netflix recommends to use open source alternatives like resilience4j. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ImportDeclaration/Name[starts-with(@Image, "com.netflix.hystrix")]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="deprecated,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
        </example>
    </rule>

    <rule name="AvoidDiscardingHttpClientConfig" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not replace the configured httpClient provided in the constructor of the factory."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi15">
        <description>Problem: Apache HttpComponentsClientHttpRequestFactory has a constructor which takes a HttpClient and also a setter: setHttpClient.
            If you use both on the same factory, you discard all configuration done on the one provided in the constructor because it is replaced by the one provided to the setter.  &#13;
            Solution: Don't use both on the same factory, provide the HttpClient only once to the factory. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Statement[StatementExpression[//ArgumentList]/PrimaryExpression/PrimaryPrefix/Name/@Image =
ancestor::MethodDeclaration//VariableDeclarator[.//AllocationExpression/ClassOrInterfaceType[@Image='HttpComponentsClientHttpRequestFactory'][..//ArgumentList]]
    /VariableDeclaratorId/concat(@Name, '.setHttpClient')]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(HttpClientBuilder.create()
                .setMaxConnTotal(config.getMaxTotalConnections())
                .setMaxConnPerRoute(config.getMaxConnPerRoute())
                .build());

        factory.setHttpClient(createHttpClient(config)); //bad
        return factory;
    }
}

class Good {
    ClientHttpRequestFactory getFactory(HttpClientConfiguration config) {
        HttpComponentsClientHttpRequestFactory factory =
            new HttpComponentsClientHttpRequestFactory(createFullyConfiguredHttpClient(config));
        return factory;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidExcessiveClassloadingWithSaajSoap"
          message="Avoid excessive class loading with SAAJ SOAP messaging, use alternative Axiom, or system properties."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi23">
        <description>Problem: SAAJ uses DOM to load the XML document in memory which uses a TransformerFactory. The implementation class of it is loaded on every call which causes lock contention under load. This means long response times.&#13;
            Solution: If possible, use Axiom SOAP messaging which uses the faster StAX. If you have/want to stick to SAAJ, set the proper system properties to prevent the excessive class loading.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Type//ClassOrInterfaceType[@Image='SaajSoapMessageFactory'
and not (ancestor::ClassOrInterfaceBody//PrimaryExpression[./PrimaryPrefix/Name[@Image='System.setProperty'] and ./PrimarySuffix/Arguments//Literal[@Image = '"javax.xml.transform.TransformerFactory"']])]
|
//AllocationExpression/ClassOrInterfaceType[@Image='SaajSoapMessageFactory'
and not (ancestor::ClassOrInterfaceBody//PrimaryExpression[./PrimaryPrefix/Name[@Image='System.setProperty'] and ./PrimarySuffix/Arguments//Literal[@Image='"javax.xml.transform.TransformerFactory"']])]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.ws.soap.saaj.SaajSoapMessageFactory;

class Foo {
    private final SaajSoapMessageFactory mfField; // bad, also possibly thread-unsafe

    public WebServiceTemplate getTemplate(final String uri, final HttpClientMessageSender httpClientMessageSender) throws SOAPException {
        SoapMessageFactory saajSoapMessageFactory = new SaajSoapMessageFactory(MessageFactory.newInstance()); // bad
        //..
    }
}

//To solve, add to the above:
    static {
        System.setProperty("javax.xml.transform.TransformerFactory", "com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl");
        System.setProperty("javax.xml.soap.MessageFactory", "com.sun.xml.internal.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl");
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidHardcodedConnectionConfig"
          message="Avoid hardcoded connection configuration."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi22">
        <description>Problem: configuring connection settings like timeouts and pool sizes in code (int values) makes it difficult to manage and tune these settings.&#13;
            Solution: use property files, e.g. yml, to define the values for these settings for each called service.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//FieldDeclaration[Type/@TypeImage='int']/VariableDeclarator[VariableDeclaratorId[@Final = true()][contains(upper-case(@Name), 'TIMEOUT') or contains(upper-case(@Name), 'DURATIONOUT')
or(contains(upper-case(@Name), 'MAX') and contains(upper-case(@Name), 'ROUTE'))]]
[VariableInitializer//Literal or VariableDeclaratorId/@Name=ancestor::ClassOrInterfaceBody//ConstructorDeclaration//StatementExpression[Expression//Literal]//Name/@Image]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class AvoidHardcodedConnectionConfig {
    private static final int CONNECTION_TIMEOUT = 50000;// bad
    private static final int SOCKET_TIMEOUT = 250000;// bad
    private static final int TRANSACTION_TIMEOUT_SECONDS = 2;// bad
    private static final int CONNECTION_TIMEOUTMILLIS = 1000;// bad

    private static final int MAX_CONN_PER_ROUTE = 10;// bad
    static final int MAX_PER_ROUTE = 100;// bad
    final int MAX_NUM_ROUTES = 2; // bad
    int some_timeout_ms = 300; //good, variable
    private static final String LOGIN_TIMEOUT_PROPERTY_KEY = "loginTimeout"; // good, not an int
    final int other_timeout_s_blank; // bad, blank final and hard coded
    private final int connectTimeoutMillis; // good, not hard coded

    AvoidHardcodedConnectionConfig(@Value("${connect_timeout:1000}") int connectTimeoutMillis) {
        this.connectTimeoutMillis = connectTimeoutMillis; // good, not hard coded
        other_timeout_s_blank = 5; // field bad
        final int timeout_s_local = 4; // good, method level
        int otherTimeoutInS = 3; // good, var
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidHttpHostOneArgumentConstructor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid the HttpHost constructor with only hostname, provide port number and protocol as well."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi16">
        <description>Problem: the HttpHost constructor with one argument must only be provided with a host name, the default port 80 and protocol http are implied.
            The mistake of providing a URL and assuming it will be parsed into hostname, port and protocol is easily made.
            When this HttpHost is then used for a route and stored socketConfig for, port 80 is added for the host and the socketConfig is stored with the wrong key and will not be used.
            It is typically difficult to find out if the config is actually used. Note that http://github.com/jborgers/http-client-monitor helps here.&#13;
            Solution: Use the HttpHost constructor with 2 (including port) or preferably 3 arguments (including port and protocol). (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//AllocationExpression[pmd-java:typeIs("org.apache.http.HttpHost")]/Arguments/ArgumentList[count(./Expression) = 1]/../..
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.HttpHost;

class Foo {
    private static final String URL = "localhost:8080";
    private static final HttpHost hostBad1 = new HttpHost("localhost:8080"); // bad

    void bar() {
        HttpHost hostBad2 = new HttpHost(URL);//bad
        HttpHost hostGood1 = new HttpHost("localhost", 8080, "http"); //good
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidJAXBUtil"
          language="java"
          message="The JAXB utility class is not optimized for performance."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXB utility methods do not reuse JAXBContext when more than one context is used. &#13;
            Solution: use JAXB API directly for marshalling and unmarshalling to gain all the performance benefits as described in IUOXAR04 and IUOXAR06.
        (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('javax.xml.bind.JAXB')]
	         ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class XMLConversion {
    public <T> T myUnmarshal(final Source response, final Class<T> clazz) {
        return JAXB.unmarshal(response, clazz); // bad
    }
    public void myMarshal(final Object response, StringWriter stringWriter) {
        JAXB.marshal(response, stringWriter); // bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidLeakingRetryEventConsumers"
          message="Avoid leaking of retry event consumers."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#pml06">
        <description>Problem: A resilience4j retry event consumer is added to a retry event publisher for every method call. Likely a lambda retaining one or more objects.
            This will result in a growing list of consumers: a memory leak. Besides, the event will be sent to the growing number of consumers, taking more and more CPU time.&#13;
            Solution: Only call EventPublisher.onRetry (that is, add a consumer) in the same scope as the Retry instance lives. Note there is no way to unregister a consumer.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//PrimaryPrefix/Name[pmd-java:typeIs('io.github.resilience4j.retry.Retry') and ends-with(@Image, '.getEventPublisher')]
(: any on-method: onRetry, onError, .. :)
[../../PrimarySuffix[starts-with(@Image, 'on')]]
(: it is a field :)
[exists(index-of((ancestor::ClassOrInterfaceBody//FieldDeclaration[pmd-java:typeIs('io.github.resilience4j.retry.Retry')]
/VariableDeclarator/VariableDeclaratorId/@Name), substring-before(@Image,'.')))]
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.Retry;

public class Foo {
    Retry retryField;
    RetryRegistry reg;
    final AtomicInteger retryCountField = new AtomicInteger();

    Foo() {
        retryField = reg.retry("one per service");
        retryField.getEventPublisher().onRetry(event -> retryCountField.getAndIncrement()); // good
    }

    void callService() {
        AtomicInteger retryCountLocal = new AtomicInteger();
        retryField.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // bad, lambda and AtomicInt leak

        Retry retryLocal = reg.retry("one per method call");
        retryLocal.getEventPublisher().onRetry(event -> retryCountLocal.getAndIncrement()); // good, no leak

        // same for onSuccess, onError, onIgnoredError
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidModifyingObjectMapper" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="ObjectMapper is configured/modified, only initialize it right after construction."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuojar02">
        <description>Problem: ObjectMapper is thread-safe only after configuration. Configuring an ObjectMapper is not thread-safe.  &#13;
            Solution: Avoid configuring objectMappers except when initializing: right after construction. It is recommended to create ObjectReaders and ObjectWriters from ObjectMapper and pass those around since they are immutable and therefore thread-safe. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: exclude method annotated with PostConstruct :)
//ClassOrInterfaceBodyDeclaration[count(Annotation//Name[@Image='PostConstruct']) = 0]
(: exclude factory where config is in method returning 'this' and one method, typically build(), returning objectMapper :)
/MethodDeclaration[count(Block//ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix[@ThisModifier=true()])=0
or ancestor::ClassOrInterfaceBody[count(.//MethodDeclaration/ResultType/Type[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]) != 1]]
(: modify operations on objectMapper in a method where objectMapper is a formal parameter or field :)
//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::MethodDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration)[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
,
(: modify operations on objectMapper in a constructor where objectMapper is a formal parameter or static field :)
//ConstructorDeclaration//Statement//Name[(concat(substring-before(@Image, '.config'), substring-before(@Image, '.set'), substring-before(@Image, '.register')
, substring-before(@Image, '.find'), substring-before(@Image, '.disable'), substring-before(@Image, '.enable'), substring-before(@Image, '.activate')
, substring-before(@Image, '.deactivate'), substring-before(@Image, '.add'), substring-before(@Image, '.clear'))
=
(ancestor::ConstructorDeclaration//FormalParameter|ancestor::ClassOrInterfaceBody//FieldDeclaration[@Static=true()])[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')]//VariableDeclaratorId/@Name)
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    public class OldStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper();
        private final ObjectMapper mapperField = new ObjectMapper();

        static {
            staticObjectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        public OldStyle() {
            mapperField.setSerializationInclusion(JsonInclude.Include.NON_NULL); // good
        }

        ObjectMapper bad(ObjectMapper mapper) {
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); // bad
            return mapper;
        }
    }

    public class NewStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidObjectMapperAsField" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid ObjectMapper as field, use ObjectReader or ObjectWriter instead."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuojar02">
        <description>Problem: Configuring an ObjectMapper is thread-unsafe.  &#13;
            Solution: Create ObjectReaders and ObjectWriters from ObjectMapper and only share those as field, since they are immutable and therefore thread-safe.
            Exceptions: A convertValue method is not provided by ObjectReader nor ObjectWriter, therefore in those cases this rule is not applied.
            Also when used like jaxMsgConverter.setObjectMapper(objectMapper) it is not considered a violation. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(for $node in (//FieldDeclaration[pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
(: if class not in classpath, can use following line :)
(:or (Type//ClassOrInterfaceType[@Image='ObjectMapper'] and //ImportDeclaration/Name[starts-with(@Image, 'com.fasterxml.jackson.databind.')]):)
]//VariableDeclaratorId)
(: exception: do not match if that field name is used in its class with a convertValue method :)
return ($node[not(ancestor::ClassOrInterfaceDeclaration//PrimaryPrefix/Name[@Image = concat($node/@Name, '.convertValue')])
(: exception: do not match if used with jaxMsgConverter.setObjectMapper(objectMapper) :)
and not($node/@Name = ancestor::ClassOrInterfaceDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, 'setObjectMapper')]]
(:[pmd-java:typeIs('org.springframework.http.converter.json.MappingJackson2HttpMessageConverter')] - somehow class resolution fails :)
/PrimarySuffix//PrimaryPrefix/Name/@Image)
]))
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    public class BadStyle {
        private static final ObjectMapper staticObjectMapper = new ObjectMapper(); // bad
        private final ObjectMapper mapperField = new ObjectMapper(); //bad
    }

    class GoodStyle {
        private static final ObjectWriter staticObjectWriter =
            new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).writer(); // good
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidReactorDebugOverhead" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Do not use Reactor debugging in production, it has much overhead."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi14">
        <description>Problem: For troubleshooting Reactor, Blockhound can be used. It needs proper stack traces which can be achieved by Hooks.onOperatorDebug(). This can have much CPU overhead. &#13;
            Solution: Remove Hooks.onOperatorDebug() when not debugging. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//StatementExpression/PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('reactor.core.publisher.Hooks')]//Name[ends-with(@Image, 'Hooks.onOperatorDebug')]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import reactor.core.publisher.Hooks;

public class Foo {
    public void bar() {
        Hooks.onOperatorDebug(); //bad
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidRecreatingHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="An HttpClient is created and combined with request-response."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi12">
        <description>Problem: Apache HttpClient with its connection pool and timeouts should be setup once and then used for many requests. It is quite expensive to create and can only provide the benefits of pooling when reused in all requests for that connection.&#13;
            Solution: Create/build HttpClient with proper connection pooling and timeouts once, and then use it for requests. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration[count(.//Annotation//Name[@Image='Configuration']) = 0]
    //MethodDeclaration//VariableInitializer//Name[
    @Image='HttpClientBuilder.create' or @Image='HttpClients.custom' or @Image='HttpAsyncClientBuilder.create']
    [ancestor::MethodDeclaration//ClassOrInterfaceType[@Image='HttpEntity' or @Image='ResponseEntity']]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Foo {
    ResponseEntity<Object> connectBad(Object req) {
        HttpEntity<Object> requestEntity = new HttpEntity<>(req);

        HttpClient httpClient = HttpClientBuilder.create().setMaxConnPerRoute(10).build(); // bad
        return remoteCall(httpClient, requestEntity);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidXMLGregorianCalendar" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="XMLGregorianCalendar is used. It is slow in JAXB." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar05">
        <description>Problem: XMLGregorianCalendar is a large object, involving substantial processing. It is created with the poorly performing DatatypeFactory.
            Solution: Add a converter for alternative date handling with Java 8+ java.time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
FieldDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
|
//TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/
MethodDeclaration//LocalVariableDeclaration/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.xml.datatype.XMLGregorianCalendar')]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AxualProducerCreatedForEachMethodCall"
          message="An Axual (Kafka) producer is created for each method call, which is expensive and takes resources."
          class="net.sourceforge.pmd.lang.rule.XPathRule"
          dfa="false"
          language="java"
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia10">
        <description>Problem: each Producer takes threads and memory. If you create it in each method call, and call this frequently, it will result in an explosion of threads and memory used and lead to Out Of Memory Error.  &#13;
            Solution: Since the Axual Producer is thread-safe, it should be shared e.g. from a static field.
            (jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//VariableDeclarator[pmd-java:typeIs('io.axual.client.producer.Producer')]
[ancestor::TypeDeclaration[count(./Annotation//Name[@Image='Configuration'])=0]]
			]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import io.axual.client.producer.Producer;

public class AxualProducerBad {
    public void publishToEventStream() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig); // bad
        producer.produce(msg);
    }
}

class AxualProducerGood1{
    private static final Producer<String, String> producer = AxualClient.buildProducer(producerConfig);
}

@Configuration
class AxualProducerGood2{
    public Producer<String, String> axualProducer() {
        Producer<String, String> producer = axualClient.buildProducer(producerConfig);
        return producer;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="BufferingClientHttpRequestFactoryIsMemoryGreedy" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="BufferingClientHttpRequestFactory is memory greedy. Only use when multiple reads of the response body cannot be avoided."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi18">
        <description>org.springframework.http.client.BufferingClientHttpRequestFactory is used.
            Problem: It buffers all incoming and outgoing streams fully in memory which may result in high memory usage. &#13;
            Solution: Avoid multiple reads of the response body so it is not needed. (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: somehow typeIs does not work with spring-web-6.0, do it old school way :)
//AllocationExpression/ClassOrInterfaceType[@Image='BufferingClientHttpRequestFactory']
[/CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.springframework.http.client')]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,memory,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.http.client.*;
import org.springframework.web.client.RestTemplate;

public class Foo {
    public RestTemplate createMemoryGreedyRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(new BufferingClientHttpRequestFactory(factory)); // bad
    }

    public RestTemplate createStreamTroughRestTemplate(HttpClientConfiguration httpClientConfiguration) {
        ClientHttpRequestFactory factory = getClientHttpRequestFactory(httpClientConfiguration);
        return new RestTemplate(factory); // good
    }
}
]]>
        </example>
    </rule>

    <rule name="DefaultFeignClientWithoutTLSConnectionReuse" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Default Feign client is used with (mutual) TLS. This is HttpURLConnection that creates a new connection for each call with TLS overhead." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi21">
        <description>Problem: the default http client of Feign is java.net.HttpURLConnection that does not pool connections when using mutual TLS. This causes connection handshake overhead: extra CPU usage and higher latency.&#13;
            Solution: switch to a Feign client that supports HTTP connection pooling with mTLS, for instance Apache HttpClient 4 with disableConnectionState and proper connection pool size and timeouts. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: default client constructor with sslSocketFactory :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('feign.Client.Default')
and not(ancestor::Expression//Arguments[ArgumentList/@Size=2]//Expression[1]//NullLiteral)]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import feign.Client;

public class MyFeignClient {

    public Client createClient(SSLSocketFactory sslSocketFactory){
        return new Client.Default(sslSocketFactory, null); // bad
    }

    public Client createClient(){
        return new Client.Default(null, null); // good
    }

    public Feign.Builder feignBuilder() {
        Client feignClient =
            new Client.Default(setupSSLContextForMutualTLS().getSocketFactory(), new DefaultHostnameVerifier()); // bad
        return Feign.builder().client(feignClient);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="GsonCreatedForEachMethodCall" message="A Gson object is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOJAR03">
        <description>Problem: Gson creation is relatively expensive. A JMH benchmark shows a 24x improvement reusing one instance. &#13;
            Solution: Since Gson objects are thread-safe after creation, they can be between threads. So, reuse created instances, from a static field. Pay attention
            to use thread-safe (custom) adapters and serializers.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	pmd-java:typeIs('com.google.gson.Gson')
	and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
    pmd-java:typeIs('com.google.gson.GsonBuilder')
    and ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'create')]
    and not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
]
			]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="HttpClientBuilderPoolSettingsIgnored" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used with a ConnectionManager and MaxConn settings on the client are ignored. Remove them." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi09">
        <description>Problem: If you use setConnectionManager, the connection pool must be configured on that Connection Manager. Pool settings on the client are ignored and lost. &#13;
            Solution: HttpClients should either 1. use setConnectionManager and *only* call setMaxTotal and setDefaultMaxPerRoute on that ConnectionManager or
            2. not use a ConnectionManager and call setMaxConnTotal and setMaxConnPerRoute on the client directly (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder with setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
,
(: method param http client builder setConnectionManager and at least one of setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClient')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')])
]/ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="correctness,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create()
                .setConnectionManager(conMgr)
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL) // bad, ignored
                .build();

        return HttpClientBuilder.create() // good
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutDisableConnectionState" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A HttpClient builder is used and disableConnectionState is not called. HTTP client tracks connection state while using TLS" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi07">
        <description>Problem: NTLM authenticated connections and SSL/TLS connections with client certificate authentication are stateful: they have a specific user identity/security context per session. If HttpClients have enabled connection state tracking which is the default, established TLS connections will not be reused because it is assumed that the user identity or security context may differ.
            Then performance will suffer due to a full TLS handshake for each request.&#13;
            Solution: HttpClients should disable connection state tracking in order to reuse TLS connections, since service calls for one pool have the same user identity/security context for all sessions. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(:locally created http client builder without disableConnectionState :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
(@Image="HttpClientBuilder.create" or @Image="HttpAsyncClientBuilder.create" or @Image="HttpClients.custom") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
,
(: method param http client builder without disableConnectionState :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
(@Image="HttpClientBuilder" or @Image="HttpAsyncClientBuilder" or @Image="HttpClients") and not(
ancestor::MethodDeclaration//PrimarySuffix/@Image="disableConnectionState")]
			]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="HttpClientBuilderWithoutPoolSize" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient builder is used and the connection pool is not configured. HttpClient defaults of 2 per route and 20 max total are probably not right." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi03">
        <description>Problem: by default only 2 connections are available per route. When two external calls are being made, a third thread requesting a connection must wait for a free connection.&#13;
            Solution: HttpClients should explicitly define the number of connections per route. If only one route is used, make the max number of connections equal to conn per route.
            Either use 1. setConnectionManager and call setMaxTotal and setDefaultMaxPerRoute on that connection manager, or 2. no ConnectionManager: call setMaxConnTotal and setMaxConnPerRoute on the client directly. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: locally created http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
    and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param http client builder without setMaxConnTotal/setMaxConnPerRoute :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and (count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxConnTotal') or ends-with(@Image, 'setMaxConnPerRoute')])<2
       and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionManager')]))
]
,
(: method param PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration (: only when returning a connection manager :)
    [ResultType/Type[pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')]]
   //FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
,
(: new PoolingHttpClientConnectionManager without setMaxTotal/setDefaultMaxPerRoute :)
//MethodDeclaration//PrimaryExpression//ClassOrInterfaceType[
   pmd-java:typeIs('org.apache.http.impl.conn.PoolingHttpClientConnectionManager')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setMaxTotal') or ends-with(@Image, 'setDefaultMaxPerRoute')])<2
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
        return HttpClientBuilder.create() // bad, missing setMaxConnPerRoute/setMaxConnTotal or setConnectionManager
                .disableConnectionState()
                .build();

        return HttpClientBuilder.create() // good, both setMaxConnPerRoute and setMaxConnTotal called on client
                .setMaxConnPerRoute(MAX_CONNECTIONS_TOTAL)
                .setMaxConnTotal(MAX_CONNECTIONS_TOTAL)
                .build();

        return HttpClientBuilder.create() // good, setConnectionManager called, pool config delegated
                .setConnectionManager(conMgr)
                .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientBuilderWithoutTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="HttpClient-v4 builder is used and not all three timeouts are configured. The defaults are probably not optimal (e.g. infinite). " typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IBI10">
        <description>Problem: (Apache client version 4) For connectionRequestTimeout, connectTimeout, socketTimeout (for HttpComponentsClientHttpRequestFactory) or readTimeout (for RequestConfig) the default timeout settings are not optimal in most cases. &#13;
            Solution: Set the timeouts explicitly to proper reasoned values. See best practice values via the link. Use the setDefaultRequestConfig with a method with a RequestConfig object on HttpClient builders to set the timeouts.(jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: only for Apache http client 4 :)
(: locally created http client builder without setDefaultRequestConfig to set timeouts :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
 (
   (pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder') and @Image='HttpClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder') and @Image='HttpAsyncClientBuilder.create')
    or (pmd-java:typeIs('org.apache.http.impl.client.HttpClients') and @Image='HttpClients.custom')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
]
,
(: method param http client builder without setDefaultRequestConfig or by RequestConfigCallback to set timeouts :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
 (
   pmd-java:typeIs('org.apache.http.impl.client.HttpClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.nio.client.HttpAsyncClientBuilder')
   or pmd-java:typeIs('org.apache.http.impl.client.HttpClients')
  )
  and not(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setDefaultRequestConfig')])
  and not(ancestor::ClassOrInterfaceBody//PrimarySuffix[@Image='setRequestConfigCallback']
    and ancestor::ClassOrInterfaceBody//MethodDeclaration[ResultType//ClassOrInterfaceType[@Image='RequestConfig.Builder']]
    /Block[count(.//PrimaryExpression/(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')]) = 3] )
]
,
(: RequestConfig creation without setConnectionRequestTimeout/setConnectTimeout/setSocketTimeout :)
//MethodDeclaration//PrimaryExpression/PrimaryPrefix/Name[
   (pmd-java:typeIs('org.apache.http.client.config.RequestConfig') and @Image='RequestConfig.custom')
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
]
,
(: HttpComponentsClientHttpRequestFactory without httpClient and without setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
    and ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.apache.http')]
   (: not if setHttpClient called on it :)
   and not(ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        (: not if one argument provided (HttpClient) as ctor arg :)
        or ancestor::Expression//Arguments[@Size = 1])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
]
|
(: HttpComponentsClientHttpRequestFactory with local httpClient and with not all three of setConnectionRequestTimeout/setConnectTimeout/[setReadTimeout or setSocketTimeout] :)
//MethodDeclaration//AllocationExpression/ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
    and ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.apache.http')]
   and (ancestor::Block//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setHttpClient')]
        or ancestor::Expression//Arguments//PrimaryPrefix[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout') or ends-with(@Image, 'setSocketTimeout')])>0
]
|
(: HttpComponentsClientHttpRequestFactory as param and with not all three of setConnectionRequestTimeout/setConnectTimeout/setReadTimeout :)
//MethodDeclaration//FormalParameter//ClassOrInterfaceType[
   pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
    and ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image, 'org.apache.http')]
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])<3
   and count(ancestor::MethodDeclaration//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'setConnectionRequestTimeout') or ends-with(@Image, 'setConnectTimeout') or ends-with(@Image, 'setReadTimeout')])>0
]

]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="io,jpinpoint-rule,performance,pitfall" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
        RequestConfig requestConfig = RequestConfig.custom()
            .setSocketTimeout(4000)
            .build(); // bad, not all timeouts set

        return HttpClientBuilder.create()
            .setDefaultRequestConfig(requestConfig) // good
            .build();
            ]]>
        </example>
    </rule>

    <rule name="HttpClientImproperConnectionTimeouts" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="ApacheHttpClient RequestConfig connectionRequestTimeout and connectTimeout have values which are typically too high."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi20">
        <description>org.apache.http.client.config.RequestConfig is used with connectionRequestTimeout and connectTimeout values above 500 milli seconds.
            Problem: 1. connectTimeout is for establishing a connection which should be quick, say below 200 ms.
            2. connectionRequestTimeout is for requesting a connection from the connection manager, which should be almost as quick, say below 250 ms.
            If timeouts are long, requests will wait long for an unavailable service and cause high thread usage and possibly overload.  &#13;
            Solution: Set connectTimeout and connectionRequestTimeout to values based om tests, for instance 200 ms and 250 ms. respectively (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: use of field, local var and return statement :)
//FieldDeclaration[Type/PrimitiveType[@Image='int' or @Image='long']]//VariableDeclaratorId[@Name =
ancestor::ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type
[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory']/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Name/@Image]
/(../VariableInitializer//Literal[number(@Image) > 500]|
  ancestor::ClassOrInterfaceBodyDeclaration//SingleMemberAnnotation[Name/@Image='Value']//Literal[number(substring-before(substring-after(@Image, ':'), '}')) > 500])
,
(: use of literal, local var and return statement : :)
//ClassOrInterfaceDeclaration[//LocalVariableDeclaration/Type[pmd-java:typeIs('org.apache.http.client.config.RequestConfig')
 or pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')
 or @TypeImage='HttpComponentsClientHttpRequestFactory'
]/..//VariableInitializer
|.//ReturnStatement//PrimaryExpression[.//Name/@Image='RequestConfig.custom']]
//(PrimarySuffix[@Image='setConnectionRequestTimeout' or @Image='setConnectTimeout']
    |PrimaryPrefix[./Name[ends-with(@Image, 'setConnectionRequestTimeout')] or ./Name[ends-with(@Image, 'setConnectTimeout')]])
/following-sibling::PrimarySuffix[1]//Literal[number(@Image) > 500]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="io,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.apache.http.client.config.RequestConfig;

public class HttpClientStuff {
    private static final int CONNECTION_TIMEOUTMILLIS = 1000; // bad // timeout until a connection is established
    private static final int CONNECTIONREQUEST_TIMEOUTMILLIS = 5000; // bad // timeout when requesting a connection from the connection manager
    private static final int SOCKET_TIMEOUTMILLIS = 5000; // timeout of waiting for data

    public RequestConfig requestConfigWithTimeouts() {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectionRequestTimeout(CONNECTIONREQUEST_TIMEOUTMILLIS)
                .setConnectTimeout(CONNECTION_TIMEOUTMILLIS)
                .setSocketTimeout(SOCKET_TIMEOUTMILLIS)
                .build();
        return requestConfig;
    }
}
]]>
        </example>
    </rule>

    <rule name="JAXBContextCreatedForEachMethodCall" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="JAXBContext is created for each method call, which is expensive."  typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#iuoxar04">
        <description>Problem: JAXBContext creation is expensive because it does much class loading.  &#13;
            Solution: Since JAXBContext objects are thread safe, they can be shared between requests and reused. So, reuse created instances, e.g. as singletons.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration[not (Annotation//Name[@Image='PostConstruct'])]
 /MethodDeclaration//Expression[pmd-java:typeIs('javax.xml.bind.JAXBContext')]
 /PrimaryExpression/PrimaryPrefix/Name[@Image = 'JAXBContext.newInstance']
                ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="ObjectMapperCreatedForEachMethodCall" message="An ObjectMapper or JsonMapper is created for each method call, which is expensive." class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"   typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#IUOJAR01">
        <description>Problem: Jackson ObjectMapper/JsonMapper creation is expensive because it does much class loading.  &#13;
            Solution: Since ObjectMapper/JsonMapper objects are thread-safe after configuration in one thread, they can be shared afterwards between requests and reused. So, reuse created instances, from a static field.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodDeclaration//Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//PrimaryPrefix[
	(pmd-java:typeIs('com.fasterxml.jackson.databind.json.JsonMapper') and
         ancestor::PrimaryExpression//(PrimaryPrefix/Name|PrimarySuffix)[ends-with(@Image, 'build')]) and
	not(ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name/@Image='Configuration')
],
//MethodDeclaration//VariableDeclarator[
    pmd-java:typeIs('com.fasterxml.jackson.databind.ObjectMapper')
]/VariableInitializer//PrimaryPrefix/Name[ends-with(@Image, 'build')]
			]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-high" type="String" description="classification"/>
         </properties>
        <example>
            <![CDATA[
public static ObjectMapper createMapper() {
    return new ObjectMapper(); // violation
}

public static JsonMapper createMapper() {
    return JsonMapper.builder().build(); // violation
}
            ]]>
        </example>
    </rule>

    <rule name="RetryCanCauseOverload" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Be careful with retrying: multiple retry locations in a call chain can cause overload."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi13">
        <description>Problem: Multiple Retry locations in a call chain multiply the number of calls. For 2x retry on 3 locations (service calls) in a chain calling a system which is just recovering,
            results in 3 x 3 x 3 = 27 calls instead of 1. This may cause it not being able to restart.&#13;
            Solution: Have the retry mechanism in one location in the chain only, recommended only the one closest to the user. (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image='Retry']
,
//Annotation//Name[@Image='Retryable']
,
//FieldDeclaration//ClassOrInterfaceType[@Image='Retry']
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,resilience,suspicious,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import io.github.resilience4j.retry.annotation.Retry;

@Retry(name = "some-service") // inform
public class Foo {
    public Response callSomeService() {
        //...and someService does a Retry for a call to the next service
    }
}
            ]]>
        </example>
    </rule>

    <rule name="SetQueueCapacityForTaskExecutor" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Configure the queue capacity for the ThreadPoolTaskExecutor."
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ia05">
        <description>The org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor queue capacity is not configured.
            Problem: It has a default queue capacity which is unlimited which can lead to an out of memory situation. &#13;
            Solution: Call setQueueCapacity, for instance with a value equal to CorePoolSize.
            Note that the pool will only grow beyond CorePoolSize up to MaxPoolSize when the queue is full. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//LocalVariableDeclaration//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
/ancestor::MethodDeclaration[.//Name[ends-with(@Image,'setCorePoolSize') or ends-with(@Image,'setMaxPoolSize')] and not(.//Name[ends-with(@Image,'.setQueueCapacity')])]
//AllocationExpression/ClassOrInterfaceType[@Image='ThreadPoolTaskExecutor']
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule,memory,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
   private ThreadPoolTaskExecutor bad() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // bad
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }

   private ThreadPoolTaskExecutor good() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setQueueCapacity(10); // good
        executor.setMaxPoolSize(20);
        executor.initialize();
        return executor;
    }
]]>
        </example>
    </rule>

    <rule name="UseCloseableForHttpClient" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="HttpClient is used instead of ClosableHttpClient. "
          typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ibi08">
        <description>Problem: if HttpClient connections are not closed properly when needed, resources are not released and connections may not (or not quick enough) become available from the pool.&#13;
            Solution: Use ClosableHttpClient to allow for invoking close on it to properly close the connection. Or use HttpComponentsClientHttpRequestFactory(httpClient) to let it manage closing. (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: bad: HttpClient without HttpComponentsClientHttpRequestFactory :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')
   and not(ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory')])]
,
(: bad: HttpClient with HttpComponentsClientHttpRequestFactory, yet if passed a param of constructor it is good :)
//LocalVariableDeclaration/Type[pmd-java:typeIsExactly('org.apache.http.client.HttpClient')]
   [ancestor::MethodDeclaration//AllocationExpression/ClassOrInterfaceType
   [pmd-java:typeIs('org.springframework.http.client.HttpComponentsClientHttpRequestFactory') and
   not(../Arguments//Expression[pmd-java:typeIs('org.apache.http.client.HttpClient')])
   and not(ancestor::MethodDeclaration//Name[ends-with(@Image, '.setHttpClient')])]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
        <![CDATA[
   void bad() {
        HttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }

    void good() {
        CloseableHttpClient httpClient = HttpClientBuilder.create()
                .disableConnectionState().build();
    }
    void good2() {
        HttpClient httpClient = HttpClientBuilder.create().disableConnectionState().build();
        ClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'remoting.xml' -->
<!-- BEGIN Included file 'spring.xml' -->
    <rule name="AvoidExpressionsInCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid SpEL-expression for computing Cacheable key" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#improper-caching">
        <description>Spring Expression Language (SpEL) expression is used for computing the key dynamically. Problem: evaluating the expression language is expensive, on every call.&#13;
            Solution: use a custom KeyGenerator: keyGenerator=... instead of key=...
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration//Annotation/NormalAnnotation[Name/@Image='Cacheable']/MemberValuePairs/MemberValuePair[@MemberName='key']
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
class Bad1 {
    @Cacheable(value = "Cache1", key = "#key1") // bad
    public String bad1(final String key1) {
        return getRemote(key1);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidIdentityCacheKeys" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Avoid identity cache keys by casting the generate method parameters" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic13">
        <description>A non-overridden Object.toString may be called on a spring KeyGenerator.generate method parameter. Problem: The non-overridden Object.toString returns a String representing the identity of the object.
            Because this is different for two objects with the same value, cache keys will be different and the cache will only have misses and no hits.&#13;
            Solution: Cast the parameters each to the type used at call site and also check the expected number of params. Or better: return a SimpleKey composed typically of class and method name and the params.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ImplementsList/ClassOrInterfaceType[pmd-java:typeIs("org.springframework.cache.interceptor.KeyGenerator")]
/../..//MethodDeclaration[@Name='generate']
/Block//BlockStatement//(
(ReturnStatement|LocalVariableDeclaration//VariableInitializer)
(:-- exclude if in an if-block checking params.length to do error logging or so --:)
[count(ancestor::IfStatement//Name[ends-with(@Image, '.length')]) = 0]
/Expression[count(.//CastExpression)=0 and count(.//AllocationExpression/ClassOrInterfaceType[@Image='SimpleKey'])=0]
//PrimaryExpression[PrimaryPrefix/Name/@Image
= ancestor::MethodDeclaration//FormalParameter[3]/VariableDeclaratorId/@Name]
|
ForStatement[./Expression//Name[@Image = ancestor::MethodDeclaration//FormalParameter[3]/VariableDeclaratorId/@Name]]
//Arguments//Name[@Image = concat(ancestor::ForStatement/LocalVariableDeclaration//VariableDeclaratorId/@Name, '.toString')]
)
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,cpu,jpinpoint-rule,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.util.StringUtils;

public class Bad implements KeyGenerator {
    public Object generate(Object target, Method method, Object... params) {
        List<Object> objArray = Arrays.asList(params);
        return target.getClass().getName() + "_" + method.getName() + "_"
                + StringUtils.arrayToDelimitedString(params, "_");  // bad, do not concatenate without casting
    }
}

public class Good implements KeyGenerator {
    public Object generate(Object target, Method method, Object... params) {
        if (params.length != 1) {
            throw new IllegalArgumentException("KeyGenerator for GetProfileCache assumes 1 parameter 'profileId', found: " + params);
        }
        String profileId = (String)params[0];
        return profileId;
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidImproperAnnotationCombinations"
          language="java"
          message="Don't combine these annotations"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodeQuality.md#ssc02"
          class="net.sourceforge.pmd.lang.rule.XPathRule">
        <description>
            Improper combination of annotations. Problem: these annotations are not meant to be combined and may cause unexpected and unwanted behavior, e.g. data mix-up.&#13;
            Solution: remove the inappropriate annotation. &#13;
            Don't combine 2+ of [@Component, @Service, @Configuration, @Controller, @RestController, @Repository, @Entity] (Spring/JPA)
            Don't combine @Aspect with one of [@Service, @Configuration, @Controller, @RestController, @Repository, @Entity] (Spring/AspectJ)
            Don't combine [@Data with @Value] and [@Data or @Value] with any of [@ToString, @EqualsHashCode, @Getter, @Setter, @RequiredArgsConstructor] (Lombok)
            Don't combine @Data with any of [@Component, @Service, @Controller, @RestController, @Repository], it may cause user data mix-up.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[count(./Annotation//Name[@Image='Component' or @Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='RestController' or @Image='Repository' or @Image='Entity']) > 1]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Aspect'] and count(./Annotation//Name[@Image='Service' or @Image='Configuration' or @Image='Controller' or @Image='RestController' or @Image='Repository' or @Image='Entity']) > 0]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[count(./Annotation//Name[@Image='Data' or @Image='Value']) > 1]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Data' or @Image='Value'] and ./Annotation/MarkerAnnotation/Name[@Image='ToString' or @Image='EqualsAndHashCode' or @Image='Getter' or @Image='Setter' or @Image='RequiredArgsConstructor']]/Annotation[2]
,
//(TypeDeclaration|ClassOrInterfaceBodyDeclaration/ClassOrInterfaceDeclaration/..)[./Annotation//Name[@Image='Data'] and
exists(./Annotation//Name[@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository'])]/Annotation[not(.//Name/@Image='Data')][1]
                    ]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="confusing,data-mix-up,jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@Component
@Entity // bad
class Bad {
}

@Component
class Good {
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidModelMapAsRenderParameter" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="A ModelMap or @ModelAttribute is used as parameter of a portlet render method and implicitly put in the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu11">
        <description>Problem: ModelMaps are rather large objects containing explicitly added data and administrative data from Spring. They are added to the Portlet session implicitly. They stay in the session for some time: during session activity and 30 minutes (HTTP timeout) after it, in case the user does not exit explicitly. They occupy heap space during that time, for every user.&#13;
            Solution: Remove the ModelMap from the render method parameter list and create a new local ModelMap to use in the render request scope.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public=true()] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.ui.ModelMap')] or
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Annotation/MarkerAnnotation/Name[@Image='ModelAttribute']) and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.portlet.RenderRequest') or pmd-java:typeIs('javax.portlet.PortletRequest')] or
Annotation//Name[@Image='RenderMapping'])]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidSimpleCaches" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Avoid simple caching in production" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic08">
        <description>Simple caches are used. Problem: Simple caching is meant for testing and prototyping, and it lacks manageability and monitorability.&#13;
            Solution: Use a proper cache implementation like ehcache or a cloud cache.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
    //AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.support.SimpleCacheManager') or pmd-java:typeIs('org.springframework.cache.concurrent.ConcurrentMapCache')]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
@EnableCaching
@Configuration
class Bad {
    @Bean public CacheManager cacheManager() {
        return new SimpleCacheManager().setCaches(Arrays.asList(new ConcurrentMapCache("ourCache")));
    }
}

@EnableCaching
@Configuration
class Good {
    @Bean public CacheManager cacheManager() {
		return new EhCacheCacheManager(ehCacheCacheManagerFactory().getObject());
	}
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSimpleKeyCollisions" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Generate a unique SimpleKey by using both method and parameters as composites." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic15">
        <description>
            Problem: Spring's SimpleKey creation lacks either the method or the method parameters, which may cause cache data mix-up.&#13;
            Solution: Create a SimpleKey composed of both the method object and the params Object[]. Make sure the params properly implement equals and hashCode.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[ImplementsList/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.interceptor.KeyGenerator')]]
//MethodDeclaration[@Name='generate']//ClassOrInterfaceType[pmd-java:typeIs('org.springframework.cache.interceptor.SimpleKey')]
[not
  ( (: a method object as 1 arg (preferred) :)
    exists(..//Expression[pmd-java:typeIs('java.lang.reflect.Method')])
    (: or (method.getName and target.getClass) :)
    or(
      exists(..//PrimaryExpression[PrimaryPrefix[pmd-java:typeIs('java.lang.Object')]][PrimarySuffix[pmd-java:typeIs('java.lang.Class')]])
      and
      exists(..//PrimaryExpression[PrimaryPrefix[pmd-java:typeIs('java.lang.reflect.Method')]])
    )
  )
  (: params included :)
  or not(exists(..//Expression[pmd-java:typeIs('java.lang.Object[]')]))
]/../Arguments
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,data-mix-up,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.cache.interceptor.SimpleKey;
import java.lang.reflect.Method;

class BadCacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return new SimpleKey(params); // bad
    }
}

class GoodCacheKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        return new SimpleKey(method, params); // good
    }
}
            ]]>
        </example>
    </rule>

    <rule name="AvoidSpringApplicationContextRecreation"
          message="Avoid re-creation of Spring application context"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#euocs01">
        <description>
            Problem: When a XXXApplicationContext is created, all Spring beans are initialized, wired and component scanning may take place. Component scanning involves extensive class path scanning which is expensive.&#13;
            Solution: Create the ApplicationContext only once in the application deployed/live time.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
   //TypeDeclaration/ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/MethodDeclaration//PrimaryExpression/PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[ends-with(@Image, 'ApplicationContext')
and (
//ImportDeclaration/Name[starts-with(@Image, 'org.springframework.context')]
)]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidSpringMVCMemoryLeaks" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Spring Controller returns an additive expression or a ModelAndView object which may cause a MemoryLeak" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md">
        <description>Avoid to return an additive expression for a Spring Controller because it may cause a MemoryLeak.
            Each new value returned will create a new entry in the View Cache.
            Also avoid to return a ModelAndView object created using non-static and non-final methods because it may
            cause a MemoryLeak.
            Solution: Although multiple solutions exist you can make use of model attributes icw a redirectUrl like
            redirect:/redirectUrl?someAttribute={someAttribute}.(jpinpoint-rules)</description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(
    //Statement/ReturnStatement
    [Expression/AdditiveExpression]
    [ancestor::ClassOrInterfaceBodyDeclaration/Annotation/NormalAnnotation/Name[starts-with(@Image,'RequestMapping')]]
    [ancestor::CompilationUnit/ImportDeclaration/Name[starts-with(@Image,'org.springframework')]]
    [ancestor::MethodDeclaration/MethodDeclarator//Annotation//Name[@Image='RequestParam']]
) | (
    //Block//PrimaryExpression
    [
        PrimaryPrefix/Name[ends-with(@Image,'.setViewName')]
        or (PrimaryPrefix/AllocationExpression/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.web.servlet.ModelAndView')])
    ]
    [
        PrimarySuffix/Arguments/ArgumentList//PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression[1]/PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    |
            PrimaryPrefix/AllocationExpression/Arguments/ArgumentList/Expression//Arguments//PrimaryExpression/PrimaryPrefix/Name[
            (@Image = ancestor::MethodDeclaration//VariableDeclaratorId/@Name)
            or (@Image = ancestor::ClassOrInterfaceBody//FieldDeclaration[@Final=false()]//VariableDeclaratorId/@Name)]
    ]
)
            ]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-low" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="EnsureProperCacheableParams" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Info: Make sure that the parameters that make up the cache key implement the required methods properly." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic16">
        <description>
            Problem: When (1) concatenating or joining parameters in a KeyGenerator: they need to properly implement toString().
            (2) using SimpleKey (recommended): the parameters need to properly implement equals() and hashCode(). Failing to do so may lead to caching data mix-up.&#13;
            Solution: Create a SimpleKey composed of both the method object and the params Object[] and make sure the params properly implement equals and hashCode.
            Note: This rule is just informational, because it cannot actually check if it is implemented correctly or not.
            (jpinpoint-rules)</description>
        <priority>5</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration[.//NormalAnnotation/Name[@Image='Cacheable']]
/MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType
  [(: common safe reference types:)
    not (pmd-java:typeIs('java.lang.String')
        or pmd-java:typeIs('java.lang.Integer')
        or pmd-java:typeIs('java.time.LocalDate')
        or pmd-java:typeIs('org.joda.time.LocalDate')
    )
  ]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="data-mix-up,jpinpoint-rule,suspicious" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.annotation.Cacheable;
import java.time.*;
import java.lang.*;

class Foo {
    @Cacheable(value = "myCache", keyGenerator = "myGenerator")
    public String getDataGood(String str, LocalDate date) {
        return service.getData(input);
    }
    @Cacheable(value = "myCache", keyGenerator = "myGenerator")
    public String getDataInform(MyObject input, String str, LocalDate date) { // inform
        return service.getData(input);
    }
}
class MyObject {
    String field;
    // equals, hashCode, toString missing
}
            ]]>
        </example>
    </rule>

    <rule name="MakeAutoWiredConstructedFieldFinal"
          message="Make autowired, constructed field final in objects shared among threads."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tutc07">
        <description>
            Problem: Multiple threads typically access fields of a singleton or may access fields in session scoped objects. If a field or its reference is mutable, non-autowired access is thread-unsafe and may cause corruption or visibility problems. To make this thread-safe, that is, guard the field e.g. with synchronized methods, may cause contention. &#13;
            Solution: Make the fields final and unmodifiable to defend against mutation. If they really need to be mutable (which is strange for autowired fields), make access thread-safe. Thread-safety can be achieved e.g. by proper synchronization and use the @GuardedBy annotation or use of volatile.&#13;
            Notes&#13;
            1. Autowiring/injection is thread safe, yet make sure no other thread-unsafe assignment is made to that field.&#13;
            2. In case you are sure the Component is used in single threaded context only (e.g. a Tasklet), annotate the class with @NotThreadSafe to make this explicit. &#13;
            3. Use package-private and @VisibleForTesting for methods (e.g. setters) used for JUnit only.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
	//TypeDeclaration/Annotation//Name[(@Image='Component' or @Image='Service' or @Image='Controller' or @Image='RestController' or @Image='Repository' or
(@Image='Singleton' and ancestor::TypeDeclaration/Annotation/NormalAnnotation/MemberValuePairs//Name[@Image='ConcurrencyManagementType.BEAN']))
and not (ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='Scope']/..//Literal[@Image='"request"' or @Image='"prototype"'])
and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='NotThreadSafe'])
and not ((ancestor::TypeDeclaration/Annotation/NormalAnnotation/Name[@Image='ConfigurationProperties'])
             and not (ancestor::TypeDeclaration/Annotation/MarkerAnnotation/Name[@Image='Setter']))]
/../../..//ClassOrInterfaceDeclaration[@Static=false()]/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration[@Final=false() and @Volatile=false()
and not (../Annotation//Name[@Image='Autowired' or @Image='PersistenceContext' or @Image='EJB' or @Image='Resource' or @Image='Inject' or @Image='Value' or @Image='GuardedBy'])
and  (../../ClassOrInterfaceBodyDeclaration/Annotation//Name[@Image='Autowired']
/../../../ConstructorDeclaration//BlockStatement/Statement//StatementExpression/AssignmentOperator/../PrimaryExpression//@Image=
./VariableDeclarator/VariableDeclaratorId/@Name)
]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,multi-threading" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="MinimizeActionModelMapInSession" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="ModelMap in action method is not cleared. This may bloat the session." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#tmsu12">
        <description>A ModelMap is used in an action method typically for form validation and not cleared. Problem: the ModelMap is put in the session by Spring. This is typically a large object which may bloat the session.&#13;
            Solution: clear the ModelMap right after the validation in the happy flow.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceBodyDeclaration
[MethodDeclaration[@Public=true()] and
MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('org.springframework.ui.ModelMap')] and
(MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType[pmd-java:typeIs('javax.portlet.ActionRequest')] or
Annotation//Name[@Image='ActionMapping']) and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image,'.clear')])=0]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="SynchronizeForKeyInCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java" message="Synchronize access for each key in @Cacheable" typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#improper-caching">
        <description>The cache by default allows multiple threads accessing by the same key. Problem: if the value of the key is not available from the cache, it will be fetched/computed by multiple threads while only one time is needed.&#13;
            Solution: Let only the first accessing thread fetch/compute the value and block others until the value is in the cache. Add attribute sync = "true" to achieve this. (Assuming the cache implementation supports it.)
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(//ClassOrInterfaceBodyDeclaration//Annotation/NormalAnnotation[Name/@Image='Cacheable']
,
//ClassOrInterfaceBodyDeclaration//Annotation/MarkerAnnotation[Name/@Image='Cacheable'])[count(MemberValuePairs/MemberValuePair[@MemberName='sync']) = 0]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,jpinpoint-rule,multi-threading,performance,sustainability-low" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
public class Bad1 {
    @Cacheable(value = "Cache1") // bad
    public String bad1() {
    }
}
class Good1 {
    @Cacheable(value = "Cache1", sync = "true")
    public String good1() {
    }
}
            ]]>
        </example>
    </rule>

    <rule name="UseClearKeyGeneratorName" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Use a specific name for this KeyGenerator class which makes clear where to use it." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic17">
        <description>This class implementing Spring's KeyGenerator uses a generic name, CacheKeyGenerator.
            Problem: It is unclear where this KeyGenerator should be used, for which cache and/or for which methods.
            If used on the wrong caches or methods, it may lead to cache key mix-up and user data mix-up.
            Solution: Make the name specific so that it is clear where to apply this KeyGenerator in @Cacheable.
            (jpinpoint-rules)</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassOrInterfaceDeclaration[@SimpleName = 'CacheKeyGenerator' and @Interface = false() and @Abstract = false()]
/ImplementsList/ClassOrInterfaceType[@Image='KeyGenerator']
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,confusing,data-mix-up,jpinpoint-rule" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.interceptor.KeyGenerator;

public class CacheKeyGenerator implements KeyGenerator { // bad, unclear name
   public Object generate(Object target, Method method, Object... params) {
        // build key and return it
   }
}
            ]]>
        </example>
    </rule>

    <rule name="UseExplicitKeyGeneratorForCacheable" class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          message="Use a KeyGenerator to generate a correct and unique key per cached value, do not rely on the implicit default key generation." typeResolution="true"
          externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaCodePerformance.md#ic14">
        <description>
            Problem: With default key generation, an object of Spring's SimpleKey class is used and its value is composed of just the method parameter(s). It does not include the method, which is unclear and risky.&#13;
            Solution: Create a KeyGenerator and make it generate a unique key for the cache per cached value, by use of SimpleKey composed of method object and the parameters.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//Annotation//Name[@Image='Cacheable']
/../MemberValuePairs[count(MemberValuePair[@Image='keyGenerator']) = 0]
	]]></value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="bad-practice,jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
import org.springframework.cache.annotation.Cacheable;
class Foo {

    @Cacheable(cacheNames = {"DATA"}, sync = true, keyGenerator = "cacheKeyGenerator")
    public Object getDataGood(String id) {
        return fetchFromBackend(id);
    }

    @Cacheable(value="DATA", sync = true) // bad, keyGenerator missing
    public Object getDataBad(String id) {
        return fetchFromBackend(id);
    }
}
            ]]>
        </example>
    </rule>

<!-- END Included file 'spring.xml' -->
<!-- BEGIN Included file 'sql.xml' -->
    <rule name="AvoidFetchingWholeList"
          message="Avoid fetching the whole list of entities for the query, while only one entity is used"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trr04">
        <description>
            Problem: Unused rows are fetched and transported, and unused jdbc buffer is allocated.&#13;
            Solution: Use query.getSingleResult() in stead of query.getResultList().
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
(: if getResultList is used to fetsch entities and entities(0) is returned :)
//ReturnStatement//PrimaryExpression[./PrimarySuffix/Arguments//Literal[@Image='0']][./PrimaryPrefix/Name/@Image=
concat(ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name,'.get')
(: not when also the whole list of entities is returnd :)
and not(ancestor::MethodDeclaration//ReturnStatement//PrimaryExpression[./PrimaryPrefix/Name/@Image=
ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name])
(: not when also another elem of entities is returned :)
and not (ancestor::MethodDeclaration//ReturnStatement//PrimaryExpression[./PrimarySuffix/Arguments//Literal[@Image!='0']][./PrimaryPrefix/Name/@Image=
concat(ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]/VariableDeclaratorId/@Name,'.get')])
]/ancestor::MethodDeclaration//VariableDeclarator[./VariableInitializer//Name[ends-with(@Image,'.getResultList')]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,io,jpinpoint-rule,memory,performance,sustainability-high" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    public SomeEntity findByQueryBad(TypedQuery<Object> query) {
        final List<SomeEntity> entities = query.getResultList();
        return !entities.isEmpty() ? entities.get(0) : null;
    }
    public SomeEntity findByQueryGood(TypedQuery<Object> query) throws NoResultException {
        return query.getSingleResult();
    }
            ]]>
        </example>
    </rule>

    <rule name="AvoidHugeQueryFetchSize"
          message="Avoid a huge query fetch size, it consumes much memory."
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trm03">
        <description>
            Problem: if huge numbers of result rows are fetched these are all stored in memory and this may introduce long gc times and out of memory risk.&#13;
            Solution: Set fetch size to 100 maximally. Only set it higher than 100 yet still max 500, if you are sure there is only little data returned per row, like 3 rather short columns.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]
[../..//ArgumentList//Literal[number(@Image) > 500]]]
|
//MethodDeclaration//PrimaryExpression[PrimaryPrefix/Name[ends-with(@Image, '.setFetchSize')]]
[PrimarySuffix//ArgumentList//Name[@Image =
ancestor::ClassOrInterfaceBody//VariableDeclarator/VariableDeclaratorId/@Name
[../../VariableInitializer//Literal[number(@Image) > 500]]]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,memory,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidMultipleRoundtripsForQuery"
          message="Avoid multiple roundtrips for the same query"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-trr05">
        <description>
            Problem: Time is taken by the unnecessary roundtrip(s). Unnecessary work is performed.&#13;
            Solution: Execute the query only once.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration/Block//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')]
[ancestor::MethodDeclaration[count(.//VariableInitializer/Expression/PrimaryExpression/PrimarySuffix[@Image='createQuery']) = 1
and
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getResultList')]) +
count(.//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.getSingleResult')])
> 1]]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="cpu,io,jpinpoint-rule,performance,sustainability-medium" type="String" description="classification"/>
        </properties>
    </rule>

    <rule name="AvoidSqlInExpression"
          message="Avoid a SQL IN-Expression, it fails for > 1000 arguments and pollutes the query plan cache / statement cache"
          class="net.sourceforge.pmd.lang.rule.XPathRule" dfa="false" language="java"
          typeResolution="true" externalInfoUrl="https://github.com/jborgers/PMD-jPinpoint-rules/tree/master/docs/JavaDataAccessPerformance.md#ida-ino01">
        <description>
            Problem: The number of values for the IN-argument list is limited, in Oracle to 1000. An error occurs when exceeding this limit. Additionally, a large IN list takes much time to transport to the database and be parsed. Moreover, each number of IN values used in a query results in a separate cache entry in e.g. the Prepared Statement Cache of the application server and in the Hibernate Query Plan Cache, resulting in higher memory usage and/or low cache hit ratio.&#13;
            Solution: Rewrite the query by replacing the IN-argument list by a sub query using the criteria used to fetch the IN arguments. Or often even better performing, an inner join using these criteria (depending on indexes etc. - recommended to test to be sure.) This way, the select and update are combined into one, which will also save one roundtrip.
            (jpinpoint-rules)</description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration/Block
//Expression/PrimaryExpression/PrimaryPrefix/Name[@Image='InExpression.in']
|
//TypeDeclaration/Annotation/SingleMemberAnnotation/Name[@Image='NamedQueries']
/../MemberValue//PrimaryExpression/PrimaryPrefix/Literal[contains(@Image, 'WHERE') and
(contains(@Image, ' IN(:') or contains(@Image, ' IN (:') or contains(@Image, ' IN :') or contains(@Image, ' IN ( :')) ]
|
//LocalVariableDeclaration/VariableDeclarator/VariableInitializer//PrimaryPrefix/Literal[
contains(@Image, ' IN') and contains(@Image, ':')]
[replace(@Image, '^.+\s+(IN|in)[\s\(]*:([A-z0-9_]+).*$', '"$2"')
=
ancestor::MethodDeclaration//BlockStatement//PrimaryPrefix/Name[ends-with(@Image, '.setParameter')]
(: Arrays.asList is typically used with just a few parameter values, so no problem :)
/../../PrimarySuffix/Arguments/ArgumentList[Expression/PrimaryExpression/PrimaryPrefix/Name[@Image != 'Arrays.asList']]
/Expression/PrimaryExpression/PrimaryPrefix/Literal/@Image],
(: Criteria API: cust.get("postalCode").in(codes) :)
//PrimaryExpression/PrimaryPrefix[pmd-java:typeIs('javax.persistence.criteria.Root')]/..//PrimarySuffix//ArgumentList/ancestor::Expression//PrimarySuffix[@Image='in']
,
(: criteria API: builder.in(cust.get("postalCode") :)
//Expression//PrimarySuffix//Expression//PrimaryPrefix[pmd-java:typeIs('javax.persistence.criteria.Root')]/..//PrimarySuffix//ArgumentList/
ancestor::BlockStatement//PrimaryExpression/PrimaryPrefix/Name[ends-with(@Image, '.in') and
(: good: builder.in(cust.get("postalCode")).value(subquery) :)
(not(exists(ancestor::PrimaryExpression/PrimarySuffix/Arguments//Expression[pmd-java:typeIs('javax.persistence.criteria.Subquery')])))]
]]>
                </value>
            </property>
            <property name="version" value="2.0"/>
            <property name="tags" value="jpinpoint-rule,performance" type="String" description="classification"/>
        </properties>
        <example>
            <![CDATA[
    private void bad(CriteriaQuery cq, Root<Customer> cust) {
        cq.select(cust).where(cust.get("postalCode").in(codes)); // bad
    }
    private void good(CriteriaBuilder builder, CriteriaQuery cq, Root<Customer> cust, SubQuery<PostalCode> subquery) {
        cq.select(cust).where(builder.in(cust.get("postalCode")).value(subquery));
    }
            ]]>
        </example>
    </rule>

<!-- END Included file 'sql.xml' -->
</ruleset>
